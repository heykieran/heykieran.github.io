<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>clojurescript | heykieran Code Notes</title>
    <link>https://heykieran.github.io/tag/clojurescript/</link>
      <atom:link href="https://heykieran.github.io/tag/clojurescript/index.xml" rel="self" type="application/rss+xml" />
    <description>clojurescript</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© Kieran J. Owens 2021</copyright><lastBuildDate>Sun, 07 Jun 2020 15:00:00 -0400</lastBuildDate>
    <image>
      <url>https://heykieran.github.io/images/logo_hu40a566661c85156769430146dbdc8595_41816_300x300_fit_lanczos_3.png</url>
      <title>clojurescript</title>
      <link>https://heykieran.github.io/tag/clojurescript/</link>
    </image>
    
    <item>
      <title>Asynchronous communication streams between a Pedestal server and a ReFrame SPA</title>
      <link>https://heykieran.github.io/post/using-sse-and-websockets/</link>
      <pubDate>Sun, 07 Jun 2020 15:00:00 -0400</pubDate>
      <guid>https://heykieran.github.io/post/using-sse-and-websockets/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In a ReFrame SPA, it&amp;rsquo;s a relatively easy task to asynchronously initiate a backend process using the &lt;code&gt;:http-xhrio&lt;/code&gt; effect handler available in the Reframe library. It&amp;rsquo;s also a rather simple matter of responding to the success and failure events (however they&amp;rsquo;re defined) produced by the back-end process when it &lt;strong&gt;finishes&lt;/strong&gt;. However, what&amp;rsquo;s less obvious is how to capture any &lt;em&gt;system processing&lt;/em&gt; messages issued by the backend process as it progresses, but &lt;strong&gt;before&lt;/strong&gt; it sucessfully completes or fails.&lt;/p&gt;
&lt;p&gt;Two mechanisms available are &lt;strong&gt;websockets&lt;/strong&gt; or &lt;strong&gt;SSE&lt;/strong&gt;. They will both suffice, but each has its own benefits and drawbacks.&lt;/p&gt;
&lt;p&gt;A repo with a working version of this code is available on 
&lt;a href=&#34;https://github.com/heykieran/clj-pedestal-spa/tree/v1.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; (tag &lt;strong&gt;v1.4&lt;/strong&gt;).&lt;/p&gt;
&lt;h2 id=&#34;web-sockets&#34;&gt;Web Sockets&lt;/h2&gt;
&lt;p&gt;WebSockets are an interactive, bi-directional (full duplex), out-of-band communication protocol used for sending messages between web servers and clients. Although WebSocket connections use HTTP ports, WebSockets is not an HTTP protocol. It is a separate TCP protocol with its own semantics. WebSockets enable full-duplex communication between a web client and server, without any need for the polling that is demanded by the half-duplex nature of HTTP.&lt;/p&gt;
&lt;p&gt;The channel is full-duplex and both endpoints (server and client) are immediately aware of any channel changes, such as a disconnection. A problem with this immediate feedback is that both client and server must respond &lt;em&gt;appropriately&lt;/em&gt;. Was the channel closed, or are there network issues? Should the client attempt to reopen the channel? etc.&lt;/p&gt;
&lt;p&gt;Most WebSocket implementations also impose a limit to how long they will maintain an open channel which hasn&amp;rsquo;t transmitted or received data recently. Often we would like to use WebSockets with long periods of time between bursts of activity. Therefore, it is the responsibility of the developer to periodically send &lt;em&gt;ping&lt;/em&gt; messages along the channel in order to remain below the time-out interval and ensure the connection is maintained.&lt;/p&gt;
&lt;h2 id=&#34;sse-server-sent-events&#34;&gt;SSE (Server Sent Events)&lt;/h2&gt;
&lt;p&gt;Server Sent Event is a &lt;em&gt;push&lt;/em&gt; technology which fully exists within the HTTP world (using content type &lt;code&gt;text/event-stream&lt;/code&gt;). SSE allows a server to send a stream of &lt;em&gt;events&lt;/em&gt; to a web client after the client has established an initial connection. Once a connection has been established the client can use the JavaScript EventSource API to subscribe to the stream, and to receive updates as they are issued by the server. The stream will remain open until explicitly closed by either the server or the client.&lt;/p&gt;
&lt;p&gt;SSE streams are uni-directional (simplex) from the server to the client and unlike WebSockets there is no facility available for the client to use the channel to transmit to the server. Helpfully, SSE provides for automatic client reconnections - convenient when network issues are encountered.&lt;/p&gt;
&lt;p&gt;On the other hand, one of the challenges of working with SSE is that generally the server is not aware that a client has disconnected until it attempts to send a message. This can be a resource drain for servers with more than a handful of &lt;em&gt;zombie&lt;/em&gt; clients. Fortunately, most implementations check the &lt;em&gt;liveness&lt;/em&gt; of the connections by automatically issuing periodic heartbeat empty messages to validate the status of the channel.&lt;/p&gt;
&lt;p&gt;Because both the reconnection and heartbeat features are often part of the base implementation of the SSE protocol, SSE is often simpler in use than WebSockets.&lt;/p&gt;
&lt;h1 id=&#34;implementations&#34;&gt;Implementations&lt;/h1&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;For the purpose of this exercise, let&amp;rsquo;s suppose we&amp;rsquo;ve created a Clojure function that performs a number of activities that take some non-trivial amount of time. We&amp;rsquo;ve developed its functionality in the REPL and we&amp;rsquo;re satisfied that it&amp;rsquo;s suitable to be made available at a particular Pedestal controlled URL accessible to our front-end application.&lt;/p&gt;
&lt;p&gt;However, we would also like to be able to execute this function (via the URL) without stalling our front-end application &lt;strong&gt;and&lt;/strong&gt; to be able to monitor its progress as it proceeds to completion. Ideally, we want to receive processing status update messages from the long-running Clojure function and present them to the user in the browser.&lt;/p&gt;
&lt;p&gt;Of course, in order to avoid stalling the front-end interface we can initiate processing using the &lt;code&gt;:http-xhrio&lt;/code&gt; effect handler in ReFrame. However, this will send an AJAX request, executing the function in the background, and to some extent making it inaccessible from our application until it either suceeds or fails.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;:http-xhrio&lt;/code&gt; effect handler can also take a &lt;code&gt;:progress-handler&lt;/code&gt; option, but this isn&amp;rsquo;t really suitable for our current requirements.&lt;/p&gt;
&lt;p&gt;On the client, the approach we&amp;rsquo;ll take is to provide a pair of React component. One that will be used to receive incoming status messages sent by the server, and another to display those messages in the UI. We will implement these components using both WebSockets and SSE streams as the underlying transports.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    In order to fully understand the login process initiated by the client and the server&amp;rsquo;s response, particularly the fields returned, it&amp;rsquo;s probably helpful to review some details. I&amp;rsquo;ve covered this in a previous post which is available &lt;a href=&#34;http://heykieran.github.io/post/pedestal-buddy#the-login-process&#34;&gt;here&lt;/a&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;client-side-react-components&#34;&gt;Client-Side React Components&lt;/h2&gt;
&lt;p&gt;We will implement two React components to provide the message logging functionality: a &lt;code&gt;log-holder-element-ui&lt;/code&gt; component and a &lt;code&gt;log-page-ui&lt;/code&gt; component.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;The client side implementation in the repo contains separate pairs of components for the two transport types &lt;strong&gt;web-socket&lt;/strong&gt; and &lt;strong&gt;SSE&lt;/strong&gt;. The former is in the &lt;code&gt;web.logs&lt;/code&gt; namespace, the latter in the &lt;code&gt;web.sse-logs&lt;/code&gt; namespace.&lt;/p&gt;
&lt;p&gt;Apart from some obvious naming diferences in function names, they are more or less interchangable. For this post I will discuss the web-socket implementation. In another post I intend to outline the SSE implementation, and the manner in which it differs from its web socket &lt;em&gt;sibling&lt;/em&gt;.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;component-1---the-log-page-ui-component&#34;&gt;Component #1 - The &lt;code&gt;log-page-ui&lt;/code&gt; Component&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;log-page-ui&lt;/code&gt; component is the simpler of the two components. It&amp;rsquo;s primary responsibility is to read the vector of messages stored in ReFrame&amp;rsquo;s state db&amp;rsquo;s &lt;code&gt;:log-messages&lt;/code&gt; field and display it in tabular form.&lt;/p&gt;
&lt;p&gt;Each message entry in the vector is a map with keys of &lt;code&gt;:source&lt;/code&gt;, &lt;code&gt;:message&lt;/code&gt; and &lt;code&gt;message-type&lt;/code&gt;. The display component subscribes to the &lt;code&gt;:logs/log-messages&lt;/code&gt; subscription, which retrieves the vector, and displays the results. We won&amp;rsquo;t take a detailed look at this component as it&amp;rsquo;s very simple, but you can review it in the accompanying code repo.&lt;/p&gt;
&lt;h3 id=&#34;component-2---the-log-holder-element-ui-component&#34;&gt;Component #2 - The &lt;code&gt;log-holder-element-ui&lt;/code&gt; Component&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;log-holder-element-ui&lt;/code&gt; component is more complex. It is responsible for populating the ReFrame state db&amp;rsquo;s &lt;code&gt;:log-messages&lt;/code&gt; vector. In order to do so, it opens a connection (web-socket or SSE) to the server, reads incoming messages, and transfers them to the state db.&lt;/p&gt;
&lt;p&gt;The component is also responsible for managing the connection&amp;rsquo;s lifecycle, including any keep-alive requirements and recovery from network errors.&lt;/p&gt;
&lt;p&gt;The component is a &lt;strong&gt;global&lt;/strong&gt; singleton component and is used to manage and control the SPA&amp;rsquo;s entire logging functionality. It exists throughout the SPA&amp;rsquo;s lifetime, and independently of the user&amp;rsquo;s context in the application, or what action he or she is performing. This simplifies server routing of messages. The server can simply direct them at a client instance. The singleton component will then process the message into the SPA&amp;rsquo;s ReFrame state atom, and the contents can be displayed on demand by the &lt;code&gt;log-page-ui&lt;/code&gt; component.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;log-holder-element-ui&lt;/code&gt; component is implemented, in reagent terms, as a Form-3 component. This is necessary because we require access to React&amp;rsquo;s lifecycle functions. Using these methods we can ensure that our component is a singleton, and that only one instance exists within the application even if the logged-in user changes. The lifecycle methods used (adopting reagent&amp;rsquo;s naming convention) are &lt;code&gt;:component-did-mount&lt;/code&gt;, &lt;code&gt;:component-did-update&lt;/code&gt;, &lt;code&gt;:component-will-unmount&lt;/code&gt; and &lt;code&gt;:reagent-render&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;internal-state&#34;&gt;Internal State&lt;/h4&gt;
&lt;p&gt;The component maintains two internal state variables &lt;code&gt;log-atom&lt;/code&gt; and &lt;code&gt;timer-atom&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;log-atom&lt;/code&gt; contains a map with keys &lt;code&gt;:user-id&lt;/code&gt;, &lt;code&gt;:session-id&lt;/code&gt;, &lt;code&gt;:connection-uuid&lt;/code&gt; and &lt;code&gt;:web-socket&lt;/code&gt;, and records an association between an application session identifiers and the web socket servicing that session.&lt;/p&gt;
&lt;p&gt;The SPA as written uses session- and jwt-based authentication. Because a session is shared between browser tabs, the &lt;code&gt;:connection-uuid&lt;/code&gt; value is used to differentiate between tabs within the same session. The &lt;code&gt;:connection-uuid&lt;/code&gt; is determined randomly by the client when it first loads.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;There is also an &lt;code&gt;:ext-token&lt;/code&gt; entry associated with the &lt;code&gt;user&lt;/code&gt; map in the ReFrame db.&lt;/p&gt;
&lt;p&gt;This is part of the application&amp;rsquo;s JWT security implementation. It is used to provide a way to validate the identity of a user in situations where session authentication is not possible.&lt;/p&gt;
&lt;p&gt;When a user logs in to the system the server will generate and return a signed jwt token. This token can be used by the client in subsequent requests to assert a value for the user&amp;rsquo;s identity.&lt;/p&gt;
&lt;p&gt;Because web sockets exist in the Jetty session layer rather than the Pedestal interceptor layer we cannor rely on the authentication and authorization interceptors I discussed in a previous post to provide server-side security for web-socket connection attempts.&lt;/p&gt;
&lt;p&gt;The JWT token (&lt;code&gt;ext-token&lt;/code&gt;) can be used to provide such security.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;timer-atom&lt;/code&gt; is responsible for the keep-alive activities of the connection and will send periodic PING messages to the server, from which it expects a PONG response.&lt;/p&gt;
&lt;p&gt;A websocket is opened by the component by opening a connection to &lt;code&gt;wss://&amp;lt;hostname&amp;gt;:&amp;lt;port&amp;gt;/ws?session-id=&amp;lt;session-id&amp;gt;&amp;amp;connection-uuid=&amp;lt;connection-uuid&amp;gt;&amp;amp;ext-token=&amp;lt;ext-token&amp;gt;&lt;/code&gt; on the server.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;session-id&lt;/code&gt; value is the session identifier requested by the client, which is correlated with the browser session. Therefore, different tabs will share the same &lt;code&gt;session-id&lt;/code&gt; because they share the same browser session.&lt;/p&gt;
&lt;p&gt;As mentioned above the &lt;code&gt;connection-uuid&lt;/code&gt; value is a value generated by the client to identify a particular instance of the application (i.e. browser tab) and the &lt;code&gt;ext-token&lt;/code&gt; value is the jwt token returned by the server when a user logs in (see note above).&lt;/p&gt;
&lt;p&gt;Internally, the server will use the session and connection identifiers to direct messages to the appropriate target client.&lt;/p&gt;
&lt;p&gt;By convention, the &lt;code&gt;session-id&lt;/code&gt; value is a combination of the user&amp;rsquo;s application user-id (a keyword) and a unique integer e.g. &lt;code&gt;:user-12&lt;/code&gt;. The incorporation of the user-id in the session-id in this manner simplifies the processing of certain security restrictions imposed by the server.&lt;/p&gt;
&lt;h4 id=&#34;lifecycle-methods&#34;&gt;Lifecycle Methods&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;:component-did-mount&lt;/code&gt; is responsible for initializing the &lt;code&gt;:timer-atom&lt;/code&gt; and starting the keep-alive process.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:component-did-update&lt;/code&gt; checks if either the current use has logged out, in which case it disconnects the websocket; or if a new user logs in, in which case it creates and connects a new websocket, clears the log messages stored in ReFrame&amp;rsquo;s state db, and finally initializes the internal &lt;code&gt;log-atom&lt;/code&gt; and associates the log session&amp;rsquo;s identifiers with the websocket.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;component-will-unmount&lt;/code&gt; stops the keep-alive process by clearing the the &lt;code&gt;timer-atom&lt;/code&gt; and the &lt;code&gt;log-atom&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:reagent-render&lt;/code&gt; returns a simple empty &lt;code&gt;DIV&lt;/code&gt; element, which seems odd. However, this element is inserted in the static portion of the SPA&amp;rsquo;s main page and created only once when the SPA is loaded.&lt;/p&gt;
&lt;p&gt;The implementation of the &lt;code&gt;log-holder-element-ui&lt;/code&gt; component is included below. The &lt;code&gt;:component-did-update&lt;/code&gt; lifecycle method checks whether the user is logging out i.e. there exists a current session (&lt;code&gt;existing-session-id&lt;/code&gt;) and the &lt;code&gt;new-session-id&lt;/code&gt; value is nil; or whether a new user has logged in.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn log-holder-element-ui
  [{session-id :client-id
    user-id :user
    ext-token :ext-token
    connection-uuid :connection-uuid
    :as current-logged-in-user}]
  (let
    [timer-atom (atom nil)
     log-atom (atom nil)]
    (if connection-uuid
      (ws-utils/connect-ws-for-log
        user-id
        session-id
        connection-uuid
        ext-token
        log-atom)
      (println &amp;quot;No connection-uuid available for logging element &amp;quot;
               &amp;quot;during creation of component&amp;quot;))

    (reagent/create-class
      {:display-name
       :alloc-log-component

       :component-did-mount
       (fn[this]
         (println &amp;quot;Log Component didMount&amp;quot;)
         (reset!
           timer-atom
           (js/setInterval
             (fn[]
               (if @log-atom
                 (ws-utils/send-ping
                   log-atom)))
             (* 1000 60 2))))

       :component-did-update
       (fn[this old-argv]
         (println &amp;quot;Log Component didUpdate&amp;quot;)
         (let [new-argv (rest (reagent/argv this))
               {new-session-id :client-id
                new-connection-uuid :connection-uuid
                new-user-id :user
                new-ext-token :ext-token
                :as current-logged-in-user}
               (first new-argv)
               {existing-user-id :user
                existing-session-id :client-id}
               (first (rest old-argv))]
           (if (and (nil? new-session-id) existing-session-id)
             (do
               (println
                 (str &amp;quot;Clearing websocket for user &amp;quot;
                      (pr-str existing-user-id) &amp;quot;, &amp;quot;
                      &amp;quot;with client-id &amp;quot;
                      (pr-str existing-session-id)))
               (ws-utils/disconnect-web-socket-for-log log-atom)
               (reset! log-atom nil)))
           (if new-session-id
             (do
               (println
                 (str &amp;quot;Creating websocket for user &amp;quot;
                      (pr-str new-user-id)
                      &amp;quot;with client-id &amp;quot;
                      (pr-str new-session-id)))
               (ws-utils/connect-ws-for-log
                 new-user-id
                 new-session-id
                 new-connection-uuid
                 new-ext-token
                 log-atom)))))

       :component-will-unmount
       (fn[this]
         (println &amp;quot;Log Component willUnmount&amp;quot;)
         (js/clearInterval @timer-atom)
         (reset! timer-atom nil)
         (reset! log-atom nil))

       :reagent-render
       (fn[{session-id :client-id :as current-logged-in-user}]
         [:div])})))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above uses a number of utility functions to manage the WebSocket connection. We will taken a deeper look at some of them below.&lt;/p&gt;
&lt;h4 id=&#34;the-web-socket-libary&#34;&gt;The Web Socket Libary&lt;/h4&gt;
&lt;p&gt;The WebSocket library used by our implementation is 
&lt;a href=&#34;https://cljdoc.org/d/haslett/haslett/0.1.6/doc/readme&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;haslett&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(require &#39;[haslett.client :as ws])
(require &#39;[haslett.format :as fmt])
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;connecting&#34;&gt;Connecting&lt;/h5&gt;
&lt;p&gt;Connections are handled by the &lt;code&gt;connect-ws-for-log&lt;/code&gt; function, which is passed a &lt;code&gt;user-id&lt;/code&gt;, &lt;code&gt;session-id&lt;/code&gt;, &lt;code&gt;connection-uuid&lt;/code&gt; and &lt;code&gt;ext-token&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is also passed (in &lt;code&gt;log-atom&lt;/code&gt;) the internal state atom of the &lt;code&gt;log-holder-element-ui&lt;/code&gt; component.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn connect-ws-for-log
  [user-id session-id connection-uuid ext-token log-atom]
  (println &amp;quot;connecting logging websocket for &amp;quot;
           &amp;quot;user &amp;quot; (pr-str user-id) &amp;quot;, with client-id &amp;quot;
           (pr-str session-id) &amp;quot;and connection-uuid &amp;quot;
           (pr-str connection-uuid))
  (let [{existing-websocket :web-socket
         existing-user-id :user-id
         existing-session-id :session-id
         existing-connection-uuid :connection-uuid}
        @log-atom]
    (when existing-websocket
      (if (ws/connected? existing-websocket)
        (do
          (println
            (str &amp;quot;Web Socket is currently connected. &amp;quot;
                 &amp;quot;Closing existing connected websocket for &amp;quot;
                 (keyword (name existing-user-id)
                          (name existing-session-id))
                 &amp;quot; with connection-uuid &amp;quot;
                 (pr-str existing-connection-uuid)))
          (ws/close existing-websocket))
        (println
          (str &amp;quot;Existing websocket to &amp;quot;
               (keyword (name existing-user-id)
                        (name existing-session-id)) &amp;quot; &amp;quot;
               &amp;quot;exists, but it is not connected.&amp;quot;)))))
  (go
    (let
      [web-socket
       (&amp;lt;! (ws/connect
             (str
               api-urls/base-websocket-url
               &amp;quot;?session-id=&amp;quot; session-id
               &amp;quot;&amp;amp;ext-token=&amp;quot; ext-token
               &amp;quot;&amp;amp;connection-uuid=&amp;quot; connection-uuid)
             {:format fmt/transit}))]
      (swap!
        log-atom
        (fn[o n]
          (js/console.log
            &amp;quot;Resetting log details to &amp;quot;
            (pr-str (select-keys n [:user-id :session-id :connection-uuid]))
            &amp;quot; from &amp;quot;
            (pr-str (select-keys o [:user-id :session-id :connection-uuid])))
          n)
        {:user-id user-id
         :session-id session-id
         :connection-uuid connection-uuid
         :web-socket web-socket
         :ext-token ext-token})
      (go
        (loop []
          (when-let
            [msg (&amp;lt;! (:source web-socket))]
            (add-message-to-log msg)
            (recur))))
      (when-let
        [msg (&amp;lt;! (:close-status web-socket))]
        (js/console.log
          &amp;quot;close-status message received -&amp;gt; &amp;quot; (pr-str msg))
        (decide-and-restart
          msg
          user-id
          session-id
          connection-uuid
          ext-token
          log-atom)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function first conducts a number of sanity checks, and then, using haslett&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function, creates a connection to the url on the server. The result of the call to &lt;code&gt;connect&lt;/code&gt; is stored in the state atom that was passed as an argument.&lt;/p&gt;
&lt;p&gt;We use Haslett&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function to create the underlying WebSocket, and specify that the communication format should be &lt;strong&gt;transit&lt;/strong&gt;.  The &lt;code&gt;connect&lt;/code&gt; function returns a promise channel that will create a map containing four elements: a &lt;code&gt;:socket&lt;/code&gt;, a &lt;code&gt;:source&lt;/code&gt;, a &lt;code&gt;:sink&lt;/code&gt; and a &lt;code&gt;:close-status&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;:socket&lt;/code&gt; entry will contain the WebSocket instance that was created. The &lt;code&gt;:source&lt;/code&gt; and &lt;code&gt;:sink&lt;/code&gt; keys are &lt;code&gt;core.async&lt;/code&gt; channels that we will use for reading and writing to the underlying web socket using Clojure&amp;rsquo;s familiar channel metaphors.&lt;/p&gt;
&lt;p&gt;Information about the connection is stored in the &lt;code&gt;log-atom&lt;/code&gt; which is a stateful part of the &lt;code&gt;log-holder-element-ui&lt;/code&gt; component. The information stored is all the information supplied by the client to the server and the websocket instance.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;connect-ws-for-log&lt;/code&gt; function then starts the messages processing loop in a &lt;code&gt;go&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;Within the &lt;code&gt;go&lt;/code&gt; block, as each message is received on the &lt;code&gt;:source&lt;/code&gt; channel connected to the WebSocket, the function &lt;code&gt;add-message-to-log&lt;/code&gt; is called and passed the message&amp;rsquo;s contents as an argument. The &lt;code&gt;add-message-to-log&lt;/code&gt; function inserts the message in ReFrame&amp;rsquo;s state db.&lt;/p&gt;
&lt;p&gt;After the message reading &lt;code&gt;go&lt;/code&gt; loop there is a section of code that responds to close events received in the haslett websocket&amp;rsquo;s &lt;code&gt;:close-status&lt;/code&gt; channel. When a close message event is received, the &lt;code&gt;decide-and-restart&lt;/code&gt; function is called. This function may, depending on the nature of the close event, decide to restart the web socket or not.&lt;/p&gt;
&lt;h5 id=&#34;disconnecting&#34;&gt;Disconnecting&lt;/h5&gt;
&lt;p&gt;The &lt;code&gt;disconnect-web-socket-for-log&lt;/code&gt; function, used when we&amp;rsquo;re shutting down the connection, is also passed the state atom. It closes the WebSocket.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn disconnect-web-socket-for-log
  [log-atom]
  (let
    [{web-socket :web-socket
      user-id :user-id
      session-id :session-id
      connection-uuid :connection-uuid} @log-atom]
    (if (and session-id connection-uuid)
      (do
        (println
          (str &amp;quot;Disconnecting web socket associated with &amp;quot;
               (pr-str user-id) &amp;quot;/&amp;quot; (pr-str session-id)
               &amp;quot; with connection uuid &amp;quot;
               connection-uuid))
        (if (ws/connected? web-socket)
          (ws/close web-socket)
          (println &amp;quot;Unable to close web socket. It&#39;s not connected.&amp;quot;)))
      (println &amp;quot;No session id available. Declined to issue close().&amp;quot;))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;web-socket-keep-alive-client&#34;&gt;Web Socket Keep-Alive (Client)&lt;/h5&gt;
&lt;p&gt;A browser will close a WebSocket if no traffic is seen in some particular interval of time (typically 5 minutes). However, status updates often occur in &lt;em&gt;bursts&lt;/em&gt; with long periods of inactivity between these bursts. When the &lt;code&gt;log-holder-element-ui&lt;/code&gt; component is mounted we start a loop (using &lt;code&gt;js/setInterval&lt;/code&gt;) which calls &lt;code&gt;send-ping&lt;/code&gt;, a function that places (at two minute intervals) a &lt;strong&gt;ping&lt;/strong&gt; message on the channel connected to the WebSocket.&lt;/p&gt;
&lt;p&gt;This let&amp;rsquo;s the server know that it shouldn&amp;rsquo;t close the connection.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn send-ping[log-atom]
  (let
    [{web-socket :web-socket
      user-id :user-id
      session-id :session-id
      ext-token :ext-token
      connection-uuid :connection-uuid} @log-atom]
    (if session-id
      (do
        (println
          (str &amp;quot;Sending Ping for &amp;quot;
               (pr-str user-id) &amp;quot;/&amp;quot;
               (pr-str session-id)
               &amp;quot; at &amp;quot; (pr-str connection-uuid)))
        (if (ws/connected? web-socket)
          (go
            (&amp;gt;! (:sink web-socket)
                {:asys/ping user-id
                 :asys/session-id session-id
                 :asys/connection-uuid connection-uuid}))
          (do
            (println
              (str &amp;quot;PING: No websocket connected. &amp;quot;
                   &amp;quot;Attempting reconnect for &amp;quot;
                   (pr-str user-id) &amp;quot;/&amp;quot;
                   (pr-str session-id) &amp;quot;, &amp;quot;
                   &amp;quot;at &amp;quot; (pr-str connection-uuid)))
            (connect-ws-for-log
              user-id
              session-id
              connection-uuid
              ext-token log-atom))))
      (println &amp;quot;No session id available. No ping sent.&amp;quot;))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the server receives a &lt;strong&gt;ping&lt;/strong&gt; it should respond with a &lt;strong&gt;pong&lt;/strong&gt;. If a web socket isn&amp;rsquo;t connected, and the client expects it to be, the &lt;code&gt;send-ping&lt;/code&gt; will attempt to reopen the connection. This may occur when connectivity is lost and the &lt;code&gt;decide-and-restart&lt;/code&gt; function has declined to reconnect. A consequence of this approach is that if the server goes away for any reason, the client will attempt to reconnect forever.&lt;/p&gt;
&lt;h3 id=&#34;the-server-side&#34;&gt;The Server Side&lt;/h3&gt;
&lt;p&gt;Now we turn our attention to how web socket connections are handled by the server.&lt;/p&gt;
&lt;h4 id=&#34;design-decisions&#34;&gt;Design Decisions&lt;/h4&gt;
&lt;p&gt;In order to decouple the underlying transport mechanism (e.g. WebSocket or SSE) from the Server&amp;rsquo;s higher-level message creation and dispatch functions we first create a single &lt;code&gt;core.async&lt;/code&gt; channel to which we can write our messages destined for the client.&lt;/p&gt;
&lt;p&gt;We also create a publication of this channel using a selector of &lt;code&gt;:topic&lt;/code&gt; on the received message map. A helpful side-effect of this approach is that a publication of a &lt;strong&gt;topic&lt;/strong&gt; without a matching subscription is simply dropped. The &lt;strong&gt;topic&lt;/strong&gt; we&amp;rsquo;ll use for our log messages is &lt;code&gt;:log-msg&lt;/code&gt;. Therefore, a message pushed to our channel with the form &lt;code&gt;{... :topic :log-msg ...}&lt;/code&gt; will be forwarded to our publication.&lt;/p&gt;
&lt;p&gt;Finally, we create a subscription to the &lt;strong&gt;topic&lt;/strong&gt; &lt;code&gt;:log-msg&lt;/code&gt;, and a servicing function to remove messages from it and forward them to the client using whatever transport mechanism is desired. This decoupling serves two purposes: it allows us to change or update our messaging transport without unnecessarily impacting the server&amp;rsquo;s code; and adding other topics is a relatively simple extension.&lt;/p&gt;
&lt;p&gt;We also need an atom to store the Server&amp;rsquo;s active subscription&amp;rsquo;s channel.&lt;/p&gt;
&lt;h4 id=&#34;creating-the-channel--publication&#34;&gt;Creating the Channel &amp;amp; Publication&lt;/h4&gt;
&lt;p&gt;Below is the code that creates the single message channel, its associated publication and the atom
used to store the subscription&amp;rsquo;s channel.&lt;/p&gt;
&lt;p&gt;The atom will be initialized correctly at application startup time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defonce
  server-messages-channel-destined-for-all-clients
  (atom nil))

(defonce
  server-messages-channel
  (chan 100))

(defonce
  server-messages-publication
  (pub server-messages-channel #(:topic %)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;starting-pedestal-with-websocket-support&#34;&gt;Starting Pedestal with WebSocket Support&lt;/h4&gt;
&lt;p&gt;In order for Pedestal/Jetty to start with WebSocket support you must, within its service map&amp;rsquo;s &lt;code&gt;::http/container-options&lt;/code&gt; entry, supply a value for the &lt;code&gt;:context-configurator&lt;/code&gt; key.&lt;/p&gt;
&lt;p&gt;The value should be a reference to a function that configures the Jetty Servlet&amp;rsquo;s web-socket behavior for Pedestal. The function should at least call the &lt;code&gt;add-ws-endpoints&lt;/code&gt; function in the &lt;code&gt;io.pedestal.http.jetty.websockets&lt;/code&gt; namespace. In our application this function is &lt;code&gt;server.messaging.websocket/websocket-configurator-for-jetty&lt;/code&gt; shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn websocket-configurator-for-jetty
  [jetty-servlet-context]
  (ws/add-ws-endpoints
    jetty-servlet-context
    ws-paths))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;add-ws-endpoints&lt;/code&gt; function takes as parameters a ServletContext and a configuration map. The configuration map passed indicates the websocket uri(s) that Jetty should use as web sockets end-points, and also the functions that should be called when the web socket service receives the &lt;code&gt;on-connect&lt;/code&gt;, &lt;code&gt;on-text&lt;/code&gt;, &lt;code&gt;on-error&lt;/code&gt; and &lt;code&gt;on-close&lt;/code&gt; events.&lt;/p&gt;
&lt;p&gt;The configuation map used by the applications is shown below&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{&amp;quot;/ws&amp;quot;
   {:on-connect
    (ws/start-ws-connection
      new-ws-client)
    :on-text
    (fn [raw-msg]
      (process-incoming-text-message raw-msg))
    :on-binary
    (fn [payload offset length]
      (process-incoming-binary-message
        payload offset length))
    :on-error
    (fn [error]
      (process-error error))
    :on-close
    (fn [num-code reason-text]
      (process-close
        num-code reason-text))}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;on-connect&lt;/code&gt; handler uses Pedestal&amp;rsquo;s web-socket functionality to start the connection. Pedestal&amp;rsquo;s &lt;code&gt;start-ws-connection&lt;/code&gt; function takes as its single argument a function that should accept two parameters passed to it by Pedestal: a websocket (of type &lt;code&gt;org.eclipse.jetty.websocket.api.Session&lt;/code&gt;) and an async channel connected to the web socket.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn new-ws-client
  [^Session ws-session send-ch]

  (log/info
    (str &amp;quot;new-ws-client: creating new websocket to client with &amp;quot;
         &amp;quot;uri: &amp;quot; (str (.getRequestURI ^Session ws-session))))
  (let
    [ws-endpoint
     (get-ws-endpoint-from-session ws-session)
     query-string-map
     (some-&amp;gt; ws-session
             (.getRequestURI)
             (.getQuery)
             (route/parse-query-string))
     [session-id ext-token connection-uuid]
     (as-&amp;gt;
       query-string-map v
       (mapv #(get v %) [:session-id :ext-token :connection-uuid]))]
    (if (and session-id connection-uuid)
      (let
        [user-id-from-token
         (or
           (auth-utils/get-id-from-ext-token ext-token)
           :anonymous)
         message-text (str &amp;quot;new-ws-client: starting web socket &amp;quot;
                           &amp;quot;with user &amp;quot; (pr-str user-id-from-token) &amp;quot; &amp;quot;
                           &amp;quot;for session-id &amp;quot; session-id &amp;quot; &amp;quot;
                           &amp;quot;with connection-uuid &amp;quot; (pr-str connection-uuid) &amp;quot; &amp;quot;
                           &amp;quot;from &amp;quot; (pr-str ws-endpoint))
         message (value-&amp;gt;transit-string
                   {:time (gen-utils/get-local-timestamp-with-offset)
                    :text message-text})]

        (log/info message-text)

        (async/put!
          send-ch
          message)

        (swap! ws-clients
               assoc
               (keyword
                 (name (gen-utils/possible-string-as-keyword user-id-from-token))
                 (str connection-uuid))
               [ws-session send-ch
                (keyword
                  (name (gen-utils/possible-string-as-keyword user-id-from-token))
                  (name (gen-utils/possible-string-as-keyword session-id)))]))
      (log/warn (str &amp;quot;No session-id and connection-uuid &amp;quot;
                     &amp;quot;supplied for websocket creation.&amp;quot;
                     &amp;quot;Websocket not created.&amp;quot;)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because web sockets exist in the Jetty session layer rather than the Pedestal routing layer we cannot rely on the authentication and authorization interceptors I discussed in a previous 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-buddy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;post&lt;/a&gt; to provide security for connection attempts at the server&amp;rsquo;s &lt;code&gt;/ws&lt;/code&gt; url. Therefore, before a client is allowed to establish a connection with a particular session-id (which encode the user&amp;rsquo;s id) the jwt token, passed as a query parameter in the connection url, is examined to determine the user&amp;rsquo;s id.&lt;/p&gt;
&lt;p&gt;We can extract the clientâs requested session-id from the url used by the client to request a web-socket connection.&lt;/p&gt;
&lt;p&gt;As described earlier, the form of the url is &lt;code&gt;wss://&amp;lt;hostname&amp;gt;:&amp;lt;port&amp;gt;/ws?session-id=&amp;lt;session-id&amp;gt;&amp;amp;connection-uuid=&amp;lt;connection-uuid&amp;gt;&amp;amp;ext-token=&amp;lt;ext-token&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The ws-clients atom is a record of the currently connected web-socket clients. It contains a map keyed by each clientâs session-id with values that is a vector of the clientâs Session instance and its connected channel.&lt;/p&gt;
&lt;p&gt;If the user has a valid user id the connection is allowed.&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;new-ws-client&lt;/code&gt; we extract the session-id requested by the client, sends a short &lt;em&gt;you&amp;rsquo;re connected&lt;/em&gt; message, and add a vector describing the connection to the &lt;code&gt;ws-clients&lt;/code&gt; atom using a key composed of the user&amp;rsquo;s id and the connection-uuid.&lt;/p&gt;
&lt;p&gt;You&amp;rsquo;ll notice in the &lt;code&gt;on-text&lt;/code&gt; handler function how the server&amp;rsquo;s side of the web socket&amp;rsquo;s &lt;em&gt;keep-alive&lt;/em&gt; functionality is implemented in &lt;code&gt;process-incoming-text-message&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn process-incoming-text-message
  [raw-msg]
  (let
    [message (transit-string-&amp;gt;value raw-msg)]
    (log/info &amp;quot;Websocket message received &amp;quot;
              (pr-str message))
    (if
      (and
        (map? message)
        (contains? message :asys/ping))
      (let
        [{user-id :asys/ping
          session-id :asys/session-id
          connection-uuid :asys/connection-uuid} message]
        (send-messages-to-clients
          {:msg
           {:asys/pong user-id
            :asys/session-id session-id
            :asys/connection-uuid connection-uuid}
           :target-client
           (keyword
             (name user-id)
             (str connection-uuid))}))
      (log/warn
        (str &amp;quot;Unexpected websocket message received: &amp;quot;
             (pr-str message) &amp;quot;, type: &amp;quot;
             (type message))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the server receives a message with an &lt;code&gt;:asys/ping&lt;/code&gt; key, the server automatically responds with an &lt;code&gt;:asys/pong&lt;/code&gt; message. The value of the &lt;code&gt;:asys/ping&lt;/code&gt; entry is the user id, session identifier and connection uuid of the client that sent the ping message and enables the server to direct its response correctly.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-message-processing&#34;&gt;Starting the Message Processing&lt;/h4&gt;
&lt;p&gt;When the application starts the web-server, the &lt;code&gt;message-transport&lt;/code&gt; function is also called to initialize the application&amp;rsquo;s messaging functionality. This function takes two parameters, a &lt;code&gt;transport-type&lt;/code&gt; (which can be either &lt;code&gt;:web-socket&lt;/code&gt; or &lt;code&gt;:sse&lt;/code&gt;) and the atom used to store the subscription&amp;rsquo;s channel.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn message-transport
  [transport-type message-channel-atom]
  (start-processing-sub transport-type message-channel-atom))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;message-transport&lt;/code&gt; function calls &lt;code&gt;start-processing-sub&lt;/code&gt; which is the function that starts the go loop - accepting messages from the subscription channel and forwarding them to the client(s).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn start-processing-sub
  [transport-type message-channel-atom]
  ;; If the channel already exists, then close it.
  (when-let [ch (deref message-channel-atom)]
    (async/close! ch))
  ;; subscribe a channel to be contained in the
  ;; server-messages-channel-destined-for-all-clients atom
  ;; to the server-messages-publication with the topic of
  ;; :log-msg i.e. anything in the publication with key of
  ;; :topic and a value of :log-msg
  (async/sub
    rlog/server-messages-publication
    :log-msg
    (reset! message-channel-atom (async/chan)))
  ;; start a go-loop that takes messages off the channel in the
  ;; atom and pass it to the send-messages-to-clients function
  (log/info &amp;quot;Starting &amp;quot; (pr-str transport-type) &amp;quot; log message loop&amp;quot;)
  (async/go
    (loop []
      (when-let
        [log-msg (async/&amp;lt;! (deref message-channel-atom))]
        (send-messages-to-clients transport-type log-msg)
        (recur)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;send-messages-to-clients&lt;/code&gt; function is defined as a multi-method which selects on the &lt;code&gt;transport-type&lt;/code&gt; value and makes sure that the correct &lt;code&gt;send-&lt;/code&gt; function(s) are called for the selected transport type.&lt;/p&gt;
&lt;p&gt;Essentially, this gets reduced to calling the &lt;code&gt;send-messages-to-client&lt;/code&gt; function in either the &lt;code&gt;server.messaging.websocket&lt;/code&gt; or the &lt;code&gt;server.messaging.sse&lt;/code&gt; namespaces.&lt;/p&gt;
&lt;h4 id=&#34;sending-messages&#34;&gt;Sending Messages&lt;/h4&gt;
&lt;p&gt;If we review the &lt;code&gt;send-message-&lt;/code&gt; functions in the &lt;code&gt;server.messaging.websocket&lt;/code&gt; namespace, we can see how they work. (The implementation for SSE is similar, and simpler).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;send-messages-to-clients&lt;/code&gt; function is the namespace&amp;rsquo;s main public function. It accepts as an argument a map representing the message to be sent. Within the map is an entry &lt;code&gt;:target-client&lt;/code&gt; which indicates the message&amp;rsquo;s destination. The function handles broadcast messages, i.e. messages destined for all connected clients, and also messages destined for only one client. In either case, this function will call the private function &lt;code&gt;send-message-to-client&lt;/code&gt; in the same namespace as many times as is necessary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn send-messages-to-clients
  [{message :msg
    target-client :target-client
    message-type :message-type
    :as whole-message}]
  (if (and (some? target-client)
           (not= :none target-client))
    (do
      (log/info
        (str &amp;quot;websocket: asked to send message to clients &amp;quot;
             (pr-str target-client)
             &amp;quot;, msg: &amp;quot;
             (pr-str whole-message)))
      (if (= :all target-client)
        (doseq
          [target-client (keys @ws-clients)]
          (send-message-to-client
            target-client
            message
            message-type))
        (send-message-to-client
          target-client
          message
          message-type)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;send-message-to-client&lt;/code&gt; is shown below. It take a &lt;code&gt;session-id&lt;/code&gt; indicating the message&amp;rsquo;s destination and a &lt;code&gt;message&lt;/code&gt; which is a map.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn- send-message-to-client
  [connection-identifier message &amp;amp; [message-type]]
  (log/info
    (str &amp;quot;Asked to send web-socket message to individual client &amp;quot;
         (pr-str connection-identifier)
         &amp;quot;, msg is &amp;quot;
         (pr-str message)))
  (if-let
    [ws-connections (get-ws-conns-for-session-id
                      @ws-clients
                      connection-identifier)]
    (doall
      (map
        (fn[connection-key]
          (if-let
            [[ws-session send-ch combined-session-id]
             (get @ws-clients connection-key)]
            (if (or
                  (not (.isOpen ws-session))
                  (ap/closed? send-ch))
              (do
                (log/warn
                  &amp;quot;While trying to send-message-to-client,&amp;quot;
                  &amp;quot;found websocket or websocket channel was closed.&amp;quot;
                  &amp;quot;combined-session-id&amp;quot; (pr-str combined-session-id)
                  &amp;quot;connection-key &amp;quot; (pr-str connection-key))
                (clean-up-ws-clients))
              (async/put!
                send-ch
                (value-&amp;gt;transit-string
                  {:time (gen-utils/get-local-timestamp-with-offset)
                   :text message
                   :message-type (or message-type :info)})
                (fn[v]
                  (log/debug
                    (str
                      &amp;quot;put! in send-message-to-client &amp;quot;
                      (pr-str connection-key)
                      &amp;quot; returned &amp;quot;
                      (pr-str v))))))
            (log/warn (str &amp;quot;Couldn&#39;t find websocket session &amp;quot;
                           &amp;quot;for client connection &amp;quot;
                           (pr-str connection-key)
                           &amp;quot;. Available connections &amp;quot;
                           &amp;quot;are &amp;quot; (pr-str (keys @ws-clients))))))
        ws-connections))
    (log/warn &amp;quot;Couldn&#39;t find any web sockets for target-client&amp;quot;
              (:target-client message))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;connecting-the-long-running-clojure-function&#34;&gt;Connecting the long-running Clojure function&lt;/h2&gt;
&lt;p&gt;Now that the messaging infrastructure is in place we&amp;rsquo;ll turn our attention to &amp;ldquo;instrumenting&amp;rdquo; our clojure function to send status update message.&lt;/p&gt;
&lt;p&gt;A convenient, but not the only, approach is to leverage Clojure&amp;rsquo;s logging functionality. Often, within a Clojure we will often use calls to &lt;code&gt;log/info&lt;/code&gt; and &lt;code&gt;log/debug&lt;/code&gt; calls to mark and record important processing events. We could take the opportunity to selectively forward some of these messages to the remote client giving it feedback similar to what might be seen if the function was run in a REPL.&lt;/p&gt;
&lt;p&gt;This is the approach I&amp;rsquo;ve chosen.&lt;/p&gt;
&lt;p&gt;First I create a macro that can wrap a call to functions in &lt;code&gt;log&lt;/code&gt; namespace, but which can also accept a &lt;code&gt;session-id&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmacro with-forward-context
  ([body]
   (list `with-forward-context nil body))
  ([target-id body]
   (list `with-forward-context target-id body {}))
  ([target-id body options]
   (list &#39;do body
         (list
           `apply
           `write-message-to-server-message-channel
           (concat
             (list
               &#39;list
               (list &#39;clojure.string/join &amp;quot; &amp;quot;
                     (conj
                       (map
                         #(if
                            (instance? java.lang.Throwable %)
                            &amp;quot;ERROR&amp;quot;
                            (list
                              &#39;clojure.string/trim
                              (list
                                `str %)))
                         (rest body))
                       &#39;list)))
             (if target-id
               (list target-id)
               &#39;())
             (if options
               (list options)
               &#39;()))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can selectively wrap any &lt;code&gt;log&lt;/code&gt; calls we like as follow:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(rlog/with-forward-context
      session-id
      (log/info &amp;quot;OK&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result is that the message is logged in the usual fashion, but a call to &lt;code&gt;write-message-to-server-message-channel&lt;/code&gt; is also made, ensuring that the content of the log message is also sent to the client matching &lt;code&gt;session-id&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;closure&#34;&gt;Closure&lt;/h1&gt;
&lt;p&gt;Hopefully, if you&amp;rsquo;re attempting to use websockets with your ClojureScript SPA this has been helpful in some small way. In a subsequent post I will discuss implementing a similar for of messaging but using SSE.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Add a Custom Authentication Backend to a Clojure Pedestal Application using Buddy</title>
      <link>https://heykieran.github.io/post/adding-a-custom-auth-backend/</link>
      <pubDate>Sat, 06 Jun 2020 05:49:44 -0400</pubDate>
      <guid>https://heykieran.github.io/post/adding-a-custom-auth-backend/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In two earlier posts (available 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-buddy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; and 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-and-google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;) I showed how to use the &lt;code&gt;buddy-auth&lt;/code&gt; library to develop an SPA that uses &lt;em&gt;session-based&lt;/em&gt; (or session cookie) security. The SPA accompanying that post (and available on 
&lt;a href=&#34;https://github.com/heykieran/clj-pedestal-spa/tree/v1.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt; tag &lt;strong&gt;v1.0&lt;/strong&gt;) was also capable of using Google credentials to authenticate the user.&lt;/p&gt;
&lt;p&gt;In this post I will provide further details on how the Google web authentication works, and I will show how to add additional authentication mechanisms (&lt;strong&gt;jwt&lt;/strong&gt; and &lt;strong&gt;Google IAP&lt;/strong&gt;) by developing a custom backend for use with &lt;code&gt;buddy-auth&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;client-side-google-sign-in&#34;&gt;Client-Side Google Sign-In&lt;/h2&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Credit where credit is due: The client-side code is based on excellent work done by Tristan Straub which is available on &lt;a href=&#34;https://github.com/tristanstraub/cljs-google-signin&#34;&gt;Github&lt;/a&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;GAPI&lt;/strong&gt; is a library provided by Google that enables browser-hosted javascript code to call Google API&amp;rsquo;s. It is available at 
&lt;a href=&#34;https://apis.google.com/js/platform.js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://apis.google.com/js/platform.js&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Amongst other functionality, it also includes the code we&amp;rsquo;ll need to interact with the endpoints used by Google Sign-In, which is used to generate the OAuth 2.0 credentials for the user.&lt;/p&gt;
&lt;p&gt;On the client-side we&amp;rsquo;ll first need to ensure that the &lt;strong&gt;GAPI&lt;/strong&gt; library is loaded. This is done using the &lt;code&gt;&amp;lt;ensure-gapi!&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;&amp;lt;ensure-gapi!&lt;/code&gt; function first checks if the &lt;strong&gt;GAPI&lt;/strong&gt; library has already been loaded. If not, it will call the function &lt;code&gt;&amp;lt;load-script&lt;/code&gt; to do so.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn- &amp;lt;ensure-gapi!
  [client-id]
  (go
    (when-not (exists? js/gapi)
      (&amp;lt;!
        (&amp;lt;load-script
          config/google-script-location)))
    (&amp;lt;! (&amp;lt;init-gapi! client-id))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;load-script&lt;/code&gt; is an interesting function. It first creates an HTML &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element in memory, and sets its source attribute to &lt;code&gt;https://apis.google.com/js/platform.js&lt;/code&gt;. It then create a promise (as a channel using &lt;code&gt;&amp;lt;cb&lt;/code&gt;) to load the javascript file, adds the &lt;code&gt;&amp;lt;SCRIPT&amp;gt;&lt;/code&gt; element to the DOM, and returns the channel/promise.&lt;/p&gt;
&lt;p&gt;After loading the &lt;strong&gt;GAPI&lt;/strong&gt; libraries, the &lt;code&gt;&amp;lt;ensure-gapi!&lt;/code&gt; function calls &lt;code&gt;&amp;lt;init-gapi!&lt;/code&gt; to initialize the &lt;code&gt;auth2&lt;/code&gt; components of the library, and to create the &lt;code&gt;GoogleAuth&lt;/code&gt; object. These are the components that we&amp;rsquo;ll use to get an OAuth 2.0 credentials claim from Google on behalf of a user.&lt;/p&gt;
&lt;p&gt;On the SPA&amp;rsquo;s &lt;strong&gt;Users&lt;/strong&gt; page, we can display a styled Google Sign-In button by calling the &lt;code&gt;gapi.signin2.render&lt;/code&gt; function. This function takes a DOM element, within which it will render the sign-in button, and a map of parameters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(js/gapi.signin2.render
        el
        #js {&amp;quot;scope&amp;quot;     &amp;quot;profile email&amp;quot;
             &amp;quot;width&amp;quot;     144
             &amp;quot;height&amp;quot;    30
             &amp;quot;longtitle&amp;quot; false
             &amp;quot;theme&amp;quot;     &amp;quot;dark&amp;quot;
             &amp;quot;onsuccess&amp;quot; on-success
             &amp;quot;onfailure&amp;quot; on-failure})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;scope&lt;/code&gt; parameter in the options map sets the user identity elements we&amp;rsquo;d like returned by Google, and &lt;code&gt;on-success&lt;/code&gt; and &lt;code&gt;on-failure&lt;/code&gt; are Clojurescript functions called according to whether the authentication attempt succeeded or failed.&lt;/p&gt;
&lt;p&gt;When the user clicks on the Sign-In button, a second browser window will open to a secure Google URL where the user can enter his or her credentials. If the authentication is successful the &lt;code&gt;on-success&lt;/code&gt; function is called with an instance of &lt;code&gt;GoogleUser&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then, by calling &lt;code&gt;GoogleUser.getAuthResponse&lt;/code&gt; we can retrieve the &lt;code&gt;AuthResponse&lt;/code&gt; map; and from that we can get the &lt;code&gt;id_token&lt;/code&gt;, which is the ID token granted by Google.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn [google-user]
            (println &amp;quot;running google-login-button on-success function&amp;quot;)
            (let
              [token (some-&amp;gt;
                       google-user
                       (ocall &amp;quot;getAuthResponse&amp;quot;)
                       (oget &amp;quot;id_token&amp;quot;))]
              (when token
                (&amp;lt;post-to-server
                  token))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given our requested scopes, the &lt;code&gt;AuthResponse&lt;/code&gt; will also contain the user&amp;rsquo;s Google email address. However, this isn&amp;rsquo;t to be trusted. The correct (and secure) way to confirm the email address is to validate the ID token using server-side code, before extracting the email address.&lt;/p&gt;
&lt;p&gt;In order to do this the success function submits the token to the server for validation using an Ajax POST request.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn- &amp;lt;post-to-server
  [token]
  (let
    [form-data
     (str &amp;quot;idtoken=&amp;quot; token &amp;quot;&amp;amp;connection-uuid=&amp;quot; (random-uuid))]
    (POST
      config/google-callback-url
      {:body form-data
       :response-format :raw
       :with-credentials true
       :handler (fn[r]
                  (js/console.log &amp;quot;Server Response from Google Login&amp;quot;)
                  (js/console.log r)
                  (js/console.log &amp;quot;will confirm with server&amp;quot;)
                  (rf/dispatch
                    [:auth/get-logged-in-user]))
       :error-handler (fn[e]
                        (js/console.log &amp;quot;Server Error&amp;quot;)
                        (js/console.log e))})))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our application the address stored in &lt;code&gt;config/google-callback-url&lt;/code&gt; is &lt;code&gt;https://&amp;lt;server-name&amp;gt;/auth/google&lt;/code&gt; which is a Pedestal route configured, at the end of its interceptor chain, to call the &lt;code&gt;alloc-auth-google-login&lt;/code&gt; handler function.&lt;/p&gt;
&lt;p&gt;Within this function a call is made to &lt;code&gt;verify-google-token-response&lt;/code&gt;, passing the POST request&amp;rsquo;s &lt;code&gt;idtoken&lt;/code&gt; value. The verify function uses the &lt;code&gt;com.google.api.client.googleapis.auth.oauth2&lt;/code&gt; java library to validate the token and extract the email address.&lt;/p&gt;
&lt;p&gt;The server will then create an &lt;code&gt;identity-token&lt;/code&gt; as explained 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-buddy/#the-login-process&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;, and add it to the Ring session&amp;rsquo;s &lt;code&gt;:identity&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;From this point, the client/server behaviors are as they would be for other session-based authentication types.&lt;/p&gt;
&lt;h2 id=&#34;google-iap&#34;&gt;Google IAP&lt;/h2&gt;
&lt;p&gt;Google IAP (Identity Aware Proxy) is a context-aware reverse proxy service available within the Google Cloud product line. It sits between the internet and your application&amp;rsquo;s resources and ensures that access to those resources is granted only to users who have the appropriate Cloud IAM role(s).&lt;/p&gt;
&lt;p&gt;When a new user attempts to access a resource protected by IAP, IAP will direct the user to a Google OAuth 2.0 sign-in flow where the user can enter his or her credentials. If those credentials are correct, IAP will then assess whether the user is authorized to access the resource by checking the user&amp;rsquo;s roles and permissions. If everything checks out, the request is forwarded to the resource with the user&amp;rsquo;s JWT claim token added to the request&amp;rsquo;s headers in the &lt;strong&gt;x-goog-iap-jwt-assertion&lt;/strong&gt; field.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;It is the responsibility of the application to verify the validity of this token using Google&amp;rsquo;s public keys.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;From the user&amp;rsquo;s perspective, the sign-in flow is similar to the flow used by the client-side sign-in described above, but with the result of a sucessful authentication being the addition of the &lt;strong&gt;x-goog-iap-jwt-assertion&lt;/strong&gt; header and the token to the request&amp;rsquo;s headers rather than calling the &lt;code&gt;on-success&lt;/code&gt; function in the browser.&lt;/p&gt;
&lt;p&gt;IAP uses one of a number of different keys to sign the header. The public component of these keys is published (in JWK format) at 
&lt;a href=&#34;https://www.gstatic.com/iap/verify/public_key-jwk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;https://www.gstatic.com/iap/verify/public_key-jwk&lt;/code&gt;&lt;/a&gt;. As far as I can tell, there is no way to determine which of the available keys Google will use to sign the JWT claim, although the signed token will include in its &lt;code&gt;:kid&lt;/code&gt; field the &lt;strong&gt;id&lt;/strong&gt; of the key used to sign it.&lt;/p&gt;
&lt;h2 id=&#34;the-challenge&#34;&gt;The Challenge&lt;/h2&gt;
&lt;p&gt;Session backends work just fine and, if handled well, provide perfectly adequate security. In my earlier post I showed how it is possible to integrate Google web login with our Reframe SPA, and although the authentication was performed by Google the end result is that the validated Google identity was inserted into the client&amp;rsquo;s session.&lt;/p&gt;
&lt;p&gt;However, there are circumstances in which session authentication &amp;amp; authorization will not work - for example when a browser session doesn&amp;rsquo;t exist. This may occur when making calls to HTTP API endoints from clients other than a browser e.g. server calls, calls from desktop clients, or calls mediated by service orchestration engines.&lt;/p&gt;
&lt;p&gt;In such cases, the use of authorization bearer tokens, such as JWT, is a better approach. The &lt;code&gt;buddy-auth&lt;/code&gt; library comes with a number of included backends, with one of which that can use JWT tokens. However, its implementation assumes that the JWT token will be included in the &lt;strong&gt;Authorization&lt;/strong&gt; header of the request. If our application is using IAP this won&amp;rsquo;t be the case. Therefore we&amp;rsquo;ll need to provide our own backend.&lt;/p&gt;
&lt;h2 id=&#34;buddy-backends&#34;&gt;Buddy Backends&lt;/h2&gt;
&lt;p&gt;A Buddy backend is simply an instance of an object that implements two protocols: &lt;code&gt;IAuthentication&lt;/code&gt; and &lt;code&gt;IAuthorization&lt;/code&gt;. Our custom backend (&lt;code&gt;jws-embedded&lt;/code&gt;) which implements these protocols can be found in the &lt;code&gt;server.auth.header&lt;/code&gt; namespace and mimics closely the &lt;code&gt;jws&lt;/code&gt; backend provided by Buddy.&lt;/p&gt;
&lt;h3 id=&#34;iauthentication&#34;&gt;IAuthentication&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;IAuthentication&lt;/code&gt; protocol defines two member functions: &lt;code&gt;-parse&lt;/code&gt; and &lt;code&gt;-authenticate&lt;/code&gt;. The former is responsible only for inspecting the request and parsing from it the material to be passed to &lt;code&gt;-authenticate&lt;/code&gt;. The standard implemenation of the Buddy middleware, initiated in the interceptor returned by our &lt;code&gt;alloc-auth-authentication-interceptor&lt;/code&gt; function (taking a backend as a parameter) ensures that if the call to &lt;code&gt;-parse&lt;/code&gt; in the backend returns nil, then the backend&amp;rsquo;s &lt;code&gt;-authenticate&lt;/code&gt; function won&amp;rsquo;t be called.&lt;/p&gt;
&lt;h3 id=&#34;iauthorization&#34;&gt;IAuthorization&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;IAuthorization&lt;/code&gt; protocol requires only a single function, &lt;code&gt;-handle-unauthorized&lt;/code&gt; which will be called with parameters of the request and some metadata when an authenticated request is not authorized to access a resource.&lt;/p&gt;
&lt;p&gt;Remember the &lt;code&gt;alloc-auth-authentication-interceptor&lt;/code&gt; function, which takes a backend as a parameter, creates an interceptor whose &lt;code&gt;:enter&lt;/code&gt; method adds to the received context a key &lt;code&gt;:auth/backend&lt;/code&gt; and attaches the backend parameter as its value. The &lt;code&gt;:enter&lt;/code&gt; function updates the &lt;code&gt;:request&lt;/code&gt; map using the &lt;code&gt;buddy.auth.middleware/authentication-request&lt;/code&gt; function with the backend parameter. This hooks up Buddy middleware (tying the &lt;code&gt;-parse&lt;/code&gt; and &lt;code&gt;-authenticate&lt;/code&gt; members together, ensuring that if &lt;code&gt;-parse&lt;/code&gt; return nil then &lt;code&gt;-authenticate&lt;/code&gt; isn&amp;rsquo;t called)&lt;/p&gt;
&lt;h2 id=&#34;the-implementation&#34;&gt;The Implementation&lt;/h2&gt;
&lt;p&gt;The custom backend is created by the &lt;code&gt;jws-embedded-backend&lt;/code&gt; function, shown below. As you can see, it implements the two required protocols.&lt;/p&gt;
&lt;p&gt;The backend is implemented in such a way as to authenticate using either the &lt;em&gt;session&lt;/em&gt; &lt;strong&gt;or&lt;/strong&gt; the &lt;em&gt;header&lt;/em&gt; information. This is accomplished in the &lt;code&gt;-parse&lt;/code&gt; function which calls &lt;code&gt;parse-embedded-header&lt;/code&gt;. If a request session is detected and it contains an &lt;code&gt;:identity&lt;/code&gt; field then &lt;code&gt;parse-embedded-header&lt;/code&gt; simply returns a 2-vector of `[:session &lt;identity&gt;].&lt;/p&gt;
&lt;p&gt;If not, and the request headers contain a field matching one of the names we&amp;rsquo;ve reserved for our JWT token the &lt;code&gt;parse-embedded-header&lt;/code&gt; returns a 2-vector of &lt;code&gt;[:token &amp;lt;embedded-token-value&amp;gt;]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By implementing the backend in this way, and in the abscence of embedded headers, the &lt;em&gt;session&lt;/em&gt;-based authentication logic will work as before when we used Buddy&amp;rsquo;s included session backend, and any authentication logic based on the request&amp;rsquo;s headers is skipped.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn jws-embedded-backend
  [{:keys [authfn unauthorized-handler options token-names on-error]}]
  {:pre [(ifn? authfn)]}
  (reify
    proto/IAuthentication
    (-parse [_ request]
      (parse-embedded-header request token-names))
    (-authenticate [_ request [auth-type session-or-token]]
      (try
        ;; parse-embedded-header will return a 2-vector
        ;; with either :session of :token in the first
        ;; position indicating how the identity is/should be
        ;; determined.
        (case auth-type
          :token
          ;; if we&#39;ve a token, attempt to identify the user using it
          (authfn request session-or-token)
          :session
          ;; if we&#39;ve a session with an identity, just accept it
          session-or-token)
        (catch clojure.lang.ExceptionInfo e
          (let [data (ex-data e)]
            (when (fn? on-error)
              (on-error request data))
            nil))))

    proto/IAuthorization
    (-handle-unauthorized [_ request metadata]
      (if unauthorized-handler
        (unauthorized-handler request metadata)
        (#&#39;token/handle-unauthorized-default request)))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the &lt;code&gt;-parse&lt;/code&gt; function returns a non-nil value then &lt;code&gt;-authenticate&lt;/code&gt; is called and the case statement will decide how to handle the actual authentication. As with the session backend if the 2-vector&amp;rsquo;s first element is &lt;code&gt;:session&lt;/code&gt; we use the second element of the vector as the identity. On the other hand, if the first element is &lt;code&gt;:token&lt;/code&gt; we call the &lt;code&gt;authfn&lt;/code&gt; to validate the token and extract the user&amp;rsquo;s identity.&lt;/p&gt;
&lt;p&gt;The implementation of &lt;code&gt;-handle-unauthorized&lt;/code&gt; either calls the default unauthorized handler, or a handler function passed to the &lt;code&gt;jws-embedded-backend&lt;/code&gt; function using the &lt;code&gt;:unauthorized-handler&lt;/code&gt; key in the options map.&lt;/p&gt;
&lt;p&gt;Also, &lt;code&gt;authfn&lt;/code&gt; is an option parameter passed to the &lt;code&gt;jws-embedded-backend&lt;/code&gt; function and is created when we def&amp;rsquo;d the backend&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def alloc-auth-google-header-token-auth-backend
  (jws-embedded
    {:authfn      token-authfn
     :token-names [&amp;quot;x-goog-iap-jwt-assertion&amp;quot; &amp;quot;x-debug-token&amp;quot;]
     :on-error
                  (fn [request ex-data]
                    (log/error
                      &amp;quot;Request to&amp;quot;
                      (:uri request)
                      &amp;quot;threw exception: &amp;quot;
                      ex-data))
     :unauthorized-handler
                  (fn unauthorized-handler
                    [request metadata]
                    (let [{user         :user
                           roles        :roles
                           required     :required
                           user-session :user-session}
                          (get-in metadata [:details :request])
                          user-response-session
                          (keyword
                            (if user (name user) &amp;quot;anonymous&amp;quot;)
                            (if user-session (name user-session) &amp;quot;anonymous&amp;quot;))
                          error-message
                          (str &amp;quot;NOT AUTHORIZED (HEADER): In unauthenticated handler for &amp;quot;
                               &amp;quot;uri: &amp;quot; (pr-str (:uri request)) &amp;quot;. &amp;quot;
                               &amp;quot;user: &amp;quot; (pr-str user) &amp;quot;, &amp;quot;
                               &amp;quot;roles: &amp;quot; (pr-str roles) &amp;quot;, &amp;quot;
                               &amp;quot;required roles: &amp;quot; (pr-str required) &amp;quot;. &amp;quot;
                               &amp;quot;session-id: &amp;quot; (pr-str user-response-session) &amp;quot;.&amp;quot;)]
                      (if user-session
                        (rlog/with-forward-context
                          user-response-session
                          (log/error
                            error-message)
                          {:message-type :error})
                        (log/error
                          error-message)))
                    (cond
                      ;; If request is authenticated, raise 403 instead
                      ;; of 401 (because user is authenticated but permission
                      ;; denied is raised).
                      (auth/authenticated? request)
                      (-&amp;gt; (ring-response/response
                            {:reason
                             (str &amp;quot;Header authenticated, but not authorized for access to &amp;quot;
                                  (some-&amp;gt; metadata :details :request :path) &amp;quot;. &amp;quot;
                                  &amp;quot;Metadata : &amp;quot; (pr-str metadata))})
                          (assoc :status 403))
                      ;; In other cases, respond with a 401.
                      :else
                      (let [current-url (:uri request)]
                        (-&amp;gt;
                          (ring-response/response
                            {:reason &amp;quot;Unauthorized&amp;quot;})
                          (assoc :status 401)
                          (ring-response/header &amp;quot;WWW-Authenticate&amp;quot; &amp;quot;tg-auth, type=1&amp;quot;)))))}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;:token-names&lt;/code&gt; entry is a vector (in priority order) of the request headers we will inspect to find the user&amp;rsquo;s JWT identity token. In the code above, if the request header &lt;strong&gt;x-goog-iap-jwt-assertion&lt;/strong&gt; is found then its value will be used, otherwise &lt;strong&gt;x-debug-token&lt;/strong&gt; will be used. If neither is found, nil is returned. The vector&amp;rsquo;s ordering means that a &lt;strong&gt;x-goog-iap-jwt-assertion&lt;/strong&gt; header injected by Google IAP will take precedence.&lt;/p&gt;
&lt;p&gt;In either case the token extracted will be validated by the function passed in the option maps &lt;code&gt;:authfn&lt;/code&gt; field (i.e. &lt;code&gt;token-authfn&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn token-authfn
  [request token]
  (log/info &amp;quot;Attempting to authorize using token with JWT header: &amp;quot;
            (some-&amp;gt; token (jws/decode-header)))
  (when token
    (let
      [validity-map
       (if (= &amp;quot;local&amp;quot; (:kid (jws/decode-header token)))
         {:aud &amp;quot;local&amp;quot;
          :iss &amp;quot;local&amp;quot;}
         {:aud server-config/google-jwt-audience
          :iss &amp;quot;https://cloud.google.com/iap&amp;quot;})]
      (try
        (when-let
          [user-id
           (google/get-valid-user-id-from-header
             token
             validity-map
             240)]
          (log/info &amp;quot;Successfully retrieved user ID using token &amp;quot; user-id)
          user-id)
        (catch clojure.lang.ExceptionInfo e
          (log/info
            (str &amp;quot;Exception thrown while retrieving user from token. Message: &amp;quot;
                 (.getMessage ^Throwable e) &amp;quot;, Data: &amp;quot; (pr-str (ex-data e))))
          (throw e))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we use the &lt;code&gt;get-valid-user-id-from-header&lt;/code&gt; function to validate the token and extract from it the user&amp;rsquo;s id. We pass to it the token, a &lt;strong&gt;validity-map&lt;/strong&gt;, indicating what the &lt;code&gt;:iss&lt;/code&gt; and &lt;code&gt;:aud&lt;/code&gt; value are expected to be, and a &lt;strong&gt;jitter&lt;/strong&gt; value (as a number of minutes).&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;validity-map&lt;/strong&gt; is a map, based on the &lt;code&gt;:kid&lt;/code&gt; value of the signed token, containing the acceptable values for the &lt;em&gt;issuer&lt;/em&gt; and the &lt;em&gt;audience&lt;/em&gt; fields of the token for a particular &lt;code&gt;:kid&lt;/code&gt;. The &lt;strong&gt;jitter&lt;/strong&gt; value is the number of minutes after the token&amp;rsquo;s actual expiration date (its &lt;code&gt;:exp&lt;/code&gt; field) that the token is still considered valid. Because, this is a demonstration project we have set the value to 4 hours (240 minutes).&lt;/p&gt;
&lt;p&gt;If the JWT token is valid then &lt;code&gt;get-valid-user-id-from-header&lt;/code&gt; returns an &lt;strong&gt;identity-token&lt;/strong&gt; as explained 
&lt;a href=&#34;http://heykieran.github.io/post/pedestal-buddy#the-login-process&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;. The &lt;code&gt;:alloc-auth/token&lt;/code&gt; key will contain the user&amp;rsquo;s JWT token, whether &lt;code&gt;:local&lt;/code&gt; or &lt;code&gt;:google&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The use of a &lt;code&gt;:local&lt;/code&gt; token is convenient for debugging purposes when you&amp;rsquo;re running the code locally, and not behind an &lt;strong&gt;IAP&lt;/strong&gt;. A local token can be used by supplying it in the &lt;strong&gt;x-debug-token&lt;/strong&gt; request header, and it will be used if an &lt;strong&gt;IAP&lt;/strong&gt; header doesn&amp;rsquo;t exist. (You will recall that the &lt;strong&gt;x-goog-iap-jwt-assertion&lt;/strong&gt; header has precedence).&lt;/p&gt;
&lt;p&gt;A local token can be created using the same underlying method for the &lt;code&gt;:ext-token&lt;/code&gt; field of the &lt;strong&gt;identity-token&lt;/strong&gt;. It is a JWT token created and signed by our Pedestal server.&lt;/p&gt;
&lt;p&gt;For convenience, the server supplies a route to retrieve a &lt;code&gt;:local&lt;/code&gt; token and&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl --insecure -X POST https://&amp;lt;server&amp;gt;:&amp;lt;port&amp;gt;/debug/token/&amp;lt;email-address&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will return a clojure map that contains a token associated with the email address you supplied in the URL. Subsequent requests can use the response&amp;rsquo;s &lt;code&gt;:token&lt;/code&gt; field as the value of the &lt;strong&gt;x-debug-token&lt;/strong&gt; request header.&lt;/p&gt;
&lt;p&gt;Obviously, this route, which allows public access, should be disabled in a production server.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn get-valid-user-id-from-header
  [google-header-assertion valid-map &amp;amp; [minutes-offset]]
  (letfn
    [(get-user-id-with-validation
       [r-val v-map]
       (log/info &amp;quot;Checking token values for validity:&amp;quot; r-val
                 &amp;quot;against&amp;quot; v-map)
       (when
         (every?
           (fn [kw]
             (= (get r-val kw) (get v-map kw)))
           (keys v-map))
         (log/info &amp;quot;token is valid, email address is&amp;quot; (get r-val :email))
         {:alloc-auth/user-id
          (auth-utils/get-id-from-email-address
            (get r-val :email))
          :alloc-auth/token-type :google
          :alloc-auth/token r-val
          :alloc-auth/ext-token  (debug-sign/sign-using-debug-key
                                   server-config/debug-local-jwt
                                   {:email (get r-val :email)})}))]
    (let
      [decoded-header
       (try
         (jws/decode-header google-header-assertion)
         (catch clojure.lang.ExceptionInfo e
           (throw
             (ex-info &amp;quot;Unable to decode assertion header as jws&amp;quot;
                      (merge
                        (ex-data e)
                        {:ex-message (.getMessage ^Throwable e)
                         :ex-cause   (.getCause ^Throwable e)})
                      e)))
         (catch Exception e
           (throw
             (ex-info &amp;quot;Unable to decode assertion header as jws&amp;quot;
                      {:ex-message (.getMessage ^Throwable e)
                       :ex-cause (.getCause ^Throwable e)}
                      e))))]
      (log/info &amp;quot;Successfully decoded header assertion using :kid&amp;quot; (:kid decoded-header))
      (log/info &amp;quot;Cache agent contains&amp;quot;
                (if-let
                  [jwks (some-&amp;gt; (deref jwk-cache-agent) :jwk)]
                  (str (count jwks) &amp;quot; entries with kid&#39;s &amp;quot; (mapv :kid jwks))
                  &amp;quot;no entries.&amp;quot;))
      (if-let
        [public-key-jwt
         (some
           (fn [poss]
             (when
               (= (:kid poss)
                  (:kid decoded-header))
               poss))
           (get (deref jwk-cache-agent) :jwk))]
        (let
          [alg (keyword (str/lower-case (:alg public-key-jwt)))]
          (try
            (-&amp;gt;
              (jwt/unsign
                google-header-assertion
                (keys/jwk-&amp;gt;public-key public-key-jwt)
                {:alg alg
                 :now (time/minus (time/instant) (time/minutes (or minutes-offset 0)))})
              (get-user-id-with-validation valid-map))
            (catch Exception e
              (log/error
                &amp;quot;Google header validation problem, &amp;quot;
                (pr-str (ex-data e))
                &amp;quot;using public key&amp;quot;
                (pr-str public-key-jwt)))))
        (do
          (log/error &amp;quot;No matching :kid entry found in cache.&amp;quot;)
          (throw
            (let [e (Exception.
                      (str &amp;quot;No matching :kid (&amp;quot;
                           (pr-str decoded-header)
                           &amp;quot;) entry found in cache.&amp;quot;))]
              (ex-info &amp;quot;Bad jws.&amp;quot;
                     (merge
                       (ex-data e)
                       {:ex-message (.getMessage ^Throwable e)
                        :ex-cause   (.getCause ^Throwable e)})
                     e))))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;testing-the-implementation&#34;&gt;Testing the Implementation&lt;/h1&gt;
&lt;p&gt;Now that we have the backend working, we can test it using &lt;strong&gt;curl&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl --insecure -X POST https://localhost:8081/api/getsecresource/a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will return the transit response&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;^ &amp;quot;,&amp;quot;~:reason&amp;quot;,&amp;quot;Unauthorized&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;indicating that the request couldn&amp;rsquo;t be authenticated using either a session of a header token. This is as we&amp;rsquo;d expect.&lt;/p&gt;
&lt;p&gt;Now issue a request for a token by supplying an email address associated with the &lt;strong&gt;user-id&lt;/strong&gt; &lt;code&gt;:user&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl --insecure -X POST https://localhost:8081/debug/token/user@timpsongray.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will return something similar to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{:identity 
  {:alloc-auth/user-id :user, 
   :alloc-auth/token-type :local, 
   :alloc-auth/token {:email &amp;quot;user@timpsongray.com&amp;quot;, :iss &amp;quot;local&amp;quot;, :aud &amp;quot;local&amp;quot;, :iat 1593088750, :exp 1593089650}, :alloc-auth/ext-token &amp;quot;eyJhbGciOiJFUzI1NiIsImtpZCI6ImxvY2FsIn0.eyJlbWFpbCI6InVzZXJAdGltcHNvbmdyYXkuY29tIiwiaXNzIjoibG9jYWwiLCJpYXQiOjE1OTMwODg3NTAsImF1ZCI6ImxvY2FsIiwiZXhwIjoxNTkzMDkyMzUwfQ.oqGnFqQ0N-7OYVBpLsiF_rNkDCtuHvI8i7OfXHaKvtJsTxxtoPHXN1kCd9d5X9Li3PM7q1Xg0z7TuRoZuGXB5A&amp;quot;, 
   :alloc-auth/user-session :user-3}, 
   :token &amp;quot;eyJhbGciOiJFUzI1NiIsImtpZCI6ImxvY2FsIn0.eyJlbWFpbCI6InVzZXJAdGltcHNvbmdyYXkuY29tIiwiaXNzIjoibG9jYWwiLCJpYXQiOjE1OTMwODg3NTAsImF1ZCI6ImxvY2FsIiwiZXhwIjoxNTkzMDkyMzUwfQ.tX6bAIqK7tPEpilwTtN-VWoNDgIJZXy7cxWgWmlKyfZi5Wt4R_emuBHPD6J6-WevwblA1V_f1pkWBKxH7QyFQg&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The token is in the &lt;code&gt;:token&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;Using this token we can now issue a request for a resource to which &lt;code&gt;:user&lt;/code&gt; is permitted access, adding the token we recieved as the &lt;strong&gt;x-debug-token&lt;/strong&gt; request header,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl --insecure -X POST \
  -H &amp;quot;x-debug-token: eyJhbGciOiJFUzI1NiIsImtpZCI6ImxvY2FsIn0.eyJlbWFpbCI6InVzZXJAdGltcHNvbmdyYXkuY29tIiwiaXNzIjoibG9jYWwiLCJpYXQiOjE1OTMwODg3NTAsImF1ZCI6ImxvY2FsIiwiZXhwIjoxNTkzMDkyMzUwfQ.tX6bAIqK7tPEpilwTtN-VWoNDgIJZXy7cxWgWmlKyfZi5Wt4R_emuBHPD6J6-WevwblA1V_f1pkWBKxH7QyFQg&amp;quot; \
  https://localhost:8081/api/getsecresource/u
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we should see the following transit response,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;^ &amp;quot;,&amp;quot;~:the-results&amp;quot;,&amp;quot;Let&#39;s pretend that this is something interesting.&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;letting us know that the request succeeded.&lt;/p&gt;
&lt;p&gt;However, if we try to access a resource to which &lt;code&gt;:user&lt;/code&gt; does not have permission,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl --insecure -X POST \
-H &amp;quot;X-debug-token: eyJhbGciOiJFUzI1NiIsImtpZCI6ImxvY2FsIn0.eyJlbWFpbCI6InVzZXJAdGltcHNvbmdyYXkuY29tIiwiaXNzIjoibG9jYWwiLCJpYXQiOjE1OTMwODg3NTAsImF1ZCI6ImxvY2FsIiwiZXhwIjoxNTkzMDkyMzUwfQ.tX6bAIqK7tPEpilwTtN-VWoNDgIJZXy7cxWgWmlKyfZi5Wt4R_emuBHPD6J6-WevwblA1V_f1pkWBKxH7QyFQg&amp;quot; \
https://localhost:8081/api/getsecresource/a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we&amp;rsquo;ll receive an error message letting us know that &lt;code&gt;:admin&lt;/code&gt; is the required role, while we only have the &lt;code&gt;:user&lt;/code&gt; role,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;^ &amp;quot;,&amp;quot;~:reason&amp;quot;,&amp;quot;Header authenticated, but not authorized for access to /api/getsecresource/a. 
Metadata : {:details {:request {:path \&amp;quot;/api/getsecresource/a\&amp;quot;, :path-params {}, 
:user :user, :roles #{:user}, 
:identity #object[clojure.core$identity 0x8a41b2d \&amp;quot;clojure.core$identity@8a41b2d\&amp;quot;], 
:required #{:admin}, :user-session nil}, 
:message \&amp;quot;\\\&amp;quot;Alloc-Unauthorized\\\&amp;quot;\&amp;quot;}}&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;closure&#34;&gt;Closure&lt;/h1&gt;
&lt;p&gt;We now have a authentication back-end that can handle both session- and header-based authentication. Our SPA works as it always did, but now we can also use the api from non-browser based clients, including requests received through, and tagged by the IAP proxy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploy a Clojure Pedestal API Server &amp; React/ClojureScript Web Application to Docker</title>
      <link>https://heykieran.github.io/post/deploy-pedestal-react-to-docker/</link>
      <pubDate>Thu, 07 May 2020 12:10:26 -0400</pubDate>
      <guid>https://heykieran.github.io/post/deploy-pedestal-react-to-docker/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In this post I&amp;rsquo;ll show how to build and deploy to docker a fully-functioning application comprising a secure Pedestal API web-server and a React front-end application written in ClojureScript which accesses the server.&lt;/p&gt;
&lt;p&gt;For this example I&amp;rsquo;ll be using the Pedestal/React application I previously discussed in this 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-and-google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt; (with its code 
&lt;a href=&#34;https://github.com/heykieran/clj-pedestal-spa/tree/v1.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; for &lt;strong&gt;tag v1.0&lt;/strong&gt;), and the code discussed in this post is available 
&lt;a href=&#34;https://github.com/heykieran/clj-docker-deploy-ext&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;outline-of-the-steps&#34;&gt;Outline of the Steps&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ll set up a working directory for the build, clone the target application into a sub-directory, compile the target, package it and its dependencies to java byte code, assemble them into a jar, create a docker image for the application, and deploy it as a docker service.&lt;/p&gt;
&lt;h3 id=&#34;background-challenges--tools&#34;&gt;Background, Challenges &amp;amp; Tools&lt;/h3&gt;
&lt;p&gt;During this exercise, I&amp;rsquo;ll try to keep separate the application I&amp;rsquo;m building from the application doing the building. This isn&amp;rsquo;t strictly necessary but it will help illustrate a procedure generally applicable to any Clojure application.&lt;/p&gt;
&lt;p&gt;One of the challenges of this approach is that I&amp;rsquo;ll need to deal with two &lt;code&gt;deps.edn&lt;/code&gt; files - one for the build environment and one for the application being built. Each &lt;code&gt;deps&lt;/code&gt; file contains relative paths (&lt;code&gt;:paths&lt;/code&gt; and &lt;code&gt;:extra-paths&lt;/code&gt;) relative to the root of the project directory to which it belongs.&lt;/p&gt;
&lt;p&gt;If I am to avoid changing in any way the &lt;code&gt;deps&lt;/code&gt; file for the project being built and yet still ensure that the built artifacts end up in the correct location within the build project&amp;rsquo;s directory structure I will need a way to inform the compiler about which paths to use, but relative to the &lt;strong&gt;build&lt;/strong&gt; project&amp;rsquo;s directory and not as specified in the &lt;strong&gt;target&amp;rsquo;s&lt;/strong&gt; &lt;code&gt;deps.edn&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;As an example, let&amp;rsquo;s suppose that the build project is at &lt;code&gt;./clj-deploy-docker&lt;/code&gt; and the project being built will be cloned into &lt;code&gt;./clj-deploy-docker/target-app&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;deps.edn&lt;/code&gt; file in &lt;code&gt;./clj-deploy-docker/target-app&lt;/code&gt; will contain an entry for the alias &lt;code&gt;:main&lt;/code&gt; as below&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-edn&#34;&gt;:aliases
 {:main
  {:paths [&amp;quot;src&amp;quot;]
   :extra-deps {ch.qos.logback/logback-classic {:mvn/version &amp;quot;1.2.3&amp;quot;}
                org.clojure/tools.logging {:mvn/version &amp;quot;0.4.1&amp;quot;}
                ring/ring-core {:mvn/version &amp;quot;1.8.0&amp;quot;}
                ring/ring-jetty-adapter {:mvn/version &amp;quot;1.8.0&amp;quot;}
                ring/ring-devel {:mvn/version &amp;quot;1.8.0&amp;quot;}
                io.pedestal/pedestal.service {:mvn/version &amp;quot;0.5.7&amp;quot;}
                io.pedestal/pedestal.route {:mvn/version &amp;quot;0.5.7&amp;quot;}
                io.pedestal/pedestal.jetty {:mvn/version &amp;quot;0.5.7&amp;quot;}
                buddy {:mvn/version &amp;quot;2.0.0&amp;quot;}
                hiccup {:mvn/version &amp;quot;1.0.5&amp;quot;}
                org.conscrypt/conscrypt-openjdk-uber {:mvn/version &amp;quot;2.2.1&amp;quot;}
                org.eclipse.jetty/jetty-alpn-conscrypt-server {:mvn/version &amp;quot;9.4.24.v20191120&amp;quot;}
                com.google.api-client/google-api-client {:mvn/version &amp;quot;1.30.6&amp;quot;}
                com.walmartlabs/dyn-edn 
                {:git/url &amp;quot;https://github.com/walmartlabs/dyn-edn.git&amp;quot; 
                 :sha &amp;quot;855a775959cf1bec531a303a323e6f05f7b260fb&amp;quot;}}
   :extra-paths [&amp;quot;resources&amp;quot; &amp;quot;common-src&amp;quot; ]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to access and use this alias correctly from the build project&amp;rsquo;s directory (&lt;code&gt;clj-deploy-docker&lt;/code&gt;) I will need to adjust (&lt;em&gt;in some way&lt;/em&gt;) the paths so that the compiler is operating with the correct class path i.e. the class path of the target rather than the class path of the build. Therefore, I&amp;rsquo;ll need to let the compiler know (&lt;em&gt;in some way&lt;/em&gt;) that the &lt;code&gt;:paths&lt;/code&gt; and &lt;code&gt;:extra-paths&lt;/code&gt; vectors should read&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:paths [&amp;quot;target-app/src&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:extra-paths [&amp;quot;target-app/resources&amp;quot; &amp;quot;target-app/common-src&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;respectively.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;On the other hand, the maven coordinates in the target&amp;rsquo;s &lt;code&gt;deps.edn&lt;/code&gt; file are correct, so we can leave the &lt;code&gt;:deps&lt;/code&gt; and &lt;code&gt;:extra-deps&lt;/code&gt; values as they are found.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As for the &lt;em&gt;&amp;ldquo;in some way&amp;rdquo;&lt;/em&gt;, I will be using the 
&lt;a href=&#34;https://github.com/EwenG/badigeon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Badigeon&lt;/a&gt; library to achieve this. Many of Badigeon&amp;rsquo;s API&amp;rsquo;s take a &lt;code&gt;:deps-map&lt;/code&gt; as input. This is an &lt;em&gt;in-memory&lt;/em&gt; map whose structure is the same as a &lt;code&gt;deps.edn&lt;/code&gt; file. This will allow me to read the &lt;code&gt;deps&lt;/code&gt; file, make in-memory adjustments and feed it to to API to do the &lt;em&gt;bundling&lt;/em&gt; and &lt;em&gt;compiling&lt;/em&gt; with a classpath relative to any directory I choose (i.e. relative to &lt;code&gt;./clj-deploy-docker&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&#34;create-a-working-directory-for-the-project&#34;&gt;Create a Working Directory for the Project&lt;/h3&gt;
&lt;p&gt;Create a working directory for the project, and &lt;code&gt;cd&lt;/code&gt; into it&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir clj-deploy-docker
$ cd clj-deploy-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;setting-up-the-application-to-be-built&#34;&gt;Setting up the Application to be built&lt;/h3&gt;
&lt;p&gt;Now, I&amp;rsquo;ll clone the repository of the application I want to build into a directory &lt;code&gt;target-app&lt;/code&gt; under my working directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/heykieran/clj-pedestal-google.git target-app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As mentioned above, for this exercise I will be using a library called 
&lt;a href=&#34;https://github.com/EwenG/badigeon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Badigeon&lt;/a&gt; to organize and compile the sources. It leverages many of the tools &amp;amp; libraries already available in &lt;code&gt;clojure.core&lt;/code&gt; and &lt;code&gt;tools.deps&lt;/code&gt;; it&amp;rsquo;s very flexible and I find the API intuitive.&lt;/p&gt;
&lt;h3 id=&#34;creating-the-build-runner&#34;&gt;Creating the build runner&lt;/h3&gt;
&lt;p&gt;In my project&amp;rsquo;s working directory I create a &lt;code&gt;deps.edn&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ touch deps.edn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and add the Badigeon dependency to the &lt;code&gt;deps.edn&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-edn&#34;&gt;{:deps 
  {}
  :aliases
  {:build
  {:extra-paths [&amp;quot;build&amp;quot;]
   :extra-deps
   {badigeon/badigeon
    {:git/url &amp;quot;https://github.com/EwenG/badigeon.git&amp;quot;
     :sha &amp;quot;1edf7ae465db870ec0066f28226edb9b04873b70&amp;quot;
     :tag &amp;quot;0.0.11&amp;quot;}}}}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Apart from the Clojure system and user dependencies this is the only dependency I&amp;rsquo;ll need in that file.&lt;/p&gt;
&lt;p&gt;Also, for later use, I create a directory called &lt;code&gt;build&lt;/code&gt; to contain the Clojure files to run the bundling, compilation and assembling processes.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir build
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;building-the-front-end-js-file&#34;&gt;Building the Front-End JS File&lt;/h3&gt;
&lt;p&gt;As outlined in my previous 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-and-google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt;, the following command will build the front-end production application&amp;rsquo;s &lt;code&gt;js&lt;/code&gt; file from the ClojureScript sources for the application being &lt;em&gt;dockerized&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd target-app
$ clj -A:prod
$ cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will build the application&amp;rsquo;s front-end only and place the production &lt;code&gt;js&lt;/code&gt; file (&lt;code&gt;prod-main.js&lt;/code&gt;) in the &lt;code&gt;target-app/target/public/cljs-out&lt;/code&gt; directory. This is the &lt;strong&gt;only&lt;/strong&gt; change that will be made to the directories and files under &lt;code&gt;target-app&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At a later stage I will move this file to its correct location under my project directory (&lt;code&gt;./clj-deploy-docker&lt;/code&gt;) so that it can be included in the docker image.&lt;/p&gt;
&lt;h3 id=&#34;building-the-back-end-jvm-class-files&#34;&gt;Building the Back-End (JVM) Class Files&lt;/h3&gt;
&lt;p&gt;I&amp;rsquo;ll now &lt;code&gt;cd&lt;/code&gt; into the &lt;code&gt;build&lt;/code&gt; directory I created previously and create a &lt;code&gt;package.clj&lt;/code&gt; file. This file will contain the &lt;code&gt;-main&lt;/code&gt; method that ultimately performs the bundling, compilation and consolidation of the back-end Clojure files i.e. the JVM class files.&lt;/p&gt;
&lt;h4 id=&#34;some-background-on-bundling-compilation-and-consolidation-_jaring_&#34;&gt;Some Background on Bundling, Compilation and Consolidation (&lt;em&gt;&lt;strong&gt;Jar&lt;/strong&gt;&amp;lsquo;ing&lt;/em&gt;)&lt;/h4&gt;
&lt;p&gt;There are three distinct phases to assembling the JVM artifacts to include in the docker image and I will be using the Badigeon API to perform all three phases.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h5 id=&#34;bundling&#34;&gt;Bundling&lt;/h5&gt;
&lt;p&gt;The &lt;em&gt;bundling&lt;/em&gt; step creates a &amp;ldquo;bundle&amp;rdquo; at a specified file-system location of all the target project&amp;rsquo;s resources and dependencies, including any &lt;code&gt;jar&lt;/code&gt; files that are needed. Note that because the Badigeon bundler does not merge in the system and user &lt;code&gt;deps&lt;/code&gt; preferences, it will not automatically copy sources that are in &lt;code&gt;src&lt;/code&gt; directory of your project, &lt;strong&gt;unless&lt;/strong&gt; that directory is explicitly specified in the &lt;code&gt;:paths&lt;/code&gt; or &lt;code&gt;:extra-paths&lt;/code&gt; entries in the &lt;code&gt;deps.edn&lt;/code&gt; file. During the bundling phase all the &lt;code&gt;jar&lt;/code&gt; files required by your application, and all other resources on the classpath such as static html file, css files, user authored js files etc. will be copied to the specified target directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;compilation&#34;&gt;Compilation&lt;/h5&gt;
&lt;p&gt;During the &lt;em&gt;compilation&lt;/em&gt; step the compiled versions of your Clojure source files (as &lt;code&gt;.class&lt;/code&gt; files) are generated and copied to a specified target directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;consolidation&#34;&gt;Consolidation&lt;/h5&gt;
&lt;p&gt;The final phase involves creating a &lt;code&gt;jar&lt;/code&gt; file containing all the &lt;code&gt;.class&lt;/code&gt; files needed by the application with an appropriate manifest file (&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;) which has an entry indicating the application&amp;rsquo;s entry-point (a &lt;code&gt;Main-Class&lt;/code&gt; entry), and an entry specifying the libraries to be used by the &lt;code&gt;jar&lt;/code&gt; file (a &lt;code&gt;Class-Path&lt;/code&gt; entry).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dependencies (found by Badigeon using the &lt;code&gt;:deps&lt;/code&gt; and &lt;code&gt;:extra-deps&lt;/code&gt; coordinates) will &lt;strong&gt;not&lt;/strong&gt; be incorporated into this &lt;code&gt;jar&lt;/code&gt; file. They will however be added to a &lt;code&gt;./lib&lt;/code&gt; directory as individual &lt;code&gt;jar&lt;/code&gt; files and referenced by the &lt;code&gt;Class-Path&lt;/code&gt; entry in the jar&amp;rsquo;s manifest file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Once these three phases are complete, &lt;strong&gt;and&lt;/strong&gt; the js file containing the front-end application is placed in its correct location, the application can be run using the &lt;code&gt;java&lt;/code&gt; command line tool.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ll come to that presently, but first I&amp;rsquo;d like to take a slightly deeper look at the &lt;em&gt;bundling&lt;/em&gt;, &lt;em&gt;compilation&lt;/em&gt; and &lt;em&gt;consolidation&lt;/em&gt; phases. The full details are available in the &lt;code&gt;package.clj&lt;/code&gt; file from which the following code snippets have been extracted.&lt;/p&gt;
&lt;h4 id=&#34;notes-on-the-code-performing-the-three-steps&#34;&gt;Notes on the code performing the three steps&lt;/h4&gt;
&lt;p&gt;First, I &lt;strong&gt;bundle&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(bundle
     out-path
     {:deps-map translated-deps-map
      :aliases aliases
      :libs-path &amp;quot;lib&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given a &lt;code&gt;deps-map&lt;/code&gt; and a vector of aliases (&lt;code&gt;[:main]&lt;/code&gt;) this function will copy the projects&amp;rsquo;s resources needed to &lt;code&gt;out-path&lt;/code&gt;, and also copy the &lt;code&gt;jar&lt;/code&gt; files required to &lt;code&gt;out-path/lib&lt;/code&gt;. Because the code I want to bundle is in the &lt;code&gt;target-app&lt;/code&gt; directory, I&amp;rsquo;ll read the &lt;code&gt;deps.edn&lt;/code&gt; file from its location under &lt;code&gt;target-app&lt;/code&gt; and update the &lt;code&gt;:path&lt;/code&gt; and &lt;code&gt;:extra-paths&lt;/code&gt; entries so that they are now relative to the current working directory rather than &lt;code&gt;target-app&lt;/code&gt; (see 
&lt;a href=&#34;#background-challenges--tools&#34;&gt;above&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Now the &lt;strong&gt;compilation&lt;/strong&gt; phase runs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(compile/compile
     &#39;main.core
     {:compile-path
      classes-path
      :classpath
      (translate-path-to-absolute
       target-dir
       deps-map
       aliases)})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This compiles the &lt;code&gt;main.core&lt;/code&gt; namespace, putting the &lt;code&gt;.class&lt;/code&gt; files into the directory specified by the &lt;code&gt;classes-path&lt;/code&gt; directory, using a classpath specified by the value of the &lt;code&gt;:classpath&lt;/code&gt; entry. In my case, this is generated by reading the &lt;code&gt;target-app/deps.edn&lt;/code&gt; file into &lt;code&gt;deps-map&lt;/code&gt; and converting the relative components of &lt;code&gt;:paths&lt;/code&gt; and &lt;code&gt;:extra-paths&lt;/code&gt; vectors to absolute file-system locations.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;strong&gt;consolidation&lt;/strong&gt; phase runs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(spit manifest-path
          (jar/make-manifest
           &#39;main.core
           {:Class-Path
            (str
             &amp;quot;. &amp;quot;
             (str/join
              &amp;quot; &amp;quot;
              (mapv
               #(str &amp;quot;lib/&amp;quot; (.getName %))
               (.listFiles (io/file &amp;quot;target/app/lib&amp;quot;)))))}))
    
    (zip/zip
     classes-path
     (str (make-path out-path &amp;quot;app-runner&amp;quot;) &amp;quot;.jar&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This achieves two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;It creates a manifest file in &lt;code&gt;target/app/classes/META-INF&lt;/code&gt;, setting &lt;code&gt;main.core&lt;/code&gt; as the entry point, and adds entries for all the &lt;code&gt;jar&lt;/code&gt; files in the &lt;code&gt;target/lib&lt;/code&gt; directory (which was created and populated during &lt;em&gt;bundling&lt;/em&gt;) into the manifest file&amp;rsquo;s &lt;code&gt;Class-Path&lt;/code&gt; header field. In order for the application to run there is an assumption that the final &lt;code&gt;jar&lt;/code&gt; file and the &lt;code&gt;lib&lt;/code&gt; directory will exist at the same level in the file system i.e. in the same directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It creates a &lt;code&gt;app-runner.jar&lt;/code&gt; file from the contents of the &lt;code&gt;target/app/classes&lt;/code&gt; directory. This &lt;code&gt;jar&lt;/code&gt; file &lt;strong&gt;is&lt;/strong&gt; the main application and will contain the manifest file just created with its &lt;code&gt;Class-Path&lt;/code&gt; entry pointing to the non-application &lt;code&gt;jar&lt;/code&gt; files it needs to run - i.e. those found in the &lt;code&gt;lib&lt;/code&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In order to run all three steps, I can &amp;ldquo;execute&amp;rdquo; the &lt;code&gt;package&lt;/code&gt; namespace passing the &lt;code&gt;target-app&lt;/code&gt; directory name as an argument.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ clj -A:build -m package &amp;quot;target-app&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This completes the Bundling, Compilation and Consolidation steps, and when it finishes I will have a directory structure, which with the addition of the front-end &lt;code&gt;js&lt;/code&gt; file (which I compiled above) will constitute the complete application.&lt;/p&gt;
&lt;p&gt;The result is a &lt;code&gt;target&lt;/code&gt; folder containing an &lt;code&gt;app-runner.jar&lt;/code&gt; file and any other supporting files needed to run the app. Many are extraneous; for instance all the classes files, now included in the &lt;code&gt;jar&lt;/code&gt; file are also under this directory, as are the source code of the Clojure files.&lt;/p&gt;
&lt;p&gt;I can copy the &lt;code&gt;js&lt;/code&gt; file to its correct location using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir -p target/app/public/cljs-out &amp;amp;&amp;amp; \ 
  cp target-app/target/public/cljs-out/prod-main.js &amp;quot;$_&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, everything I need (and some I don&amp;rsquo;t) is available in the &lt;code&gt;./target/app/&lt;/code&gt; directory.&lt;/p&gt;
&lt;h4 id=&#34;running-the-application&#34;&gt;Running the Application&lt;/h4&gt;
&lt;p&gt;Before running the compiled application I need to ensure that certain environment variables are defined and set correctly.&lt;/p&gt;
&lt;p&gt;As discussed in my 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-and-google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;previous post&lt;/a&gt;, the application requires a number of environment variables to be set in order to configure itself correctly.&lt;/p&gt;
&lt;p&gt;These are&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# the https port number used by the Pedestal API server
ALLOC_SSL_PORT=8081 
# the password of Jetty&#39;s keystore 
ALLOC_KEYSTORE_PASSWORD=&amp;lt;password&amp;gt; 
# the http port number used by the Pedestal API server
ALLOC_PORT=8080 
# the file system location of the Jetty&#39;s keystore (as an absolute file path)
ALLOC_KEYSTORE_LOCATION=&amp;lt;location&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can &lt;code&gt;cd&lt;/code&gt; into the built artifact&amp;rsquo;s directory (&lt;code&gt;./target/app&lt;/code&gt;) and run the backend application directly from the &lt;code&gt;jar&lt;/code&gt; file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd target/app
$ java -jar app-runner.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or, because the classes still exist in a &lt;code&gt;classes&lt;/code&gt; directory under the &lt;code&gt;app&lt;/code&gt; directory&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd target/app
$ java -cp .:classes:lib/* main.core
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The app will start, and when it&amp;rsquo;s fully initialized, I can navigate to 
&lt;a href=&#34;https://localhost:8081/r/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;https://localhost:8081/r/home&lt;/code&gt;&lt;/a&gt; to see it in action.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is also a lot of unnecessary &amp;ldquo;residue&amp;rdquo; in the &lt;code&gt;./target/app&lt;/code&gt; directory, created during &lt;em&gt;bundling&lt;/em&gt;, including directories containing clj and cljc files that are not actually needed to run the application (they will already have been compiled into the &lt;code&gt;classes&lt;/code&gt; directory).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When I process the files for deployment to docker, these will be removed.&lt;/p&gt;
&lt;p&gt;There remains then only the task of creating the docker image itself, which is outlined below.&lt;/p&gt;
&lt;h2 id=&#34;quick-review&#34;&gt;Quick Review&lt;/h2&gt;
&lt;p&gt;Currently, we have in the &lt;code&gt;target/app&lt;/code&gt; all the artifacts (with some extras) to run the application. Now we will rationalize those artifacts, removing all the unnecessary ones, leaving only those that are necessary for running our application and package what remains into a docker image, which we&amp;rsquo;ll place in the folder &lt;code&gt;docker/deploy&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;create-the-docker-image&#34;&gt;Create the Docker Image&lt;/h2&gt;
&lt;p&gt;The docker image I will use is very simple - a basic Debian stretch image with a Java8 SDK.&lt;/p&gt;
&lt;p&gt;In my project directory I create a directory called &lt;code&gt;docker&lt;/code&gt; and &lt;code&gt;cd&lt;/code&gt; into it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir docker
$ cd docker 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and create a &lt;code&gt;Dockerfile&lt;/code&gt; containing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM openjdk:8-stretch

COPY entrypoint.sh /sbin/entrypoint.sh
RUN chmod 755 /sbin/entrypoint.sh

EXPOSE 8081/tcp

COPY deploy /image

WORKDIR /image/app

ENV ALLOC_KEYSTORE_LOCATION=/image/local/jetty-keystore \
    ALLOC_KEYSTORE_PASSWORD=password \
    ALLOC_PORT=8080 \
    ALLOC_SSL_PORT=8081 

ENTRYPOINT [&amp;quot;/sbin/entrypoint.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Dockerfile&lt;/code&gt; as defined will&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create an image from a base &lt;code&gt;openjdk:8-stretch&lt;/code&gt; image,&lt;/li&gt;
&lt;li&gt;copy the file &lt;code&gt;entrypoint.sh&lt;/code&gt; (which I haven&amp;rsquo;t created yet) from the &lt;code&gt;docker/deploy&lt;/code&gt; folder to the image&amp;rsquo;s &lt;code&gt;/sbin&lt;/code&gt; directory and set its mode to executable,&lt;/li&gt;
&lt;li&gt;enable network connectivity to port &lt;code&gt;8081&lt;/code&gt; only (there will be &lt;em&gt;no&lt;/em&gt; access to the unprotected &lt;code&gt;http&lt;/code&gt; port 8080),&lt;/li&gt;
&lt;li&gt;copy the entire contents of the &lt;code&gt;docker/deploy&lt;/code&gt; directory to the image&amp;rsquo;s &lt;code&gt;/image&lt;/code&gt; directory,&lt;/li&gt;
&lt;li&gt;set the image&amp;rsquo;s working directory to &lt;code&gt;/image/app&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;set the needed environment variables for the new image, and&lt;/li&gt;
&lt;li&gt;specify that the &lt;code&gt;/sbin/entrypoint.sh&lt;/code&gt; script should be run when the container starts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;deploy&lt;/code&gt; directory under the &lt;code&gt;docker&lt;/code&gt; directory is the location where the application&amp;rsquo;s artifact will be assembled before their inclusion in the image when the &lt;code&gt;COPY deploy /image&lt;/code&gt; command is run.&lt;/p&gt;
&lt;p&gt;From my project&amp;rsquo;s folder (&lt;code&gt;clj-deploy-docker&lt;/code&gt;) I run the following command to copy the entire app (including residue) to the &lt;code&gt;docker/deploy&lt;/code&gt; folder (creating it if it doesn&amp;rsquo;t exist).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir -p docker/deploy/app &amp;amp;&amp;amp; cp -r target/app/* &amp;quot;$_&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, in order to remove the extraneous files I can run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ 	find docker/deploy/app -maxdepth 1 -mindepth 1 -type d \( ! \( -name &#39;lib&#39; -o -name &#39;public&#39; \) \) -exec rm -rf {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This deletes any sub-directory in the &lt;code&gt;docker/deploy&lt;/code&gt; folder &lt;strong&gt;not&lt;/strong&gt; named &lt;code&gt;lib&lt;/code&gt; (which contain the &lt;code&gt;jar&lt;/code&gt; files the application needs) or &lt;code&gt;public&lt;/code&gt; (which contains all the non-JVM resources the application needs).&lt;/p&gt;
&lt;p&gt;I now add the &lt;code&gt;entrypoint.sh&lt;/code&gt; file to the &lt;code&gt;docker&lt;/code&gt; folder. This script, which is run when the image is started, simply calls the application&amp;rsquo;s entry-point.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;#!/bin/bash
# exit immediately if error
set -e

java -jar app-runner.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, I need to ensure that the keystore used to encrypt the application&amp;rsquo;s &lt;code&gt;https&lt;/code&gt; communication is available for the image build process, so I copy it from my local file system&amp;rsquo;s location to the &lt;code&gt;/docker/deploy/local&lt;/code&gt; directory, from whence, during the image building process, it will be copied to the image&amp;rsquo;s &lt;code&gt;/image/local&lt;/code&gt; folder.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mkdir -p docker/deploy/local &amp;amp;&amp;amp; cp &amp;lt;location-of-keystore&amp;gt; &amp;quot;$_&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, with everything cleaned-up and with the script and the keystore in place, I can create the application&amp;rsquo;s docker image, tagging it with the label &lt;code&gt;testapp:dev&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker build -t testapp:dev docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then run a container based on that image using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run --rm --name test 
    --env ALLOC_KEYSTORE_PASSWORD=&amp;lt;the-real-keystore-password&amp;gt; 
    -p:8081:8081 
    -it testapp:dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can then open my browser to 
&lt;a href=&#34;https://localhost:8081/r/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;https://localhost:8081/r/home&lt;/code&gt;&lt;/a&gt; in order to confirm it&amp;rsquo;s running correctly.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;
When I created the image I did not include the correct password for the keystore in the Dockerfile. Therefore, in order for the application to work correctly I&amp;rsquo;m required to pass the correct value by setting the env variable &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt; when I start the container. It will be used in lieu of the value embedded in the image.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;docker-secrets&#34;&gt;Docker Secrets&lt;/h2&gt;
&lt;p&gt;Passing sensitive information using environment variables is satisfactory in many situations, but there is available a better approach: &lt;strong&gt;docker secrets&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;
Docker secrets are &lt;strong&gt;not&lt;/strong&gt; available in stand-alone mode, the feature is only available in &lt;strong&gt;swarm&lt;/strong&gt; mode.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;passing-configuration-values&#34;&gt;Passing Configuration Values&lt;/h3&gt;
&lt;p&gt;For further details on the subject of passing configurations to a Clojure application you can refer to my 
&lt;a href=&#34;https://heykieran.github.io/post/clojure-configuration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt; on the subject. The post also discusses more fully the mechanics of how the configuration is used by the application&amp;rsquo;s code.&lt;/p&gt;
&lt;h3 id=&#34;create-a-swarm&#34;&gt;Create a swarm&lt;/h3&gt;
&lt;p&gt;To create a local swarm for testing I can issue the following command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker swarm init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the swarm has been initialized I can add a secret to the registry. Let&amp;rsquo;s suppose I want to protect the &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt; and avoid having to pass it to the image as an environment variable. I can simply create a docker secret to hold the value, protecting it from being stolen too easily. The following command will create a secret called &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt;, set its value to &lt;code&gt;MYKEYSTOREPASSWORD&lt;/code&gt; and store it in the swarm&amp;rsquo;s registry.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ printf &amp;quot;MYKEYSTOREPASSWORD&amp;quot; | docker secret create ALLOC_KEYSTORE_PASSWORD -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can test that the secret was successfully created by issuing&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker secret ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to use the secret, the container has to be started as a service within the swarm, and on the command line must be specified to what secrets the service has access. In order to start the container with access to the &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt; and linking swarm&amp;rsquo;s network to the host&amp;rsquo;s network I can issue the following command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service create --replicas 1 \
    --secret ALLOC_KEYSTORE_PASSWORD \ 
    --name testapp \
    --publish mode=host,published=8081,target=8081 \
    testapp:dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will start the service (named &lt;code&gt;testapp&lt;/code&gt;) within the swarm, and the service will start serving the application similarly to when I used the &lt;code&gt;docker run&lt;/code&gt; command above.&lt;/p&gt;
&lt;p&gt;Once started the following command will return basic information about the service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this information should look something like the following&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
kjzh1uc2ttng        testapp             replicated          1/1                 testapp:dev         
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If I want to monitor the activity of the service I should monitor the &lt;strong&gt;logs&lt;/strong&gt; of its associated container and, in order to do this I need to know the container&amp;rsquo;s ID.&lt;/p&gt;
&lt;p&gt;I can issue the following command and note the value in the &lt;code&gt;CONTAINER_ID&lt;/code&gt; column for the image &lt;code&gt;testapp:dev&lt;/code&gt; and use it to interrogate the logs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker container ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will return something like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS                    NAMES
d5b269d508b4        testapp:dev         &amp;quot;/sbin/entrypoint.sh&amp;quot;   15 seconds ago      Up 14 seconds       0.0.0.0:8081-&amp;gt;8081/tcp   testapp.1.tb4n70oe1t8tz3qdzo2aawmek
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And I can view the logs of the running container using as much of the container&amp;rsquo;s ID as necessary to make it unique&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker logs d5b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This allows me to confirm that the application started correctly and is responding to requests.&lt;/p&gt;
&lt;p&gt;As before, I can point my browser at 
&lt;a href=&#34;https://localhost:8081/r/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;https://localhost:8081/r/home&lt;/code&gt;&lt;/a&gt; and exercise the packaged application running as a docker service.&lt;/p&gt;
&lt;p&gt;After some activity I can review the history of my interactions (and the server&amp;rsquo;s responses) by once again reviewing the logs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker logs d5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To shutdown the service, I run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service rm testapp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;review&#34;&gt;Review&lt;/h2&gt;
&lt;p&gt;There were quite a number of steps but I hope the detail was illuminative.&lt;/p&gt;
&lt;p&gt;A later post will illustrate how to integrate the build process within the Clojure application directory structure rather than requiring that it be cloned into a separate working directory.&lt;/p&gt;
&lt;p&gt;That post will also show how the build and deployment steps can be automated using a simple Makefile.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pedestal API, ClojureScript SPA and Google Authentication</title>
      <link>https://heykieran.github.io/post/pedestal-and-google/</link>
      <pubDate>Mon, 27 Apr 2020 11:53:08 -0400</pubDate>
      <guid>https://heykieran.github.io/post/pedestal-and-google/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The following are some notes about a 
&lt;a href=&#34;https://github.com/heykieran/clj-pedestal-spa/tree/v1.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repository&lt;/a&gt;
containing working code (extracted from a larger project) demonstrating a
combination of a secured &lt;strong&gt;Pedestal&lt;/strong&gt; website (and associated API services), and
a &lt;strong&gt;React&lt;/strong&gt;-ive ClojureScript front-end application that utilizes either Google
or bespoke login logic to identify and validate the user&amp;rsquo;s credentials, and sets
his/her authorization levels.&lt;/p&gt;
&lt;p&gt;I hope that it may be helpful to anyone else who may know how each of the the
individual pieces work, but is wondering how to put it all together.&lt;/p&gt;
&lt;p&gt;I owe a debt of gratitude to Tristan Straub, as much of the front-end logic (and
code) to utilize Google&amp;rsquo;s login is based on some code he posted on

&lt;a href=&#34;https://github.com/tristanstraub/cljs-google-signin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;. I&amp;rsquo;ve changed the
code in many ways, so any errors are not his but mine.&lt;/p&gt;
&lt;p&gt;The front-end application, which is intentionally simple, allows a user to
login, and according to his/her permissions will allow access to various
resources. The application is written using React/ReFrame, Semantic UI React and
ClojureScript. The application uses Figwheel-main to compile and, in development
mode run the front-end; but switching to a different tool-chain (e.g.
shadow-cljs) should be relatively easy.&lt;/p&gt;
&lt;h1 id=&#34;features&#34;&gt;Features&lt;/h1&gt;
&lt;h3 id=&#34;google-login-integration-and-mapping-to-application-id&#34;&gt;Google Login Integration (and mapping to application id)&lt;/h3&gt;
&lt;p&gt;The application demonstrates how to integrate Google&amp;rsquo;s login
functionality with a ClojureScript application. After successfully
authenticating with Google, the user&amp;rsquo;s Google &lt;em&gt;email&lt;/em&gt; address is
associated with one (and only one) internal application user ID. The
internal user ID is associated internally with one or more application
defined roles, which are defined in the code.&lt;/p&gt;
&lt;p&gt;Conceivably, this &lt;em&gt;mapping&lt;/em&gt; of external ID to internal ID could allow
multiple external authentication services to be used to map multiple
externally asserted identities to a single internal user ID. For
example, by extending the application to use Facebook&amp;rsquo;s authentication
service, it would be possible to have both &lt;code&gt;user@gmail.com&lt;/code&gt; and
&lt;code&gt;user@facebook.com&lt;/code&gt; to be mapped to the same internal user ID, e.g.
&lt;code&gt;:user&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fundamentally, authenticating and logging in merely associates a user
with a web session. The session is the operative object and identities
are not, and cannot be shared between sessions. A user may have multiple
sessions open, but they don&amp;rsquo;t &amp;ldquo;&lt;em&gt;mingle&lt;/em&gt;&amp;rdquo;.&lt;/p&gt;
&lt;h3 id=&#34;ad-hoc-_affirmative_-login-method&#34;&gt;Ad-hoc &lt;em&gt;affirmative&lt;/em&gt; login method&lt;/h3&gt;
&lt;p&gt;The application as presented allows a user to simply assert that they
are a known user. The only reason this feature is included is to
simplify debugging. In a production application these assertions would
typically be replaced with an application specific logon process.&lt;/p&gt;
&lt;h3 id=&#34;isolation-of-sensitive-information-from-codebase&#34;&gt;Isolation of sensitive information from codebase&lt;/h3&gt;
&lt;p&gt;In order to run Pedestal/Jetty (for production) or Figwheel/Jetty (for
development) with https (required to use Google login) the location of a
keystore and its password must be supplied.&lt;/p&gt;
&lt;p&gt;This is an obvious security concern - including any sensitive information in
either the source-code, or the application&amp;rsquo;s generated js code is poor security
hygiene. The application avoids this by using environment variable (assumed to
be available) to store this information which is read-only at runtime.&lt;/p&gt;
&lt;h3 id=&#34;secured-api-end-points-by-role-membership&#34;&gt;Secured API end-points by role membership&lt;/h3&gt;
&lt;p&gt;The application uses role-based security, where access to resources (URI&amp;rsquo;s) is
permitted or prohibited according to whether a user has membership within a
particular role. A user ID can be associated with one or more roles. Roles are
independent of one another. There is no concept of hierarchy or inheritance
beyond how the code chooses to handle these concepts.&lt;/p&gt;
&lt;p&gt;The application, for our purposes, defines three roles: &lt;code&gt;:admin&lt;/code&gt;,
&lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:public&lt;/code&gt;. An unauthenticated user is associated with the
role &lt;code&gt;:public&lt;/code&gt;. Note that there is nothing privileged about these roles,
or their names. They are completely application defined.&lt;/p&gt;
&lt;p&gt;In the code for the application&amp;rsquo;s configuration file
(&lt;code&gt;common-src/config/config.cljc&lt;/code&gt;) you can see how these have been
defined:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(def roles-and-users
  {:admin {:roles #{:admin} 
           :users #{&amp;quot;admin@timpsongray.com&amp;quot; &amp;quot;heykieran@gmail.com&amp;quot;}}
   :user {:roles #{:user} 
          :users #{&amp;quot;user@timpsongray.com&amp;quot;}}})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we&amp;rsquo;ve defined two users &lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:admin&lt;/code&gt;, along with two
roles, also called &lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:admin&lt;/code&gt;. Users who authenticated with
the email addresses &lt;code&gt;admin@timpsongray.com&lt;/code&gt; and &lt;code&gt;heykieran@gmail.com&lt;/code&gt;
will be associated with the user ID &lt;code&gt;:admin&lt;/code&gt;, and the user with the
email address &lt;code&gt;user@timpsongray.com&lt;/code&gt; will be associated with the user ID
&lt;code&gt;:user&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we examine how routes are defined in the file
&lt;code&gt;server/be_handler_pdstl.clj&lt;/code&gt; we can see how security is applied to
URL&amp;rsquo;s.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(def routes
  (route/expand-routes
    #{[&amp;quot;/echo&amp;quot;  :get echo]
      [&amp;quot;/auth/isauthenticated&amp;quot; :post (build-secured-route-vec-to app-auth/get-current-logged-in-user) :route-name :alloc-public/is-authenticated]
      [&amp;quot;/auth/setid&amp;quot; :post (build-secured-route-vec-to app-auth/alloc-auth-explicitly-set-identity-of-user-post) :route-name :alloc-public/auth-set-id-post]
      [&amp;quot;/auth/google&amp;quot; :post (build-secured-route-vec-to app-auth/alloc-auth-google-login) :route-name :alloc-public/google-login-post]
      [&amp;quot;/auth/logout&amp;quot; :post (build-secured-route-vec-to disconnect-session) :route-name :alloc-user/auth-logout-post]
      [&amp;quot;/api/getsecresource/p&amp;quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :alloc-public/test-res]
      [&amp;quot;/api/getsecresource/u&amp;quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :alloc-user/test-res]
      [&amp;quot;/api/getsecresource/a&amp;quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :test-res]
      [&amp;quot;/r/home&amp;quot; :get [content-neg-intc respond-with-app-page] :route-name :app-main-page]}))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The current implementation uses the namespace of values
of each route&amp;rsquo;s &lt;code&gt;:route-name&lt;/code&gt; key to assign security.&lt;/p&gt;
&lt;p&gt;Any protected URL whose &lt;code&gt;:route-name&lt;/code&gt; namespace is &lt;code&gt;:alloc-public&lt;/code&gt; is
available to any user, authenticated or not.&lt;/p&gt;
&lt;p&gt;Any protected URL whose &lt;code&gt;:route-name&lt;/code&gt; namespace is &lt;code&gt;:alloc-user&lt;/code&gt; is
available to any user associated with the &lt;code&gt;:user&lt;/code&gt; role.&lt;/p&gt;
&lt;p&gt;Any protected URL whose &lt;code&gt;:route-name&lt;/code&gt; namespace is &lt;strong&gt;either&lt;/strong&gt;
&lt;code&gt;:alloc-admin&lt;/code&gt; or the default namespace is available to only users
associated with the &lt;code&gt;:admin&lt;/code&gt; role.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;URL&amp;rsquo;s are only &lt;em&gt;protected&lt;/em&gt; if they use the auth interceptors. These
interceptors are included when the function
&lt;code&gt;build-secured-route-vec-to&lt;/code&gt; is used to wrap the content handler
function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Another item to note is the three test URL&amp;rsquo;s &lt;code&gt;/api/getsecresource/p&lt;/code&gt;
(available to all users), &lt;code&gt;/api/getsecresource/u&lt;/code&gt; (available to users in
the &lt;code&gt;:user&lt;/code&gt; role) and &lt;code&gt;/api/getsecresource/a&lt;/code&gt; (available only to users
in the &lt;code&gt;:admin&lt;/code&gt; role) use the same handler &lt;code&gt;get-secured-resource&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;development-server--production-server&#34;&gt;Development Server &amp;amp; Production Server&lt;/h3&gt;
&lt;p&gt;The application has both a &lt;em&gt;development&lt;/em&gt; mode and a &lt;em&gt;production&lt;/em&gt; mode. Both
modes use Pedestal as the API server, responding to requests as defined
in the &lt;code&gt;routes&lt;/code&gt; parameter used to start the server. The difference
between the two modes is in how the js files are served, and in how
front-end development proceeds, or not.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;development&lt;/em&gt; mode the application&amp;rsquo;s js files are served from a handler
(&lt;code&gt;fe-src/server/fe-handler&lt;/code&gt;) sitting behind figwheel/Jetty, and started
using the script provided in &lt;code&gt;scripts/server.clj&lt;/code&gt;. This facilitates the
&lt;em&gt;standard&lt;/em&gt; figwheel development process of having figwheel monitor a set
of source directories and regenerate and reload any changed files as
necessary. This should be familiar to anyone who&amp;rsquo;s used figwheel-main
for ClojureScript development. An alias has been defined in the
&lt;code&gt;deps.edn&lt;/code&gt; file to start all the various servers and to start figwheel.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;production&lt;/em&gt; mode, the js files are served from the Pedestal/Jetty
server itself. Of course, in order to do this the js files must have
been previously compiled by figwheel. An alias has been defined in the
&lt;code&gt;deps.edn&lt;/code&gt; file for this purpose.&lt;/p&gt;
&lt;h3 id=&#34;log-out-functionality&#34;&gt;Log-out Functionality&lt;/h3&gt;
&lt;p&gt;The application allows the user to disassociate their session from their
identity. Because the session is the operative object, this is
essentially logging out.&lt;/p&gt;
&lt;h3 id=&#34;session-expiration&#34;&gt;Session Expiration&lt;/h3&gt;
&lt;p&gt;When credentials are issued for an authenticated user and associated
with a session, the information will also contain an expiration date. If
a user attempts to access a protected resource and the credentials are
found to have expired, access is denied and the user&amp;rsquo;s credentials are
disassociated from the session. This essentially logs that user out and
he/she will need to reassociate their credentials with the session.&lt;/p&gt;
&lt;h3 id=&#34;reactreagentreframekee-frame-application&#34;&gt;React/Reagent/Reframe/kee-frame Application&lt;/h3&gt;
&lt;p&gt;The test application is a reactive application written in ClojureScript
using reagent, reframe and kee-frame. It illustrates some of the
principles required for a simple application of this type.&lt;/p&gt;
&lt;h3 id=&#34;semantic-ui-integration&#34;&gt;Semantic UI Integration&lt;/h3&gt;
&lt;p&gt;The toolkit used for widgets and styling is 
&lt;a href=&#34;https://react.semantic-ui.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SemanticUI-react&lt;/a&gt;, and the
application illustrates how the library can be used.&lt;/p&gt;
&lt;h1 id=&#34;running-the-servers--applications&#34;&gt;Running the Servers &amp;amp; Applications&lt;/h1&gt;
&lt;h3 id=&#34;setting-up-a-keystore-for-https&#34;&gt;Setting up a keystore for HTTPS&lt;/h3&gt;
&lt;p&gt;In order to run the web servers in secured mode you&amp;rsquo;ll need to create a
keystore for the certificates used by the servers and make it available
to Jetty. Instructions on how to do this can be found

&lt;a href=&#34;https://heykieran.github.io/post/pedestal-jetty-https/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;setting-up-google-login&#34;&gt;Setting up Google Login&lt;/h3&gt;
&lt;p&gt;In order to use the application for yourself you will need to get your
own Google Client ID. Instructions on how to do this can be found

&lt;a href=&#34;https://developers.google.com/identity/sign-in/web/sign-in&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You will also need to use the Google Console to inform Google of the
&lt;strong&gt;Authorized Javascript Origins&lt;/strong&gt; associated with your Client ID. These
should be the names and ports of your https endpoints. For testing,
these will typically be the server name and port of your Pedestal/Jetty
and your figwheel/Jetty (for development mode only) servers.&lt;/p&gt;
&lt;p&gt;The values should also be set in the following places&lt;/p&gt;
&lt;p&gt;In your environment the following variables should be set&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Environment Variable&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The keystore&amp;rsquo;s password&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ALLOC_KEYSTORE_LOCATION&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The keystore&amp;rsquo;s filesystem location&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ALLOC_SSL_PORT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The ssl port number used for Pedestal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ALLOC_PORT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The port number used for Pedestal&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In the &lt;code&gt;common-src/config/config.cljc&lt;/code&gt; you will need to set the following 
variables&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Configuration Variable&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;google-client-id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;your Google Client ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;my-hostname&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;your server&amp;rsquo;s name&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;figwheel-ssl-port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the port used by figwheel&amp;rsquo;s https server and serving the application&amp;rsquo;s js files&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pedestal-port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Pedestal&amp;rsquo;s HTTP port number (should match &lt;code&gt;ALLOC_PORT&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pedestal-ssl-port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Pedestal&amp;rsquo;s HTTPS port number (should match &lt;code&gt;ALLOC_SSL_PORT&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;google-callback-url&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;change the server name in this variable to match your server&amp;rsquo;s name.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In the file &lt;code&gt;dev.cljs.edn&lt;/code&gt; change the &lt;code&gt;:open-url&lt;/code&gt; parameter to match your
server&amp;rsquo;s name, and the ssl port used by figwheel. This should match 
&lt;code&gt;https://&amp;lt;my-hostname&amp;gt;:&amp;lt;pedestal-ssl-port&amp;gt;/r/home&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;starting-the-servers&#34;&gt;Starting the Server(s)&lt;/h3&gt;
&lt;h4 id=&#34;development-mode&#34;&gt;Development Mode&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In your IDE of choice, start a REPL (with the alias &lt;code&gt;:main&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Load and execute the &lt;code&gt;control&lt;/code&gt; namespace&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the function &lt;code&gt;(start-dev)&lt;/code&gt; (It&amp;rsquo;s within a &lt;code&gt;comment&lt;/code&gt; expression).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log messages are sent to the REPL output stream, so you can monitor
progress and activity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When the Pedestal server has started, run the following from a command line&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clj -A:dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will start the front-end server used by figwheel on ports 9500 and
&lt;code&gt;figwheel-ssl-port&lt;/code&gt; and will start the figwheel watch process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Your browser should automatically open to
&lt;code&gt;https://&amp;lt;my-hostname&amp;gt;:&amp;lt;figwheel-ssl-port&amp;gt;/r/home&lt;/code&gt; where the application
will be loaded. (You should have set this in &lt;code&gt;dev.cljs.edn&lt;/code&gt; as above).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    When you&amp;rsquo;re finished and wish to stop the front-end server: from the Figwheel console you issue the &lt;code&gt;:cljs/quit&lt;/code&gt; command to stop the Figwheel build process followed by Ctrl+C to stop the front-end server itself.
  &lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;production-mode&#34;&gt;Production Mode&lt;/h4&gt;
&lt;p&gt;Build the production application by running&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clj -A:prod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;from the command line. This will generate the production js files from your ClojureScript sources. Then, from the command line run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clj -A:main:main-output -m control
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will start the Pedestal server which in addition to serving API requests will also serve the js files built in the last step.&lt;/p&gt;
&lt;p&gt;Finally, open your browser and navigate to &lt;code&gt;https://&amp;lt;my-hostname&amp;gt;:8081/r/home&lt;/code&gt; to display the application&amp;rsquo;s Home page.&lt;/p&gt;
&lt;h2 id=&#34;navigating-the-application&#34;&gt;Navigating the Application&lt;/h2&gt;
&lt;h3 id=&#34;the-home-page&#34;&gt;The Home Page&lt;/h3&gt;
&lt;p&gt;When the application first starts, you can go to the Home page&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-initial-view-of-the-home-page-no-logged-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page_huaaba3d4bf3897864ad8c0dbe2950fa00_42345_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The initial view of the home page (&amp;lt;strong&amp;gt;no&amp;lt;/strong&amp;gt; logged-in user).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page_huaaba3d4bf3897864ad8c0dbe2950fa00_42345_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1338&#34; height=&#34;352&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The initial view of the home page (&lt;strong&gt;no&lt;/strong&gt; logged-in user).
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;the-applications-menu&#34;&gt;The Application&amp;rsquo;s Menu&lt;/h3&gt;
&lt;p&gt;The application is a SPA with client-side routing and has only a single menu with 5 menu items.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-main-menu-no-logged-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page-menu-no-logged-in-user_hufd402a6ba5fecc72c633474ae2fa3e3d_57047_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The main menu (&amp;lt;strong&amp;gt;no&amp;lt;/strong&amp;gt; logged-in user).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page-menu-no-logged-in-user_hufd402a6ba5fecc72c633474ae2fa3e3d_57047_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1338&#34; height=&#34;674&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The main menu (&lt;strong&gt;no&lt;/strong&gt; logged-in user).
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;strong&gt;Home&lt;/strong&gt; item will take you to the Home page&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Users&lt;/strong&gt; menu item will display the application&amp;rsquo;s Sign-In/Sign-Out page. Here you can connect an identity to your session (&lt;em&gt;log-in&lt;/em&gt;), or disconnect an identity from your session (&lt;em&gt;log-out&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Public&lt;/strong&gt; menu item will request content from an unsecured API endpoint whose content is available to any user whether authenticated or not.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;User&lt;/strong&gt; menu item will request content from an an API endpoint to which access has been restricted to users with &lt;strong&gt;role&lt;/strong&gt; memberships of &lt;code&gt;:admin&lt;/code&gt; or &lt;code&gt;:user&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Admin&lt;/strong&gt; menu item will request content from an an API endpoint to which access has been restricted to users with &lt;strong&gt;role&lt;/strong&gt; membership of &lt;code&gt;:admin&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-a-public-resource&#34;&gt;Access a Public Resource&lt;/h3&gt;
&lt;p&gt;Even though you have not yet signed in, if you click on the &lt;strong&gt;Public&lt;/strong&gt; menu item the application will respond with some content.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-access-to-public-resource-is-allowed-no-logged-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/access-public-resource_huf6a3c9ebea043d4f5d4e6b23eba4a1b4_41499_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;Access to Public Resource is allowed (&amp;lt;strong&amp;gt;no&amp;lt;/strong&amp;gt; logged-in user).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/access-public-resource_huf6a3c9ebea043d4f5d4e6b23eba4a1b4_41499_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1340&#34; height=&#34;418&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Access to Public Resource is allowed (&lt;strong&gt;no&lt;/strong&gt; logged-in user).
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;This is as expected as that resource is unsecured and available to anyone who can access the application.&lt;/p&gt;
&lt;h3 id=&#34;sign-in-as-the-localuser-user&#34;&gt;Sign-In as the &lt;code&gt;:local/:user&lt;/code&gt; User&lt;/h3&gt;
&lt;p&gt;On the Sign-In Page, click on the button labelled &lt;strong&gt;
&lt;a href=&#34;mailto:user@timpsongray.com&#34;&gt;user@timpsongray.com&lt;/a&gt;&lt;/strong&gt;. This will associate you session with the application user &lt;code&gt;:user&lt;/code&gt;, who has been assigned the &lt;code&gt;:user&lt;/code&gt; &lt;strong&gt;role&lt;/strong&gt;. This form of sign-in is a &lt;code&gt;:local&lt;/code&gt; authority sign-in. The authority is granted by the application itself.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-standard-sign-in-page-no-logged-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/sign-in-page_hu08d58e743afadb57a341d72a72bfa387_91827_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The Standard Sign-In Page (&amp;lt;strong&amp;gt;no&amp;lt;/strong&amp;gt; logged-in user).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/sign-in-page_hu08d58e743afadb57a341d72a72bfa387_91827_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1336&#34; height=&#34;868&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Standard Sign-In Page (&lt;strong&gt;no&lt;/strong&gt; logged-in user).
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Once you&amp;rsquo;ve done that you&amp;rsquo;ll be redirected to the &lt;strong&gt;Home&lt;/strong&gt; page where your session and identity details are displayed.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-after-the-user-user-has-signed-in&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-user-signed-in_hu88471979aee3312eae8537ac4b138fbe_46032_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;After the user &amp;lt;code&amp;gt;:user&amp;lt;/code&amp;gt; has signed in.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-user-signed-in_hu88471979aee3312eae8537ac4b138fbe_46032_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1340&#34; height=&#34;372&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    After the user &lt;code&gt;:user&lt;/code&gt; has signed in.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;accessing-a-protected-resource&#34;&gt;Accessing a protected resource&lt;/h3&gt;
&lt;p&gt;Now click on the &lt;strong&gt;User&lt;/strong&gt; menu item. The application will attempt to fetch a resource from an API endpoint restricted to users in the &lt;code&gt;:user&lt;/code&gt; or &lt;code&gt;:admin&lt;/code&gt; roles.&lt;/p&gt;
&lt;p&gt;Because &lt;code&gt;:user&lt;/code&gt; has that role association the contents of the resource is displayed.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-user-user-is-allowed-to-access-to-the-user-resource&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-accesses-user-page-ok_hua77f555305a4e482c429b34566c4f1b6_45163_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The user (&amp;lt;code&amp;gt;:user&amp;lt;/code&amp;gt;) is allowed to access to the &amp;lt;strong&amp;gt;User&amp;lt;/strong&amp;gt; resource.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-accesses-user-page-ok_hua77f555305a4e482c429b34566c4f1b6_45163_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1344&#34; height=&#34;426&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The user (&lt;code&gt;:user&lt;/code&gt;) is allowed to access to the &lt;strong&gt;User&lt;/strong&gt; resource.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;However, if you now click on the &lt;strong&gt;Admin&lt;/strong&gt; menu item, which attempts to fetch
data from an API endpoint restricted to &lt;code&gt;:admin&lt;/code&gt; role members only, you&amp;rsquo;ll see
an access denied message.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-user-user-is-denied-access-to-the-admin-resource&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-accesses-admin-page-denied_hu8fda4bc3b88839b1d49961b5d15e137b_125581_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The user (&amp;lt;code&amp;gt;:user&amp;lt;/code&amp;gt;) is denied access to the &amp;lt;strong&amp;gt;Admin&amp;lt;/strong&amp;gt; resource.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-accesses-admin-page-denied_hu8fda4bc3b88839b1d49961b5d15e137b_125581_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1334&#34; height=&#34;592&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The user (&lt;code&gt;:user&lt;/code&gt;) is denied access to the &lt;strong&gt;Admin&lt;/strong&gt; resource.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;sign-out-from-user&#34;&gt;Sign-Out from &lt;code&gt;:user&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Click on the &lt;strong&gt;Users&lt;/strong&gt; menu item to go to the Sign-In/Sign-Out page&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-a-view-of-the-standard-sign-out-page-with-user-user-is-logged-in&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/local-user-sign-out_hu5288488acb08e3af3122c648af377573_121592_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;A view of the standard Sign-Out page with user (&amp;lt;code&amp;gt;:user&amp;lt;/code&amp;gt;) is logged in.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/local-user-sign-out_hu5288488acb08e3af3122c648af377573_121592_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1334&#34; height=&#34;1170&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    A view of the standard Sign-Out page with user (&lt;code&gt;:user&lt;/code&gt;) is logged in.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;and at the bottom click on the button in &lt;strong&gt;Sign-Out (Local)&lt;/strong&gt; section. This will remove the identity information from your session, and return you to the Home page.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-returned-to-home-page-after-user-signs-out&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page_huaaba3d4bf3897864ad8c0dbe2950fa00_42345_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;Returned to Home Page after user signs out.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page_huaaba3d4bf3897864ad8c0dbe2950fa00_42345_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1338&#34; height=&#34;352&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Returned to Home Page after user signs out.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;sign-in-as-a-google-user&#34;&gt;Sign in as a Google User&lt;/h3&gt;
&lt;p&gt;Again, click on the &lt;strong&gt;Users&lt;/strong&gt; menu item to go to the Sign-In/Sign-Out page&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-standard-sign-in-page&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/sign-in-page_hu08d58e743afadb57a341d72a72bfa387_91827_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The Standard Sign-In Page.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/sign-in-page_hu08d58e743afadb57a341d72a72bfa387_91827_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1336&#34; height=&#34;868&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Standard Sign-In Page.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;This time however click on the Google &lt;strong&gt;Sign in&lt;/strong&gt; button. This will open the familiar Google Sign-In dialog where you can login with your Google identity. If the email address of the Google user is registered with an application user ID your session will assigned that identity, but the &lt;code&gt;:authority&lt;/code&gt; will now be &lt;code&gt;:google&lt;/code&gt;, indicating that is the entity making the assertion of identity.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-google-sign-in-dialog&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-login-dialog_hu00c65657a65268155e33b18fe1910fb9_72909_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The Google Sign-In Dialog.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-login-dialog_hu00c65657a65268155e33b18fe1910fb9_72909_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1178&#34; height=&#34;712&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Google Sign-In Dialog.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Again, you&amp;rsquo;ll be returned to the Home page where the session&amp;rsquo;s identity information is displayed.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-home-page-with-google-signed-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-user-login-home_hu0f008ac669061a5310176bfbdabf1530_48835_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The Home Page with Google signed-in user.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-user-login-home_hu0f008ac669061a5310176bfbdabf1530_48835_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1478&#34; height=&#34;352&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Home Page with Google signed-in user.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Because &lt;strong&gt;
&lt;a href=&#34;mailto:heykieran@gmail.com&#34;&gt;heykieran@gmail.com&lt;/a&gt;&lt;/strong&gt; is an alias for the user &lt;code&gt;:admin&lt;/code&gt;, that is the ID displayed in the top-right corner of the page, and consequently access to the API endpoints restricted to users in the &lt;code&gt;:admin&lt;/code&gt; role will be allowed.&lt;/p&gt;
&lt;h3 id=&#34;signing-out&#34;&gt;Signing Out&lt;/h3&gt;
&lt;p&gt;If you click on the &lt;strong&gt;Users&lt;/strong&gt; menu item you can return to the Sign-In/Sign-Out page to disconnect your session from the Google account using the &lt;strong&gt;Sign Out&lt;/strong&gt; button. This disconnects your application session, but does &lt;strong&gt;not&lt;/strong&gt; log you out from Google.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-users-page-with-a-signed-in-google-user-mapped-to-application-id-admin&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-user-sign-out-page_hua45813ca70e13bb9a469ee5545a5e2d9_106661_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;The Users page with a Signed-In Google user (mapped to application ID &amp;lt;code&amp;gt;:admin&amp;lt;/code&amp;gt;).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-user-sign-out-page_hua45813ca70e13bb9a469ee5545a5e2d9_106661_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1340&#34; height=&#34;908&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Users page with a Signed-In Google user (mapped to application ID &lt;code&gt;:admin&lt;/code&gt;).
  &lt;/figcaption&gt;


&lt;/figure&gt;

</description>
    </item>
    
  </channel>
</rss>
