<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>clojure | heykieran Code Notes</title>
    <link>https://heykieran.github.io/tag/clojure/</link>
      <atom:link href="https://heykieran.github.io/tag/clojure/index.xml" rel="self" type="application/rss+xml" />
    <description>clojure</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© Kieran J. Owens 2020</copyright><lastBuildDate>Wed, 03 Jun 2020 12:40:00 +0000</lastBuildDate>
    <image>
      <url>https://heykieran.github.io/images/logo_hu40a566661c85156769430146dbdc8595_41816_300x300_fit_lanczos_2.png</url>
      <title>clojure</title>
      <link>https://heykieran.github.io/tag/clojure/</link>
    </image>
    
    <item>
      <title>Pedestal, Buddy and Security</title>
      <link>https://heykieran.github.io/post/pedestal-buddy/</link>
      <pubDate>Wed, 03 Jun 2020 12:40:00 +0000</pubDate>
      <guid>https://heykieran.github.io/post/pedestal-buddy/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In this piece I show how to integrate 
&lt;a href=&#34;https://funcool.github.io/buddy-auth/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Buddy&amp;rsquo;s&lt;/a&gt; authentication and authorization functionality with a 
&lt;a href=&#34;http://pedestal.io/index&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pedestal&lt;/a&gt; web application.&lt;/p&gt;
&lt;p&gt;I provide a brief overview of Pedestal&amp;rsquo;s interceptor model, particularly error-handling, which we&amp;rsquo;ll use to catch and handle any authentication or authorization errors thrown by Buddy.&lt;/p&gt;
&lt;p&gt;I also cover some of Buddy&amp;rsquo;s available functionality; how to decide if access to a web resource should be allowed; and how to respond to the requesting client when access is denied.&lt;/p&gt;
&lt;h2 id=&#34;whats-not-covered&#34;&gt;What&amp;rsquo;s not covered?&lt;/h2&gt;
&lt;p&gt;For the purpose of this discussion, there is an assumption that the application is using session-based security. However, there is only a short discussion of how the user session is &lt;strong&gt;actually&lt;/strong&gt; populated for use by Pedestal and Buddy.&lt;/p&gt;
&lt;p&gt;This is an important topic and if you want to learn more about how to manage the login and session population processes, you can review the following 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-and-google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt;, where I&amp;rsquo;ve covered it more fully, or the source code for the application, using session based authentication, is available on 
&lt;a href=&#34;https://github.com/heykieran/clj-pedestal-spa/tree/v1.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; (tag &lt;strong&gt;v1.0&lt;/strong&gt;).&lt;/p&gt;
&lt;h1 id=&#34;the-web-application&#34;&gt;The Web Application&lt;/h1&gt;
&lt;p&gt;The web application will proceed through the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The user requests a resource located at a URL on the server&lt;/li&gt;
&lt;li&gt;The application identifies &amp;amp; authenticates the user&lt;/li&gt;
&lt;li&gt;The application determines the valid role(s) for the user&lt;/li&gt;
&lt;li&gt;The application determines if the user&amp;rsquo;s role(s) permit access to the resource&lt;/li&gt;
&lt;li&gt;The application either serves the resource &lt;strong&gt;or&lt;/strong&gt; returns an access-denied response.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Initially, I elide certain details, such as how the user asserts an identity, but return to them later in the piece.&lt;/p&gt;
&lt;h1 id=&#34;pedestal&#34;&gt;Pedestal&lt;/h1&gt;
&lt;p&gt;Pedestal is a set of libraries developed by the team at Cognitect to facilitate the creation of web applications in Clojure. It uses the &lt;em&gt;interceptor&lt;/em&gt; pattern, which differs from the handler/middleware pattern adopted by Ring.&lt;/p&gt;
&lt;p&gt;Oversimplifed, but adequate for our purposes, a Pedestal application is a &lt;em&gt;chain&lt;/em&gt; of interceptors with each interceptor being an entity with an &lt;code&gt;:enter&lt;/code&gt; function, a &lt;code&gt;:leave&lt;/code&gt; function, and an &lt;code&gt;:error&lt;/code&gt; function. The web-server receives a request, bundles it into a &lt;em&gt;context&lt;/em&gt; (a map) and then threads that context through each interceptor, which has an opportunity to change it, producing a final context which is marshalled into an HTTP response and returned to the requesting client.&lt;/p&gt;
&lt;p&gt;The chaining logic through the interceptors is &lt;em&gt;two-pass&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;If we consider a chain of interceptors &lt;strong&gt;I1&lt;/strong&gt;, &lt;strong&gt;I2&lt;/strong&gt; and &lt;strong&gt;I3&lt;/strong&gt;: Pedestal will push the context through &lt;strong&gt;I1&lt;/strong&gt;, then &lt;strong&gt;I2&lt;/strong&gt; and then &lt;strong&gt;I3&lt;/strong&gt;. It will then pull the context back through the chain in reverse order i.e. &lt;strong&gt;I3&lt;/strong&gt;, then &lt;strong&gt;I2&lt;/strong&gt;, and finally &lt;strong&gt;I1&lt;/strong&gt;. In the &lt;em&gt;push&lt;/em&gt; phase each interceptor&amp;rsquo;s &lt;code&gt;:enter&lt;/code&gt; function will be called with the context as its argument, and the return value (also a context) will be passed to the next interceptor&amp;rsquo;s &lt;code&gt;:enter&lt;/code&gt; function. During the &lt;em&gt;pull&lt;/em&gt; phase, each interceptor&amp;rsquo;s &lt;code&gt;:leave&lt;/code&gt; function will be called. As with the &lt;em&gt;push&lt;/em&gt; phase, each interceptor&amp;rsquo;s &lt;code&gt;:leave&lt;/code&gt; function will receive the context as its argument and is expected to return a context which is passed to the next interceptor.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;In the discussion above, I&amp;rsquo;ve stated that an interceptor function receives a context and returns a context. This is conceptually correct, but obscures one of Pedestal&amp;rsquo;s useful features.&lt;/p&gt;
&lt;p&gt;An interceptor function can also return a &lt;code&gt;core.async&lt;/code&gt; channel. When this happens, Pedestal will yield the thread, allowing other activity to occur, and will recommence when a value is available on the channel. When that happens, Pedestal will read &lt;strong&gt;one&lt;/strong&gt; value from the channel (which &lt;strong&gt;must&lt;/strong&gt; be a context) and continue processing the chain.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Although it&amp;rsquo;s not particularly relevant to our current discussion, it&amp;rsquo;s important to note that the interceptor chain is not &lt;strong&gt;fixed&lt;/strong&gt; in any general sense. An interceptor, within the context it receives, has access to the chain itself and can manipulate it.&lt;/p&gt;
&lt;p&gt;What &lt;strong&gt;is&lt;/strong&gt; relevant is how the Pedestal interceptor chain handles errors and exceptions. Although the Pedestal interceptor call sequence is analagous to a function call stack, the calls do not exist in that nested manner on the JVM call stack. Therefore, it&amp;rsquo;s not possible to use Clojure&amp;rsquo;s try/catch mechanism to catch exceptions thrown by one interceptor in a different interceptor further up the stack.&lt;/p&gt;
&lt;p&gt;The Pedestal &lt;em&gt;machinery&lt;/em&gt; catches any exception thrown by an interceptor, wraps it in an &lt;code&gt;ExceptionInfo&lt;/code&gt; instance and associates the instance into the context map with the key &lt;code&gt;:io.pedestal.interceptor.chain/error&lt;/code&gt;. Pedestal then back tracks through the interceptor chain looking for an interceptor with an &lt;code&gt;:error&lt;/code&gt; function that can handle the exception.&lt;/p&gt;
&lt;p&gt;Each &lt;code&gt;:error&lt;/code&gt; function is called with two arguments, the context (without the &lt;code&gt;:io.pedestal.interceptor.chain/error&lt;/code&gt; key) and the &lt;code&gt;ExceptionInfo&lt;/code&gt; instance. If an interceptor&amp;rsquo;s &lt;code&gt;:error&lt;/code&gt; function can handle the error the interceptor should return a context. In that case, Pedestal will continue processing the remaining interceptor&amp;rsquo;s &lt;code&gt;:leave&lt;/code&gt; functions and ultimately return a response to the client.&lt;/p&gt;
&lt;p&gt;If an interceptor&amp;rsquo;s &lt;code&gt;:error&lt;/code&gt; function cannot handle the exception it should reattach the &lt;code&gt;ExceptionInfo&lt;/code&gt; instance it received to the context (as &lt;code&gt;:io.pedestal.interceptor.chain/error&lt;/code&gt;) and return the new updated context. This allows Pedestal to continue searching for an appropriate handler.&lt;/p&gt;
&lt;p&gt;During Pedestal&amp;rsquo;s exception handling process no &lt;code&gt;:enter&lt;/code&gt; or &lt;code&gt;:leave&lt;/code&gt; functions will be called while the context map contains a &lt;code&gt;:io.pedestal.interceptor.chain/error&lt;/code&gt; entry.&lt;/p&gt;
&lt;h1 id=&#34;buddy&#34;&gt;Buddy&lt;/h1&gt;
&lt;p&gt;
&lt;a href=&#34;https://funcool.github.io/buddy-auth/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Buddy&lt;/a&gt; is a Clojure library providing authentication and authorization facilites to web applications. Although its documentation is primarily focused on ring based applications, the library itself is flexible enough to be used with just about any Clojure web-application library including Pedestal.&lt;/p&gt;
&lt;p&gt;Buddy treats authentication and authorization as independent concerns. Authentication decides who you are, and authorization determines what you can do. I discuss authentication first, and return to the topic of authorization.&lt;/p&gt;
&lt;p&gt;Within Buddy there are available many mechanisms to authenticate the user, and Buddy refers to these machanisms as &lt;em&gt;backends&lt;/em&gt;. The two we will discuss in greater detail below are &lt;strong&gt;session&lt;/strong&gt; and (in a different blog post) &lt;strong&gt;jws&lt;/strong&gt; (signed JWT).&lt;/p&gt;
&lt;p&gt;Conceptually, for all backends, Buddy&amp;rsquo;s authentication functionality is extremely simple. It occurs in two phases: a &lt;strong&gt;parse&lt;/strong&gt; phase, and an &lt;strong&gt;auth&lt;/strong&gt; phase&lt;/p&gt;
&lt;h2 id=&#34;parse-phase&#34;&gt;Parse Phase&lt;/h2&gt;
&lt;p&gt;During the &lt;strong&gt;parse&lt;/strong&gt; phase the backend takes the http request (for example, contained in Pedestal&amp;rsquo;s context map) and extracts from it any values required by the backend&amp;rsquo;s &lt;strong&gt;auth&lt;/strong&gt; phase. These values could be in the request&amp;rsquo;s headers, session, query params etc; it depends on the backend. If the parsing of the request returns nothing (&lt;code&gt;nil&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) then further processing by Buddy stops and the auth phase is not entered - the request (and the requestor) is considered &lt;code&gt;unauthenticated&lt;/code&gt;. Otherwise, the relevant values from parsing are passed to the &lt;strong&gt;auth&lt;/strong&gt; phase.&lt;/p&gt;
&lt;h2 id=&#34;auth-phase&#34;&gt;Auth Phase&lt;/h2&gt;
&lt;p&gt;During the &lt;strong&gt;auth&lt;/strong&gt; phase, the values returned by the &lt;strong&gt;parse&lt;/strong&gt; phase are used to determine the identity of the user. This involves calling the backend&amp;rsquo;s authentication function (&lt;code&gt;auth-fn&lt;/code&gt;) with those values. If the &lt;code&gt;auth-fn&lt;/code&gt; returns a non-nil, non-false value then the request map&amp;rsquo;s &lt;code&gt;:identity&lt;/code&gt; key is set to that value. This value represents an authenticated user. As with parsing, how authentication is done depends on the backend in use. Possibly, it&amp;rsquo;s an extraction of a session identifier followed by a database lookup, or even a decryption and verification of a signed JWT that was parsed from the request&amp;rsquo;s headers.&lt;/p&gt;
&lt;p&gt;Buddy provides a number of backend, but you&amp;rsquo;re also free to define your own if they do not meet your needs.&lt;/p&gt;
&lt;h1 id=&#34;review-of-application&#34;&gt;Review of Application&lt;/h1&gt;
&lt;p&gt;Considering what we know about interceptors and Buddy, we can now sketch out an approach to securing the application, and then its implementation using Pedestal interceptors.&lt;/p&gt;
&lt;h2 id=&#34;the-security-model&#34;&gt;The Security Model&lt;/h2&gt;
&lt;h3 id=&#34;user&#34;&gt;User&lt;/h3&gt;
&lt;p&gt;The basic entity is the &lt;strong&gt;user&lt;/strong&gt;. A &lt;strong&gt;user&lt;/strong&gt; can be associated with one or more email addresses. At a later stage this will allow the application use a variety of external identity providers, such as Google, Facebook, Azure etc. Obviously, an email address can be associated with &lt;strong&gt;only&lt;/strong&gt; one application &lt;strong&gt;user&lt;/strong&gt; entity.&lt;/p&gt;
&lt;h3 id=&#34;role&#34;&gt;Role&lt;/h3&gt;
&lt;p&gt;A &lt;strong&gt;user&lt;/strong&gt; can also be assigned to one or more &lt;strong&gt;roles&lt;/strong&gt;. &lt;strong&gt;Roles&lt;/strong&gt; determine a &lt;strong&gt;user&amp;rsquo;s&lt;/strong&gt; permissions within the web application. &lt;strong&gt;Roles&lt;/strong&gt; exist independently of each other and within a &lt;em&gt;flat&lt;/em&gt; structure. There are no concepts of hierarchy and inheritance.&lt;/p&gt;
&lt;h3 id=&#34;route&#34;&gt;Route&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Roles&lt;/strong&gt; are granted (or denied) HTTP &lt;em&gt;verb&lt;/em&gt; access to individual &lt;strong&gt;uri&amp;rsquo;s&lt;/strong&gt; which are represented in the Pedestal world as &lt;strong&gt;routes&lt;/strong&gt;. A &lt;strong&gt;route&lt;/strong&gt; may also be &lt;em&gt;unprotected&lt;/em&gt; meaning that its uri is accessible to unauthenticated users (i.e. the public).&lt;/p&gt;
&lt;p&gt;There are two ways to allow &lt;em&gt;unprotected&lt;/em&gt; access to a resource&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Do not use interceptors that manage or restrict access based on identity and permissions. (These interceptors are established for a &lt;strong&gt;route&lt;/strong&gt; with the &lt;code&gt;build-secured-route-vec-to&lt;/code&gt; function, which is dicussed in greater detail below).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Name the route using a value in the &lt;code&gt;:alloc-public&lt;/code&gt; namespace (see note below on how the &lt;strong&gt;permissions&lt;/strong&gt; lookup table is populated).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;
&lt;p&gt;The following code fragment defines three routes&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def routes
  (route/expand-routes
    #{[&amp;quot;/&amp;quot; :get landing-page :route-name :landing-page]
      [&amp;quot;/api/htest&amp;quot; :get (build-secured-route-vec-to test-response) 
        :route-name :alloc-user/auth-test-response-get]
      [&amp;quot;/api/htest&amp;quot; :post (build-secured-route-vec-to test-response)
       :route-name :alloc-admin/auth-test-response-post]}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each vector in the set passed to &lt;code&gt;expand-route&lt;/code&gt;, contains a uri pattern, a method, an interceptor (or vector of interceptors) and a &lt;code&gt;:route-name&lt;/code&gt; key with its associated value. The application will use the namespace of the route name to build a &lt;strong&gt;permission&lt;/strong&gt; table linking a uri to a &lt;strong&gt;role&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In the fragment above the path &lt;code&gt;/&lt;/code&gt; is available to any user (including unauthenticated users) as the only active interceptor is the &lt;code&gt;landing-page&lt;/code&gt; interceptor, which uses no authentication.&lt;/p&gt;
&lt;p&gt;The ability to &lt;code&gt;GET&lt;/code&gt; from &lt;code&gt;/api/htest&lt;/code&gt; is restricted to &lt;strong&gt;users&lt;/strong&gt; with the &lt;code&gt;:user&lt;/code&gt; &lt;strong&gt;role&lt;/strong&gt;, and the ability to &lt;code&gt;POST&lt;/code&gt; to the uri is restricted to &lt;strong&gt;users&lt;/strong&gt; with the &lt;code&gt;:admin&lt;/code&gt; &lt;strong&gt;role&lt;/strong&gt;. This is ensured because the &lt;code&gt;build-secured-route-vec-to&lt;/code&gt; function inserts the necessary authentication and permission checking interceptors into the uri&amp;rsquo;s interceptor chain before the &lt;code&gt;test-response&lt;/code&gt; handler/interceptor.&lt;/p&gt;
&lt;p&gt;This approach is helpful as Pedestal, when seeing a &lt;em&gt;pure&lt;/em&gt; handler function as the last entry in an interceptor vector, will convert it to an interceptor. (A &lt;em&gt;pure&lt;/em&gt; handler function is a single arity function taking a &lt;code&gt;request&lt;/code&gt; as its argument). This means that a handler function can be fully exercised in the REPL before attempting to secure it.&lt;/p&gt;
&lt;p&gt;Using the information encoded in the &lt;strong&gt;routes&lt;/strong&gt;, the &lt;strong&gt;permission&lt;/strong&gt; table will be constructed by the application at runtime and is used by the interceptor responsible for checking permissions that the authenticated user is in a &lt;strong&gt;role&lt;/strong&gt; required to access the resource.&lt;/p&gt;
&lt;h2 id=&#34;a-namethe-login-processa-the-log-in-process&#34;&gt;&lt;a name=&#34;the-login-process&#34;&gt;&lt;/a&gt; The Log In Process&lt;/h2&gt;
&lt;p&gt;In general, and elliding how claims are actually made, when the user attempts to log in the following sequence of events occurs on the server,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The user asserts a claim that they are a valid user with a particular email address&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the server finds this claim to be valid, it will create an &lt;strong&gt;identity-token&lt;/strong&gt; map with the following keys&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:alloc-auth/user-id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The user&amp;rsquo;s id e.g. &lt;code&gt;:admin&lt;/code&gt; or &lt;code&gt;:act-user&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:alloc-auth/token-type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The assertion type made by the user (&lt;code&gt;local&lt;/code&gt; or &lt;code&gt;google&lt;/code&gt;) and verified by the server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:alloc-auth/token&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The user&amp;rsquo;s token. This will contain fields &lt;code&gt;:email&lt;/code&gt;, &lt;code&gt;:iss&lt;/code&gt;, &lt;code&gt;:aud&lt;/code&gt;, &lt;code&gt;:iat&lt;/code&gt; and &lt;code&gt;:exp&lt;/code&gt;, which are the user&amp;rsquo;s email address, the token&amp;rsquo;s issuer, an audience indicator, the time of the token&amp;rsquo;s issuance, and the time of its expiration.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:alloc-auth/ext-token&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A jwt token created and signed by the server. It contains the user&amp;rsquo;s email address and can be used by the client to assert an identity independently of the Pedestal interceptor chain. This may be necessary when a session isn&amp;rsquo;t available i.e. a client can make a request to an api endpoint by including this token in the request&amp;rsquo;s headers, or when a request to an endpoint outside the security context of Pedestal&amp;rsquo;s interceptor chain is made e.g. a websocket connection, which is made at the Jetty Session level.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:alloc-auth/user-session&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A keyword that is a combination of the user&amp;rsquo;s id and a monotonically increasing sequence number (e.g. &lt;code&gt;:admin-8&lt;/code&gt; for user &lt;code&gt;:admin&lt;/code&gt;). Each Pedestal (Ring) session will be associated with a unique &lt;code&gt;user-session&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The server then adds the &lt;strong&gt;identity-token&lt;/strong&gt; to its record of logged in users, stored in the &lt;code&gt;server.auth.data/alloc-auth-logged-in-users&lt;/code&gt; atom.&lt;/p&gt;
&lt;p&gt;This atom retains a list of all the currently logged in users. It is a map where the key is a vector combining the &lt;code&gt;user-id&lt;/code&gt; the &lt;code&gt;user-session&lt;/code&gt; and a text flag, that is currently always the string &amp;ldquo;single-session-only&amp;rdquo;. The value stored in this map is the &lt;strong&gt;identity-token&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The server will also write the &lt;strong&gt;identity-token&lt;/strong&gt; to the Ring session&amp;rsquo;s &lt;code&gt;:identity&lt;/code&gt; field&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The server will send the Ring session&amp;rsquo;s identifier as a secure http-only cookie in a transit response to the client.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This completes the initial client/server login and authentication process.&lt;/p&gt;
&lt;h2 id=&#34;the-interceptor-chain&#34;&gt;The Interceptor Chain&lt;/h2&gt;
&lt;p&gt;Now, a consideration of the interceptor chain built by the &lt;code&gt;build-secured-route-vec-to&lt;/code&gt; function. This function taking as its first argument an interceptor (or handler function) will return a vector of interceptors appropriate for the dual functions of authenticating the &lt;strong&gt;user&lt;/strong&gt; and authorizing his/her access to the resource (uri). The function also accepts a number of other options, which we will return to later.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The first interceptor in the security-related portion of the interceptor chain attempts to authenticate the user. It is provided a context map, and will update the &lt;code&gt;:request&lt;/code&gt; portion of the context map using the &lt;code&gt;buddy.auth.middleware/authentication-request&lt;/code&gt; function.
This function takes as parameters the request, and the backend. It will populate the &lt;code&gt;:identity&lt;/code&gt; key of the request map if authentication suceeds (as determined by the backend). If the authentication fails the backend&amp;rsquo;s &lt;code&gt;:unauthorized-handler&lt;/code&gt; is called. This returns a 401 response to the client.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The next interceptor retrieves the &lt;code&gt;:identity&lt;/code&gt; from the the context&amp;rsquo;s &lt;code&gt;:request&lt;/code&gt; map and looks up the roles associated with the user. It attaches the information retrieved to the context map using the key &lt;code&gt;:alloc-auth/auth&lt;/code&gt;. The value added will be a map with two keys &lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:roles&lt;/code&gt;. By attaching this information to the context map, it becomes available for interceptors later in the chain.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Then the &lt;em&gt;&lt;strong&gt;error catching&lt;/strong&gt;&lt;/em&gt; interceptor (created by the function &lt;code&gt;alloc-auth-unauthorized-interceptor&lt;/code&gt;) is entered. It returns the received context map unchanged. It&amp;rsquo;s only responsibility is to handle exceptions that might be thrown later by the interceptors named &lt;code&gt;:alloc-auth-permission-checker&lt;/code&gt; and &lt;code&gt;:alloc-auth-access-rule-checker&lt;/code&gt;. These two interceptors in turn check the user&amp;rsquo;s access to a resource (uri) based on his/her assigned roles; and checks his/her access based on custom defined rules. (I provide a expanded description of both below.)&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
&lt;div&gt;
  A benefit of using a single &lt;em&gt;error catching&lt;/em&gt; interceptor is that there is a consolidation of application responses in a single area of the code rather than having them spread throughout the code in other interceptors&amp;rsquo; &lt;code&gt;:error&lt;/code&gt; functions. The interceptor is created by the &lt;code&gt;alloc-auth-unauthorized-interceptor&lt;/code&gt; function which will select the appropriate &lt;em&gt;backend&lt;/em&gt; at the time an authentication or authorization error is encountered. Therefore, in addition to the consistency of responses mentioned above, this approach ensures that backends are fully &lt;em&gt;swappable&lt;/em&gt; and can be changed without impacting other areas of the code.
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The next interceptor in the chain (&lt;code&gt;:alloc-auth-permission-checker&lt;/code&gt;) extracts the &lt;code&gt;:alloc-auth/auth&lt;/code&gt; value from the context map and compares its &lt;code&gt;:roles&lt;/code&gt; value against the roles required to access the resource using the &lt;strong&gt;permissions&lt;/strong&gt; table. If the comparison fails to find a match between the user&amp;rsquo;s assigned roles and the roles required to access the resource, the interceptor will throw an &amp;ldquo;Alloc-Unauthorized&amp;rdquo; exception. This will cause Pedestal to start looking for a handler, finding it in the &lt;em&gt;&lt;strong&gt;error catching&lt;/strong&gt;&lt;/em&gt; interceptor (see above), which ultimately returns a 401 or 403 response to the client.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the request has gotten this far, then the user is &lt;em&gt;superficially&lt;/em&gt; allowed to access the resource (by HTTP &lt;em&gt;verb&lt;/em&gt; and uri), but there may be other, &lt;em&gt;finer&lt;/em&gt; restrictions to be considered. The final interceptor related to security is now entered (&lt;code&gt;:alloc-auth-access-rule-checker&lt;/code&gt;). It takes the context map&amp;rsquo;s &lt;code&gt;:request&lt;/code&gt; value and runs a set of rules against it using functions in the &lt;code&gt;buddy.auth.accessrules&lt;/code&gt; namespace. If these rules result in a &lt;code&gt;success&lt;/code&gt; the resource is returned to the client; if not, an exception is thrown, which is again handled by the &lt;em&gt;&lt;strong&gt;error catching&lt;/strong&gt;&lt;/em&gt; interceptor. This will return a 401 or 403 response to the client as appropriate.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;access-rules&#34;&gt;Access Rules&lt;/h2&gt;
&lt;p&gt;Access rules are helpful when an application developer want to allow access to a &lt;strong&gt;route&lt;/strong&gt; only under certain circumstances; circumstances that cannot be encoded in a &lt;strong&gt;route&lt;/strong&gt;&amp;lsquo;s uri pattern. As a trivial example, consider the situation where the developer wants to grant access to a uri pattern &lt;code&gt;/api/dostuff/:id&lt;/code&gt; between 9:00AM and 5:00PM only.&lt;/p&gt;
&lt;p&gt;A way to achieve this is to use an &lt;strong&gt;access rule&lt;/strong&gt; defined according to the convention required by &lt;code&gt;buddy.auth.accessrules&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Such a rule can be expressed as follows&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def rule-1
  [{:uri &amp;quot;/api/dostuff/:id&amp;quot;
    :handler
         (fn [request]
           (let
             [d (time/local-date) n (time/local-date-time)]
             (if (time/before?
               (time/local-date-time (str d &amp;quot;T09:00:00&amp;quot;))
               n
               (time/local-date-time (str d &amp;quot;T17:00:00&amp;quot;)))
                 (buddy.auth.accessrules/success)
                 (buddy.auth.accessrules/error))))}])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If it was required that the &lt;strong&gt;role&lt;/strong&gt; should be granted access during those hours only, and when the &lt;code&gt;:id&lt;/code&gt; parameter is equal to &amp;ldquo;&lt;code&gt;company1&lt;/code&gt;&amp;rdquo; the rule would be&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def rule1
  [{:uri &amp;quot;/api/dostuff/:id&amp;quot;
    :handler
         (fn [request]
           (let
             [{company-id :id}
              (-&amp;gt; request :match-params)
              user-identity (-&amp;gt; request :identity)
              auth? (buddy.auth/authenticated? request)
              uri (-&amp;gt; request :uri)
              d (time/local-date)
              n (time/local-date-time)]
             (if (and
                   (= company-id &amp;quot;company1&amp;quot;)
                   (time/before?
                     (time/local-date-time (str d &amp;quot;T09:00:00&amp;quot;))
                     n
                     (time/local-date-time (str d &amp;quot;T17:00:00&amp;quot;))))
               (buddy.auth.accessrules/success)
               (buddy.auth.accessrules/error))))}])
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Because, &lt;code&gt;buddy-auth&lt;/code&gt; attaches the user&amp;rsquo;s identity to the &lt;code&gt;request&lt;/code&gt; map in the context map, it can be retrived and used during the processing of an access rule. Also, any path params extracted from the uri will be available in the handler function in the &lt;code&gt;request&lt;/code&gt; map&amp;rsquo;s &lt;code&gt;:path-params&lt;/code&gt; field.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When a rule returns &lt;code&gt;error&lt;/code&gt; it results in an unauthorized exception being raised by the backend. This exception is caught in the &lt;em&gt;&lt;strong&gt;error catching&lt;/strong&gt;&lt;/em&gt; interceptor as before.&lt;/p&gt;
&lt;h1 id=&#34;buddy-backends&#34;&gt;Buddy Backends&lt;/h1&gt;
&lt;p&gt;As previously mentioned, a backend is responsible for providing a function (&lt;code&gt;authfn&lt;/code&gt;) that can authenticate a user, a function (&lt;code&gt;unauthorized-handler&lt;/code&gt;) responsible for handling authentication and authorization failures, and possibly a function (&lt;code&gt;on-error&lt;/code&gt;) to handle errors.&lt;/p&gt;
&lt;p&gt;Internally, a backend is an instance of an object that implements two protocols defined in the &lt;code&gt;buddy.auth.protocols&lt;/code&gt; namespace, namely &lt;code&gt;IAuthentication&lt;/code&gt; and &lt;code&gt;IAuthorization&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IAuthentication&lt;/code&gt; protocol must provide the &lt;code&gt;-parse&lt;/code&gt; method, a function to extract any required information from the suplied request; and the &lt;code&gt;-authenticate&lt;/code&gt; method, a function to authenticate the user. The &lt;code&gt;-authenticate&lt;/code&gt; method will call the &lt;code&gt;authfn&lt;/code&gt; function passed when the backend is created in the application.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IAuthorization&lt;/code&gt; protocol must provide the &lt;code&gt;-handle-unauthorized&lt;/code&gt; method which will call the &lt;code&gt;unauthorized-handler&lt;/code&gt; function with the request map and a metadata argument describing the failure.&lt;/p&gt;
&lt;p&gt;Fortunately, &lt;code&gt;buddy-auth&lt;/code&gt; comes with a number of built-in backends.&lt;/p&gt;
&lt;h2 id=&#34;the-session-back-end&#34;&gt;The Session Back-End&lt;/h2&gt;
&lt;p&gt;One of the back-ends provided by Buddy is &lt;code&gt;session&lt;/code&gt;, which relies on ring&amp;rsquo;s 
&lt;a href=&#34;https://ring-clojure.github.io/ring/ring.middleware.session.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;session&lt;/a&gt; support. During the parse phase, the request&amp;rsquo;s session map is inspected for an &lt;code&gt;:identity&lt;/code&gt; key. If that key exists it&amp;rsquo;s passed to the auth phase, which simply sets the request map&amp;rsquo;s &lt;code&gt;:identity&lt;/code&gt; key to that value. It&amp;rsquo;s really that simple.&lt;/p&gt;
&lt;p&gt;If you use sessions there are a number of security implications that you should consider. First, although the complete session information exists only on the server, the session&amp;rsquo;s identifier is passed back and forth between the client and the server, and despite some of the security mechanisms employed by browsers (and user agents, more generally), and the cookie-based session functionality provided by ring you will need to be careful.&lt;/p&gt;
&lt;p&gt;You should only use https. This ensures that the information passed between the client and the server is encryped in transit. Also, cookies should be set to &lt;code&gt;Secure&lt;/code&gt;. Also, you should consider strongly the use of &lt;code&gt;HttpOnly&lt;/code&gt; and &lt;code&gt;SameSite&lt;/code&gt;. 
&lt;a href=&#34;https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OWASP&lt;/a&gt; provides some very good information regarding session security, and you should review it.&lt;/p&gt;
&lt;h2 id=&#34;using-ring-session-middleware-with-pedestal&#34;&gt;Using Ring Session Middleware with Pedestal&lt;/h2&gt;
&lt;p&gt;Because of the fundamental differences between Pedestal&amp;rsquo;s interceptor model and Ring&amp;rsquo;s wrapped middleware model, Pedestal provides in its &lt;code&gt;io.pedestal.http.ring-middlewares&lt;/code&gt; namespace an ability to adapt a Ring middleware function to an interceptor context. Conveniently, the namespace also provides a function (&lt;code&gt;session&lt;/code&gt;) which does this specifically for adapting Ring&amp;rsquo;s session middleware. We only need to include the interceptor returned by this function in our interceptor chain to make use of Ring sessions in our Pedestal application.&lt;/p&gt;
&lt;h2 id=&#34;using-buddys-session-back-end-with-pedestal&#34;&gt;Using Buddy&amp;rsquo;s session back-end with Pedestal&lt;/h2&gt;
&lt;p&gt;Buddy provides an implementation of the &lt;code&gt;session&lt;/code&gt; back-end in the &lt;code&gt;buddy.auth.backends&lt;/code&gt; namespace and it can be instantiated using the &lt;code&gt;buddy.auth.backends/session&lt;/code&gt; function. This function can also accept an options map containing &lt;code&gt;:authfn&lt;/code&gt; and &lt;code&gt;:unauthorized-handler&lt;/code&gt; keys, which if supplied are expected to be functions that handle authentication and what to do when a request is not authorized respectively. If neither is supplied, Buddy will supply sensible defaults.&lt;/p&gt;
&lt;p&gt;For our purposes, the default &lt;code&gt;:authfn&lt;/code&gt; function will suffice, but because we will later have to handle authorization we will provide our own &lt;code&gt;:unauthorized-handler&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
(def alloc-auth-session-auth-backend
  (auth.backends/session
    {:unauthorized-handler
     (fn unauthorized-handler
       [request metadata]
       (let [{user         :user roles :roles required :required
              user-session :user-session}
             (get-in metadata [:details :request])
             error-message
             (str &amp;quot;NOT AUTHORIZED (SESSION): In unauthenticated handler for &amp;quot;
                  &amp;quot;uri: &amp;quot; (pr-str (:uri request)) &amp;quot;, &amp;quot;
                  &amp;quot;and path-params &amp;quot;
                  (pr-str (:path-params request)) &amp;quot;. &amp;quot;
                  &amp;quot;user: &amp;quot; (pr-str user) &amp;quot;, &amp;quot;
                  &amp;quot; roles: &amp;quot; (pr-str roles) &amp;quot;. &amp;quot;
                  &amp;quot;required: &amp;quot; (pr-str required) &amp;quot;. &amp;quot;
                  &amp;quot;user-session: &amp;quot; (pr-str user-session) &amp;quot;.&amp;quot;)]
         (if user-session
           (rlog/with-forward-context
             user-session
             (log/error
               error-message))
           (log/error
             error-message)))
       (cond
         ;; If request is authenticated, raise 403 instead
         ;; of 401 (because user is authenticated but permission
         ;; denied is raised).
         (auth/authenticated? request)
         (-&amp;gt; (ring-response/response
               {:reason
                (str &amp;quot;Authenticated, but not authorized for access to .\n&amp;quot;
                     &amp;quot;Metadata : &amp;quot; (pr-str metadata))})
             (assoc :status 403))
         ;; In other cases, respond with a 401.
         :else
         (let [current-url (:uri request)]
           (-&amp;gt;
             (ring-response/response
               {:reason &amp;quot;Unauthorized&amp;quot;})
             (assoc :status 401)
             (ring-response/header &amp;quot;WWW-Authenticate&amp;quot; &amp;quot;tg-auth, type=1&amp;quot;)))))}))

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;the-route-and-interceptor-implementations&#34;&gt;The Route and Interceptor Implementations&lt;/h1&gt;
&lt;h2 id=&#34;building-the-interceptor-chain&#34;&gt;Building the Interceptor Chain&lt;/h2&gt;
&lt;p&gt;For each Pedestal route defined in the application, an interceptor chain (a vector of interceptors) is constructed and included in the service map which is passed to &lt;code&gt;io.pedestal.http/start&lt;/code&gt; to start the server. The application uses a function &lt;code&gt;build-secured-route-vec-to&lt;/code&gt; to return a vector of interceptors that are &lt;em&gt;installed&lt;/em&gt; for the route. The vector returned will include a number of common interceptors in addition to the security-related interceptors we&amp;rsquo;ve been discussing.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;build-secured-route-vec-to&lt;/code&gt; function takes as parameters a &lt;strong&gt;handler&lt;/strong&gt; (or interceptor), and potentially two option parameters, &lt;code&gt;:use-headers&lt;/code&gt; and &lt;code&gt;:rules&lt;/code&gt;. The &lt;strong&gt;handler&lt;/strong&gt; is installed as the last interceptor in the chain, and is expected to provide the business-logic functionality.&lt;/p&gt;
&lt;p&gt;If a &lt;code&gt;:rules&lt;/code&gt; option is supplied, it is expected to be a map conforming to the format required by &lt;code&gt;buddy.auth.accessrules&lt;/code&gt;. The presence of the &lt;code&gt;:rules&lt;/code&gt; option will also cause the &lt;code&gt;:alloc-auth-access-rule-checker&lt;/code&gt; interceptor to be included in the vector of interceptors returned.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;:use-headers&lt;/code&gt; option can be ignored for now. It will be the subject of another blog post discussing how to create a custom backend for Buddy.&lt;/p&gt;
&lt;h2 id=&#34;the-security-interceptors&#34;&gt;The Security Interceptors&lt;/h2&gt;
&lt;p&gt;Now let&amp;rsquo;s take a closer look at the implementation details of the security-related interceptors mentioned above.&lt;/p&gt;
&lt;h3 id=&#34;the-alloc-auth-authenticate-interceptor&#34;&gt;The &lt;code&gt;:alloc-auth-authenticate&lt;/code&gt; interceptor&lt;/h3&gt;
&lt;p&gt;This interceptor is responsible for the authentication of the user and is created by the  &lt;code&gt;alloc-auth-authentication-interceptor&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn alloc-auth-authentication-interceptor
  [backend]
  (interceptor/interceptor
    {:name  ::alloc-auth-authenticate
     :enter (fn [ctx]
              (-&amp;gt; ctx
                  (assoc
                    :auth/backend
                    backend)
                  (update
                    :request
                    auth.middleware/authentication-request
                    backend)))}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;authentication-request&lt;/code&gt; is a function which takes a &lt;strong&gt;request&lt;/strong&gt; and a &lt;strong&gt;backend&lt;/strong&gt; and using the &lt;strong&gt;backend&lt;/strong&gt; attempts to parse the &lt;strong&gt;request&lt;/strong&gt; and to authenticate the user. If the user is sucessfully authenticated an &lt;code&gt;:identity&lt;/code&gt; key is added to the request map with the value returned by the backend&amp;rsquo;s &lt;code&gt;authfn&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;The interceptor performs two functions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;it attaches to the context map the authentication backend being used. This makes it available to other interceptors later in the chain, particularly the &lt;strong&gt;error catcher&lt;/strong&gt; interceptor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it updates and returns the context map with the (potentially) updated &lt;strong&gt;request&lt;/strong&gt; map returned by the call to &lt;code&gt;authentication-request&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;the-alloc-auth-user-roles-interceptor&#34;&gt;The &lt;code&gt;:alloc-auth-user-roles&lt;/code&gt; interceptor&lt;/h3&gt;
&lt;p&gt;This interceptor will attach to the context map information about the roles to which the user has been assigned. It is created by calling the &lt;code&gt;alloc-auth-user-roles-interceptor&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn alloc-auth-user-roles-interceptor
  []
  {:name  ::alloc-auth-user-roles
   :enter (fn [ctx]
            (log/info &amp;quot;Assigning roles for identity &amp;quot; 
              (pr-str (get-in ctx [:request :identity])))
            (let
              [{identity-user-id    :alloc-auth/user-id
                identity-token-type :alloc-auth/token-type
                identity-token      :alloc-auth/token}
               (get-in ctx [:request :identity])]
              (assoc
                ctx
                :alloc-auth/auth
                {:user  identity-user-id
                 :roles (alloc-auth-get-roles-for-identity identity-user-id)})))})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This interceptor was discussed quite extensively above, but two items are worth noting. The authenticated user (in the &lt;strong&gt;request&lt;/strong&gt; map&amp;rsquo;s &lt;code&gt;:identity&lt;/code&gt; field) is expected to be identified by a map with the keys &lt;code&gt;:alloc-auth/user-id&lt;/code&gt;, &lt;code&gt;:alloc-auth/token-type&lt;/code&gt; and &lt;code&gt;:alloc-auth/token&lt;/code&gt;. For our current discussion the first of these is the most important, and using buddy&amp;rsquo;s session backend would have been extracted from the user&amp;rsquo;s session object. It is the internal application user id for the user e.g. &lt;code&gt;:admin&lt;/code&gt; or &lt;code&gt;:fred&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This value is used by &lt;code&gt;alloc-auth-get-roles-for-identity&lt;/code&gt; to return a collection of &lt;strong&gt;role&lt;/strong&gt; entities indicating with which roles the user is associated. The interceptor returns an updated context with this information attached in the &lt;code&gt;:alloc-auth/auth&lt;/code&gt; key.&lt;/p&gt;
&lt;h3 id=&#34;the-error-catcher-interceptor&#34;&gt;The Error Catcher interceptor&lt;/h3&gt;
&lt;p&gt;This interceptor will catch authentication and authorization errors raised by the &lt;code&gt;:alloc-auth-permission-checker&lt;/code&gt; and &lt;code&gt;:alloc-auth-access-rule-checker&lt;/code&gt; interceptors (any others are ignored). This interceptor is created by calling the &lt;code&gt;alloc-auth-unauthorized-interceptor&lt;/code&gt; function, which internally uses Pedestal&amp;rsquo;s &lt;code&gt;error-dispatch&lt;/code&gt; function to match errors with handlers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn alloc-auth-unauthorized-interceptor
  []
  (letfn
    [(unauthorized-fn[ctx ex]
       (if-let
         [handling-backend (:auth/backend ctx)]
         (assoc
           ctx
           :response
           (.-handle-unauthorized
             handling-backend
             (:request ctx)
             {:details
              {:request (ex-data (ex-cause ex))
               :message (pr-str (ex-message (ex-cause ex)))}}))
         (do
           (log/error &amp;quot;Unauthorized requests, but there is no backend&amp;quot;
                      &amp;quot;installed to handle the exception.&amp;quot;)
           (throw &amp;quot;No auth backend found.&amp;quot;))))]
    (error-dispatch
      [ctx ex]
      [{:exception-type :clojure.lang.ExceptionInfo 
        :interceptor ::alloc-auth-permission-checker}]
      (try
        (unauthorized-fn ctx ex)
        (catch Exception e
          (assoc ctx ::interceptor.chain/error e)))
      [{:exception-type :clojure.lang.ExceptionInfo 
        :interceptor :alloc-auth-access-rule-checker}]
      (try
        (unauthorized-fn ctx ex)
        (catch Exception e
          (assoc ctx ::interceptor.chain/error e)))
      :else
      (assoc ctx ::interceptor.chain/error ex))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function uses Pedestal&amp;rsquo;s &lt;code&gt;error-dispatch&lt;/code&gt; function to create an interceptor that can handle &lt;code&gt;ExceptionInfo&lt;/code&gt; exceptions thrown by either the &lt;code&gt;::alloc-auth-permission-checker&lt;/code&gt; or &lt;code&gt;::alloc-auth-access-rule-checker&lt;/code&gt; interceptors.&lt;/p&gt;
&lt;p&gt;In the case of either exception, it will call the backend&amp;rsquo;s &lt;code&gt;-handle-unauthorized&lt;/code&gt; method (from the &lt;code&gt;IAuthorization&lt;/code&gt; protocol implemented by the backend), which ultimately calls the &lt;code&gt;unauthorized-handler&lt;/code&gt; function registered with the backend (see the notes on &lt;code&gt;alloc-auth-session-auth-backend&lt;/code&gt; above).&lt;/p&gt;
&lt;p&gt;Any errors that cannot be handled, or throw exceptions during handling are reattached to the context map - potentially to be handled by another interceptor&amp;rsquo;s &lt;code&gt;:error&lt;/code&gt; function, or escaping at the top level with a &lt;strong&gt;5xx&lt;/strong&gt; error being returned to the client.&lt;/p&gt;
&lt;p&gt;Note, that the backend instance to be used when signalling an exception is retrieved from the context map. It was added to the context map by the &lt;code&gt;:alloc-auth-authenticate&lt;/code&gt; interceptor (see above).&lt;/p&gt;
&lt;h3 id=&#34;the-alloc-auth-permission-checker-interceptor&#34;&gt;The &lt;code&gt;:alloc-auth-permission-checker&lt;/code&gt; interceptor&lt;/h3&gt;
&lt;p&gt;This interceptor checks whether the user&amp;rsquo;s &lt;strong&gt;roles&lt;/strong&gt; (embedded in the context map by &lt;code&gt;:alloc-auth-user-roles&lt;/code&gt;) allow access to the requested uri. It is created by calling the &lt;code&gt;alloc-auth-permission-checker-interceptor-factory&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn alloc-auth-permission-checker-interceptor-factory
  []
  (interceptor/interceptor
    {:name  ::alloc-auth-permission-checker
     :enter (fn [ctx]
              (log/info
                (str &amp;quot;Checking Identity: &amp;quot;
                     (pr-str 
                       (get-in ctx 
                         [:request :identity :alloc-auth/user-id] 
                          :unauthenticated))
                     &amp;quot; for access to &amp;quot;
                     (pr-str 
                       (get-in ctx [:request :path-info]))
                     &amp;quot; with path params &amp;quot;
                     (pr-str 
                       (get-in ctx [:request :path-params]))
                     &amp;quot; for route name &amp;quot;
                     (pr-str 
                       (get-in ctx [:route :route-name]))
                     &amp;quot; with session &amp;quot;
                     (pr-str 
                       (get-in ctx [:request :session]))))
              (let
                [{req-path :path-info
                  res-path-params :path-params
                  {identity-user-id    :alloc-auth/user-id
                   identity-token-type :alloc-auth/token-type
                   identity-token      :alloc-auth/token
                   user-session :alloc-auth/user-session} :identity}
                 (get-in ctx [:request])
                 {route-name        :route-name route-method :method
                  route-path-re     :path-re route-path-parts :path-parts
                  route-path-params :path-params}
                 (get-in ctx [:route])
                 {user :user roles :roles}
                 (get-in ctx [:alloc-auth/auth])
                 required-roles
                 (get-in 
                   @alloc-auth-permissions 
                   [route-name :permissions :roles])]

                (log/info
                  (str &amp;quot;User Roles: &amp;quot;
                       (pr-str roles)
                       &amp;quot; , required roles &amp;quot;
                       (pr-str required-roles)))

                (if (and
                      (not (contains? required-roles :public))
                      (empty? (clojure.set/intersection
                                roles required-roles)))
                  (throw
                    (ex-info &amp;quot;Alloc-Unauthorized&amp;quot;
                             {:path     req-path :path-params res-path-params
                              :user     user :roles roles :identity identity
                              :required required-roles
                              :user-session user-session}))
                  (update-in
                    ctx
                    [:request]
                    assoc :auth-alloc &amp;quot;ok&amp;quot;))))}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the &lt;strong&gt;roles&lt;/strong&gt; associated with the user, and &lt;code&gt;assoc&lt;/code&gt;-ed into the context map earlier as &lt;code&gt;:alloc-auth/auth&lt;/code&gt; don&amp;rsquo;t intersect with the &lt;strong&gt;roles&lt;/strong&gt; required for access (stored in the &lt;code&gt;alloc-auth-permissions&lt;/code&gt; atom) an &lt;code&gt;ex-info&lt;/code&gt; exception is thrown. The exception will be handled by the &lt;strong&gt;error catcher&lt;/strong&gt; interceptor which will return the appropriate response to the client.&lt;/p&gt;
&lt;h3 id=&#34;the-alloc-auth-access-rule-checker-interceptor&#34;&gt;The &lt;code&gt;:alloc-auth-access-rule-checker&lt;/code&gt; interceptor&lt;/h3&gt;
&lt;p&gt;If the Pedestal interceptor chain which is built using &lt;code&gt;build-secured-route-vec-to&lt;/code&gt; was passed a &lt;code&gt;:rules&lt;/code&gt; parameter, this interceptor will run the rules&amp;rsquo; handler functions to decide whether access to the resource should be granted (returns &lt;code&gt;success&lt;/code&gt;) or denied (returns &lt;code&gt;error&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn alloc-auth-rules-checker-interceptor-factory
  [rules]
  (interceptor/interceptor
    {:name  :alloc-auth-access-rule-checker
     :enter (fn [context]
              (let
                [request (:request context)
                 policy :allow
                 w-a-rules-fn
                 (auth.accessrules/wrap-access-rules
                   (fn [req] :ok)
                   {:rules rules :policy policy})]
                (w-a-rules-fn request)
                context))}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final security-related interceptor uses &lt;code&gt;buddy.auth.accessrules&lt;/code&gt; to determine if access should be granted. &lt;code&gt;buddy.auth.accessrules&lt;/code&gt; contains a &lt;code&gt;wrap-access-rules&lt;/code&gt; function that is helpful in Ring&amp;rsquo;s middleware context to wrap other Ring handlers. The interceptor uses this functionality by providing a &lt;strong&gt;synthetic&lt;/strong&gt; handler that returns &lt;code&gt;:ok&lt;/code&gt;. This works for our purposes, because the implementation of &lt;code&gt;wrap-access-rules&lt;/code&gt; when &lt;strong&gt;called&lt;/strong&gt; with a request will throw an exception if rules are violated for that request. This exception will be caught by the &lt;strong&gt;error catcher&lt;/strong&gt; interceptor. If no exception is thrown, the interceptor returns unchanged the context map it received.&lt;/p&gt;
&lt;h1 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h1&gt;
&lt;p&gt;Hopefully, if you&amp;rsquo;ve been looking for guidance on how to integrate Buddy with Pedestal this document has helped. A later post will consider how one might provide a custom backend for Buddy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploy a Clojure Web Application to Kubernetes (GKE)</title>
      <link>https://heykieran.github.io/post/deploy-to-kubernetes-gke/</link>
      <pubDate>Thu, 28 May 2020 05:49:44 -0400</pubDate>
      <guid>https://heykieran.github.io/post/deploy-to-kubernetes-gke/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In a previous blog post I showed how it was possible to take a Clojure project containing a Pedestal &lt;em&gt;back-end&lt;/em&gt; and a React &lt;em&gt;front-end&lt;/em&gt;, and package it as a Docker container which can be run as a standalone Docker image using &lt;code&gt;docker run&lt;/code&gt;, or as part of a Docker Swarm using &lt;code&gt;docker service&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this post, I will show how it is possible to deploy the same Docker container to a Kubernetes Cluster and to make the application available at a particular URL of your choosing.&lt;/p&gt;
&lt;p&gt;A repository containing the code can be found 
&lt;a href=&#34;https://github.com/heykieran/clj-pedestal-spa/tree/v1.2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; (tag &lt;strong&gt;v1.2&lt;/strong&gt;).&lt;/p&gt;
&lt;h1 id=&#34;summary-of-the-steps&#34;&gt;Summary of the steps&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Create a GCP Project&lt;/li&gt;
&lt;li&gt;Build and Tag your Docker image&lt;/li&gt;
&lt;li&gt;Upload your image to the Google Registry&lt;/li&gt;
&lt;li&gt;Create a GKE Cluster&lt;/li&gt;
&lt;li&gt;Get a Google Static IP address&lt;/li&gt;
&lt;li&gt;Create an A record in your DNS for the IP endpoint&lt;/li&gt;
&lt;li&gt;Create a Google managed SSL certificate&lt;/li&gt;
&lt;li&gt;Deploy your image to the cluster&lt;/li&gt;
&lt;li&gt;Create a back-end service over your container&lt;/li&gt;
&lt;li&gt;Create an Ingress front-end service connecting the external IP address to the back-end service over https&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;the-steps&#34;&gt;The Steps&lt;/h1&gt;
&lt;h2 id=&#34;setting-up-a-cloud-project-on-gcp&#34;&gt;Setting up a Cloud Project on GCP&lt;/h2&gt;
&lt;p&gt;Before you start, you&amp;rsquo;ll need to create a Google Cloud Project. This is a simple process, so I won&amp;rsquo;t go into the details as instructions can be found 
&lt;a href=&#34;https://cloud.google.com/resource-manager/docs/creating-managing-projects&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The current demo assumes that the project name is &lt;code&gt;clojure-app-v1&lt;/code&gt;, that a Docker daemon is running locally, and that the &lt;code&gt;docker&lt;/code&gt; binary is on your path. Also, the URL at which the application is published is chosen to be &lt;code&gt;https://demo.timpsongray.com&lt;/code&gt;. Obviously, this will be different for you.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You should also install both the &lt;code&gt;gcloud&lt;/code&gt; and &lt;code&gt;kubectl&lt;/code&gt; command line tools locally. If this is your first GCP project, don&amp;rsquo;t forget to also initialize the Cloud SDK. This will set your account&amp;rsquo;s credentials, authorize access to GCP API&amp;rsquo;s, and establish a base configuration, such as your default compute region and zone.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://cloud.google.com/sdk/install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Installing &lt;code&gt;gcloud&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://cloud.google.com/sdk/docs/initializing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Initializing the SDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once you have installed &lt;code&gt;gcloud&lt;/code&gt; locally, installing &lt;code&gt;kubectl&lt;/code&gt; is simply a matter of running&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud components install kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;from the command line.&lt;/p&gt;
&lt;p&gt;Finally, with the tools installed and your project created, you can view its details using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud projects describe allocations-accounting-v1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;setting-your-current-project&#34;&gt;Setting your Current Project&lt;/h3&gt;
&lt;p&gt;Now, you should set &lt;code&gt;allocations-accounting-v1&lt;/code&gt; to be the &lt;em&gt;current&lt;/em&gt; project. (If you&amp;rsquo;ve run &lt;code&gt;gcloud init&lt;/code&gt; as above, this should already have been done, but it&amp;rsquo;s no harm to &lt;em&gt;set&lt;/em&gt; it a second time.)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud config set project allocations-accounting-v1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;connecting-you-docker-repository-to-gcp&#34;&gt;Connecting you Docker Repository to GCP&lt;/h3&gt;
&lt;p&gt;In order to easily publish a docker image from your local machine to a GCP container registry you should configure docker to use &lt;code&gt;gcloud&lt;/code&gt; as the credential helper for all Google&amp;rsquo;s registries using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud auth configure-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;build-and-tag-the-docker-image&#34;&gt;Build and Tag the docker image&lt;/h2&gt;
&lt;h3 id=&#34;build-the-docker-image&#34;&gt;Build the docker image&lt;/h3&gt;
&lt;p&gt;If your using the repo, you can do this by issuing&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ make clean-all
$ make docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;from the command line.&lt;/p&gt;
&lt;h3 id=&#34;tag-the-image-for-upload-to-the-google-container-registry&#34;&gt;Tag the image for upload to the Google container registry&lt;/h3&gt;
&lt;p&gt;Now we&amp;rsquo;ll tag the image so it conforms with the image names expected by the Google registry.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker tag clojure-app-v1 gcr.io/allocations-accounting-v1/allocations-accounting:v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, if you don&amp;rsquo;t specify a tag the above command adds &lt;code&gt;:latest&lt;/code&gt; to the end of the full tag name. It&amp;rsquo;s good practice to explicitly specify a tag.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Google registry location is constructed using &lt;code&gt;gcr.io/&amp;lt;PROJECT_NAME&amp;gt;/&amp;lt;IMAGE_NAME&amp;gt;.&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;push-the-image-to-the-google-registry&#34;&gt;Push the image to the Google Registry&lt;/h2&gt;
&lt;p&gt;Before Google will accept a pushed image you need to enable the &lt;strong&gt;Google Container Registry API&lt;/strong&gt; for your project&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud services enable containerregistry.googleapis.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then push the tagged image using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker push gcr.io/allocations-accounting-v1/allocations-accounting:v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;create-the-cluster&#34;&gt;Create the Cluster&lt;/h2&gt;
&lt;p&gt;First enable the &lt;strong&gt;Kubernetes Engine API&lt;/strong&gt; using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud services enable container.googleapis.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which may take a few minutes.&lt;/p&gt;
&lt;p&gt;When complete, we ask GKE to create a cluster with a single node, which is sufficient for illustrative purposes.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud container clusters create allocations-accounting-v1-cluster --num-nodes=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this may take a few minutes as the cluster&amp;rsquo;s resources are created, deployed and health-checked.&lt;/p&gt;
&lt;h3 id=&#34;import-credentials&#34;&gt;Import Credentials&lt;/h3&gt;
&lt;p&gt;Once the cluster has been created we &lt;em&gt;sync&lt;/em&gt; credentials&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud container clusters get-credentials allocations-accounting-v1-cluster
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create a &lt;code&gt;kubeconfig&lt;/code&gt; entry for the cluster, and allow you to manage the new cluster using the &lt;code&gt;kubectl&lt;/code&gt; command line tool.&lt;/p&gt;
&lt;h2 id=&#34;get-a-static-ip-address-for-your-site&#34;&gt;Get a static IP address for your site&lt;/h2&gt;
&lt;p&gt;We have decided to publish our application at a well-known url (i.e. &lt;code&gt;demo.timpsongray.com&lt;/code&gt;), so we need to ensure that we have a stable, externally addressable IP address. We do this by asking GCP to assign a global IP address for our use.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud compute addresses create allocations-app-v1-addr --global
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;find-the-external-ip-address&#34;&gt;Find the external IP address&lt;/h3&gt;
&lt;p&gt;Now, find what IP address was assigned using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud compute addresses list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which should return something like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME                            ADDRESS/RANGE   TYPE      PURPOSE  NETWORK  REGION  SUBNET  STATUS
allocations-app-v1-addr         34.120.154.247  EXTERNAL                                    RESERVED
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Make a note of the IP address, and then add an &lt;strong&gt;A&lt;/strong&gt; record to your DNS associating the name &lt;code&gt;demo.timpsongray.com&lt;/code&gt; with that IP address. You may need to wait a little while for the DNS changes to propogate.&lt;/p&gt;
&lt;h3 id=&#34;create-a-secret&#34;&gt;Create a Secret&lt;/h3&gt;
&lt;p&gt;The application uses either environment variables or docker secrets to configure itself. From an internal perspective, this distinction is abstracted away with the use of the &lt;code&gt;walmartlabs/dyn-edn&lt;/code&gt; Clojure library.&lt;/p&gt;
&lt;p&gt;However, GKE adds a feature to its use of secrets that is not available with docker swarm - it&amp;rsquo;s possible to have a secret&amp;rsquo;s value dynamically injected into a container&amp;rsquo;s environment as a standard environment variable.&lt;/p&gt;
&lt;p&gt;In order to make use of this, of course, you must create a secret. This can be done as follows. (The value of &lt;code&gt;&amp;lt;THESECRET&amp;gt;&lt;/code&gt; should be the password for the keystore used by the Jetty instance in your application).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl create secret generic \
    allocations-app-v1-secrets \
    --from-literal=ALLOC_KEYSTORE_PASSWORD=&#39;&amp;lt;PASSWORD&amp;gt;&#39; \
    --from-literal ALLOC_SESSION_STORE_KEY=&#39;&amp;lt;16 byte session key&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can check that the secret was created successfully by issuing the following command and inspecting the results&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl describe secrets/allocations-app-v1-secrets
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;rsquo;s important that the length of the &lt;code&gt;ALLOC_SESSION_STORE_KEY&lt;/code&gt; value is precisely 16 bytes.&lt;/p&gt;
&lt;h2 id=&#34;deploy-your-app-to-the-cluster&#34;&gt;Deploy your App to the Cluster&lt;/h2&gt;
&lt;p&gt;Now deploy the Docker image containing the application to a container running in the cluster specifying the image recently pushed to the Google registry.&lt;/p&gt;
&lt;p&gt;During the deployment GKE will be requested to inject the values of the &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt; and &lt;code&gt;ALLOC_SESSION_STORE_KEY&lt;/code&gt; from the &lt;code&gt;allocations-app-v1-secrets&lt;/code&gt; resource as an environment variable (also called &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt; and &lt;code&gt;ALLOC_SESSION_STORE_KEY&lt;/code&gt; respectively) into the container&amp;rsquo;s run-time environment. These variables are used by the Clojure application to gain access to Jetty&amp;rsquo;s keystore, which is required to allow Jetty to publish the application on an &lt;code&gt;https&lt;/code&gt; endpoint; and the key used to encode session cookies.&lt;/p&gt;
&lt;div class=&#34;alert alert-&#34;&gt;
  &lt;div&gt;
    Kubernetes secrets can also be made available within the container at a particular mount point (using &lt;code&gt;tmpfs&lt;/code&gt;). This is similar to Docker swarm&amp;rsquo;s strategy. We could use it here, but the environment variable approach is simpler and the use of the &lt;code&gt;dyn-edn&lt;/code&gt; library ensures that there&amp;rsquo;s very little transition to be done moving from a local development environment and the Kubernetes production environment.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now instruct GKE to deploy the application using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl apply -f deploy.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where the contents of the &lt;code&gt;deploy.yaml&lt;/code&gt; file is as follows&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: allocations-app-v1
  name: allocations-app-v1-web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: allocations-app-v1
      tier: allocations-app-v1-web
  template:
    metadata:
      labels:
        app: allocations-app-v1
        tier: allocations-app-v1-web
    spec:
      containers:
      - image: gcr.io/allocations-accounting-v1/allocations-accounting:v1.0
        name: allocations-app-v1-app
        ports:
        - containerPort: 8081
        env:
        - name: ALLOC_HOST_NAME
          value: demo.timpsongray.com
        - name: ALLOC_KEYSTORE_PASSWORD
          valueFrom:
            secretKeyRef:
              key: ALLOC_KEYSTORE_PASSWORD
              name: allocations-app-v1-secrets
        - name: ALLOC_SESSION_STORE_KEY
          valueFrom:
            secretKeyRef:
              key: ALLOC_SESSION_STORE_KEY
              name: allocations-app-v1-secrets
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the &lt;code&gt;env&lt;/code&gt; in the deployment yaml file also specifies a value for &lt;code&gt;ALLOC_HOST_NAME&lt;/code&gt;. This is important as the application will make decisions about what ports to use for serving content and api endoints based on this value.&lt;/p&gt;
&lt;p&gt;In the current codebase, if the host name ends with the string &amp;ldquo;&lt;strong&gt;timpsongray.com&lt;/strong&gt;&amp;rdquo; then all communication is assumed to occur on port 80. This is probably what&amp;rsquo;s intended for a production system served using https. Obviously, your site name will be different and you should adjust the code.&lt;/p&gt;
&lt;h2 id=&#34;create-a-back-end-service&#34;&gt;Create a Back-End Service&lt;/h2&gt;
&lt;p&gt;To access the deployed application GKE is requested to create a back-end service over the pods containing the deployment. The request will be for a NodePort service, which exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using &lt;NodeIP&gt;:&lt;NodePort&gt;. Superset of ClusterIP.&lt;/p&gt;
&lt;p&gt;This is done using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl apply -f service.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where the content of the &lt;code&gt;service.yaml&lt;/code&gt; file is as follows&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: allocations-app-v1-svc
  annotations:
    cloud.google.com/app-protocols: &#39;{&amp;quot;app-https-port&amp;quot;:&amp;quot;HTTPS&amp;quot;,&amp;quot;app-http-port&amp;quot;:&amp;quot;HTTP&amp;quot;}&#39;
  labels:
    app: allocations-app-v1
spec:
  type: NodePort
  selector:
    app: allocations-app-v1
    tier: allocations-app-v1-web
  ports:
    - name: app-https-port
      port: 8081
      targetPort: 8081
    - name: app-http-port
      port: 8080
      targetPort: 8080
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;h5 id=&#34;why-http-_and-other-notes-on-health-checks_&#34;&gt;Why &lt;code&gt;http&lt;/code&gt;? &lt;em&gt;(and other notes on Health Checks)&lt;/em&gt;&lt;/h5&gt;
&lt;p&gt;GKE will automatically create &lt;em&gt;Health Checks&lt;/em&gt; to check the status of the backend services created, and which expose your deployment.&lt;/p&gt;
&lt;p&gt;By default, for web services, GKE will probe the app at a particular path (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;/healthz&lt;/code&gt;) using a particular protocol (&lt;code&gt;http&lt;/code&gt; or &lt;code&gt;https&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Network load balancers require &lt;em&gt;legacy&lt;/em&gt; health checks. These must be &lt;code&gt;http&lt;/code&gt;, which means that the backend must support &lt;code&gt;http&lt;/code&gt; probing by the health checking mechanisms. Don&amp;rsquo;t disable &lt;code&gt;http&lt;/code&gt; on NodePort service (the backend service) or GKE will complain.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although &lt;em&gt;Legacy&lt;/em&gt; health checks &lt;em&gt;can&lt;/em&gt; be &lt;code&gt;https&lt;/code&gt;, the Network Load Balancer only supports &lt;code&gt;http&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;check-the-services-status&#34;&gt;Check the Service&amp;rsquo;s Status&lt;/h3&gt;
&lt;p&gt;A convenient way to check if a web application is running correctly is to use port forwarding from your local machine to tunnel directly to the running pod. You can use the following command to open a tunnel to the node&amp;rsquo;s port 8081 (which is the home port for the &lt;em&gt;containerized&lt;/em&gt; Clojure application) from port 8080 on localhost.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud container clusters get-credentials \
  allocations-accounting-v1-cluster --zone us-east4-a --project allocations-accounting-v1 \
  &amp;amp;&amp;amp; kubectl port-forward $(kubectl get pod \
  --selector=&amp;quot;app=allocations-app-v1,tier=allocations-app-v1-web&amp;quot; \
  --output jsonpath=&#39;{.items[0].metadata.name}&#39;) 8080:8081
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then in your browser, navigate to &lt;code&gt;https://localhost:8080&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If everything is operating correctly, you should see the home page of the Clojure application served by Jetty.&lt;/p&gt;
&lt;p&gt;In your console window type &lt;code&gt;Ctrl+C&lt;/code&gt; to stop port forwarding.&lt;/p&gt;
&lt;h2 id=&#34;set-up-external-routing&#34;&gt;Set up External Routing&lt;/h2&gt;
&lt;p&gt;In the following section we will connect our chosen URL &lt;code&gt;demo.timpsongray.com&lt;/code&gt; to the application.&lt;/p&gt;
&lt;p&gt;But first we&amp;rsquo;ll need to perform a few checks and actions.&lt;/p&gt;
&lt;h3 id=&#34;check-that-the-apps-dns-name-is-available&#34;&gt;Check that the app&amp;rsquo;s DNS name is available&lt;/h3&gt;
&lt;p&gt;From the command line run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nslookup demo.timpsongray.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and ensure that the address returned is the static IP address that was created by Google earlier. This indicates that the DNS is responding correctly.&lt;/p&gt;
&lt;h3 id=&#34;create-a-google-managed-ssl-certificate&#34;&gt;Create a Google Managed SSL Certificate&lt;/h3&gt;
&lt;p&gt;We want to use &lt;code&gt;https&lt;/code&gt; on our publicly accessible endpoint so we&amp;rsquo;ll need to install an SSL certificate. There are a few ways to do this, but the most convenient is to use GCP&amp;rsquo;s managed SSL certificates.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;DNSSEC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In order for the managed certicate creation to happen correctly, and for the external IP address you provisioned to be associated with it (when you create the Ingress service), &lt;strong&gt;DNSSEC&lt;/strong&gt; must be enabled on your domain and the &lt;strong&gt;&lt;code&gt;A&lt;/code&gt;&lt;/strong&gt; record you created on the domain must point to the static IP address.&lt;/p&gt;
&lt;p&gt;If either of these aren&amp;rsquo;t set correctly, you may see a &lt;code&gt;Status: FailedNotVisible&lt;/code&gt; status when you issue the &lt;code&gt;kubectl describe managedcertificate&lt;/code&gt; command below, and the Ingress creation will fail.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;We can request a managed SSL certificate using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl apply -f cert.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where the content of the &lt;code&gt;cert.yaml&lt;/code&gt; file is&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.gke.io/v1beta1
kind: ManagedCertificate
metadata:
  name: allocations-app-v1-cert
spec:
  domains:
    - demo.timpsongray.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;check-the-status-of-the-ssl-certificate&#34;&gt;Check the status of the SSL certificate&lt;/h3&gt;
&lt;p&gt;We can check the status of the SSL provisioning process using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcloud compute ssl-certificates list --global
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will show something like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME                TYPE     CREATION_TIMESTAMP             EXPIRE_TIME  MANAGED_STATUS
mcrt-5fc3491d-8eb3  MANAGED  2020-05-28T06:38:28.757-07:00               PROVISIONING
demo.timpsongray.com: PROVISIONING
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;indicating that provisioning has started, and that the URL is as expected.&lt;/p&gt;
&lt;h2 id=&#34;create-an-ingress-front-end-service&#34;&gt;Create an Ingress Front-End Service&lt;/h2&gt;
&lt;p&gt;In order to connect the outside world with the back-end service we will create load-balanced Ingress service using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl apply -f ingress.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where the content of the &lt;code&gt;ingress.yaml&lt;/code&gt; file is&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: allocations-app-v1-web
  annotations:
    kubernetes.io/ingress.global-static-ip-name: &amp;quot;allocations-app-v1-addr&amp;quot;
    kubernetes.io/ingress.allow-http: &amp;quot;false&amp;quot;
    networking.gke.io/managed-certificates: &amp;quot;allocations-app-v1-cert&amp;quot;
  labels:
    app: allocations-app-v1
spec:
  backend:
    serviceName: allocations-app-v1-svc
    servicePort: 8081
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although the kubectl command returns quickly it can take a few minutes for the ingress to be provisioned, deployed and stabilized. You can check its status using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl describe ingress allocations-app-v1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the provisioning is completed, you should be able to navigate to &lt;code&gt;https://demo.timpsongray.com&lt;/code&gt; and view your application.&lt;/p&gt;
&lt;h3 id=&#34;viewing-logs&#34;&gt;Viewing Logs&lt;/h3&gt;
&lt;p&gt;Kubernetes allows you to inspect the logs of the Clojure application if you specify the pod in which it&amp;rsquo;s running. In order to discover the pod name you can issue the following command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl get pods
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will return something like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME                                     READY   STATUS    RESTARTS   AGE
allocations-app-v1-web-5d966f5d8-v2wgn   1/1     Running   0          32m
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can then issue the following command (substituting the correct pod name) to view the application logs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl logs allocations-app-v1-web-5d966f5d8-v2wgn
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;closure&#34;&gt;Closure&lt;/h1&gt;
&lt;p&gt;Deploying a web application to Kubernetes and exposing it on the web with a specific URL isn&amp;rsquo;t particularly difficult, but there are a number of places where things can go pear-shaped. Hopefully, this will help when you try to do the same thing.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploy a Clojure Pedestal API Server &amp; React/ClojureScript Web Application to Docker</title>
      <link>https://heykieran.github.io/post/deploy-pedestal-react-to-docker/</link>
      <pubDate>Thu, 07 May 2020 12:10:26 -0400</pubDate>
      <guid>https://heykieran.github.io/post/deploy-pedestal-react-to-docker/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In this post I&amp;rsquo;ll show how to build and deploy to docker a fully-functioning application comprising a secure Pedestal API web-server and a React front-end application written in ClojureScript which accesses the server.&lt;/p&gt;
&lt;p&gt;For this example I&amp;rsquo;ll be using the Pedestal/React application I previously discussed in this 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-and-google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt; (with its code 
&lt;a href=&#34;https://github.com/heykieran/clj-pedestal-spa/tree/v1.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; for &lt;strong&gt;tag v1.0&lt;/strong&gt;), and the code discussed in this post is available 
&lt;a href=&#34;https://github.com/heykieran/clj-docker-deploy-ext&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;outline-of-the-steps&#34;&gt;Outline of the Steps&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ll set up a working directory for the build, clone the target application into a sub-directory, compile the target, package it and its dependencies to java byte code, assemble them into a jar, create a docker image for the application, and deploy it as a docker service.&lt;/p&gt;
&lt;h3 id=&#34;background-challenges--tools&#34;&gt;Background, Challenges &amp;amp; Tools&lt;/h3&gt;
&lt;p&gt;During this exercise, I&amp;rsquo;ll try to keep separate the application I&amp;rsquo;m building from the application doing the building. This isn&amp;rsquo;t strictly necessary but it will help illustrate a procedure generally applicable to any Clojure application.&lt;/p&gt;
&lt;p&gt;One of the challenges of this approach is that I&amp;rsquo;ll need to deal with two &lt;code&gt;deps.edn&lt;/code&gt; files - one for the build environment and one for the application being built. Each &lt;code&gt;deps&lt;/code&gt; file contains relative paths (&lt;code&gt;:paths&lt;/code&gt; and &lt;code&gt;:extra-paths&lt;/code&gt;) relative to the root of the project directory to which it belongs.&lt;/p&gt;
&lt;p&gt;If I am to avoid changing in any way the &lt;code&gt;deps&lt;/code&gt; file for the project being built and yet still ensure that the built artifacts end up in the correct location within the build project&amp;rsquo;s directory structure I will need a way to inform the compiler about which paths to use, but relative to the &lt;strong&gt;build&lt;/strong&gt; project&amp;rsquo;s directory and not as specified in the &lt;strong&gt;target&amp;rsquo;s&lt;/strong&gt; &lt;code&gt;deps.edn&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;As an example, let&amp;rsquo;s suppose that the build project is at &lt;code&gt;./clj-deploy-docker&lt;/code&gt; and the project being built will be cloned into &lt;code&gt;./clj-deploy-docker/target-app&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;deps.edn&lt;/code&gt; file in &lt;code&gt;./clj-deploy-docker/target-app&lt;/code&gt; will contain an entry for the alias &lt;code&gt;:main&lt;/code&gt; as below&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-edn&#34;&gt;:aliases
 {:main
  {:paths [&amp;quot;src&amp;quot;]
   :extra-deps {ch.qos.logback/logback-classic {:mvn/version &amp;quot;1.2.3&amp;quot;}
                org.clojure/tools.logging {:mvn/version &amp;quot;0.4.1&amp;quot;}
                ring/ring-core {:mvn/version &amp;quot;1.8.0&amp;quot;}
                ring/ring-jetty-adapter {:mvn/version &amp;quot;1.8.0&amp;quot;}
                ring/ring-devel {:mvn/version &amp;quot;1.8.0&amp;quot;}
                io.pedestal/pedestal.service {:mvn/version &amp;quot;0.5.7&amp;quot;}
                io.pedestal/pedestal.route {:mvn/version &amp;quot;0.5.7&amp;quot;}
                io.pedestal/pedestal.jetty {:mvn/version &amp;quot;0.5.7&amp;quot;}
                buddy {:mvn/version &amp;quot;2.0.0&amp;quot;}
                hiccup {:mvn/version &amp;quot;1.0.5&amp;quot;}
                org.conscrypt/conscrypt-openjdk-uber {:mvn/version &amp;quot;2.2.1&amp;quot;}
                org.eclipse.jetty/jetty-alpn-conscrypt-server {:mvn/version &amp;quot;9.4.24.v20191120&amp;quot;}
                com.google.api-client/google-api-client {:mvn/version &amp;quot;1.30.6&amp;quot;}
                com.walmartlabs/dyn-edn 
                {:git/url &amp;quot;https://github.com/walmartlabs/dyn-edn.git&amp;quot; 
                 :sha &amp;quot;855a775959cf1bec531a303a323e6f05f7b260fb&amp;quot;}}
   :extra-paths [&amp;quot;resources&amp;quot; &amp;quot;common-src&amp;quot; ]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to access and use this alias correctly from the build project&amp;rsquo;s directory (&lt;code&gt;clj-deploy-docker&lt;/code&gt;) I will need to adjust (&lt;em&gt;in some way&lt;/em&gt;) the paths so that the compiler is operating with the correct class path i.e. the class path of the target rather than the class path of the build. Therefore, I&amp;rsquo;ll need to let the compiler know (&lt;em&gt;in some way&lt;/em&gt;) that the &lt;code&gt;:paths&lt;/code&gt; and &lt;code&gt;:extra-paths&lt;/code&gt; vectors should read&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:paths [&amp;quot;target-app/src&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:extra-paths [&amp;quot;target-app/resources&amp;quot; &amp;quot;target-app/common-src&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;respectively.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;On the other hand, the maven coordinates in the target&amp;rsquo;s &lt;code&gt;deps.edn&lt;/code&gt; file are correct, so we can leave the &lt;code&gt;:deps&lt;/code&gt; and &lt;code&gt;:extra-deps&lt;/code&gt; values as they are found.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As for the &lt;em&gt;&amp;ldquo;in some way&amp;rdquo;&lt;/em&gt;, I will be using the 
&lt;a href=&#34;https://github.com/EwenG/badigeon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Badigeon&lt;/a&gt; library to achieve this. Many of Badigeon&amp;rsquo;s API&amp;rsquo;s take a &lt;code&gt;:deps-map&lt;/code&gt; as input. This is an &lt;em&gt;in-memory&lt;/em&gt; map whose structure is the same as a &lt;code&gt;deps.edn&lt;/code&gt; file. This will allow me to read the &lt;code&gt;deps&lt;/code&gt; file, make in-memory adjustments and feed it to to API to do the &lt;em&gt;bundling&lt;/em&gt; and &lt;em&gt;compiling&lt;/em&gt; with a classpath relative to any directory I choose (i.e. relative to &lt;code&gt;./clj-deploy-docker&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&#34;create-a-working-directory-for-the-project&#34;&gt;Create a Working Directory for the Project&lt;/h3&gt;
&lt;p&gt;Create a working directory for the project, and &lt;code&gt;cd&lt;/code&gt; into it&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir clj-deploy-docker
$ cd clj-deploy-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;setting-up-the-application-to-be-built&#34;&gt;Setting up the Application to be built&lt;/h3&gt;
&lt;p&gt;Now, I&amp;rsquo;ll clone the repository of the application I want to build into a directory &lt;code&gt;target-app&lt;/code&gt; under my working directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/heykieran/clj-pedestal-google.git target-app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As mentioned above, for this exercise I will be using a library called 
&lt;a href=&#34;https://github.com/EwenG/badigeon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Badigeon&lt;/a&gt; to organize and compile the sources. It leverages many of the tools &amp;amp; libraries already available in &lt;code&gt;clojure.core&lt;/code&gt; and &lt;code&gt;tools.deps&lt;/code&gt;; it&amp;rsquo;s very flexible and I find the API intuitive.&lt;/p&gt;
&lt;h3 id=&#34;creating-the-build-runner&#34;&gt;Creating the build runner&lt;/h3&gt;
&lt;p&gt;In my project&amp;rsquo;s working directory I create a &lt;code&gt;deps.edn&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ touch deps.edn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and add the Badigeon dependency to the &lt;code&gt;deps.edn&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-edn&#34;&gt;{:deps 
  {}
  :aliases
  {:build
  {:extra-paths [&amp;quot;build&amp;quot;]
   :extra-deps
   {badigeon/badigeon
    {:git/url &amp;quot;https://github.com/EwenG/badigeon.git&amp;quot;
     :sha &amp;quot;1edf7ae465db870ec0066f28226edb9b04873b70&amp;quot;
     :tag &amp;quot;0.0.11&amp;quot;}}}}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Apart from the Clojure system and user dependencies this is the only dependency I&amp;rsquo;ll need in that file.&lt;/p&gt;
&lt;p&gt;Also, for later use, I create a directory called &lt;code&gt;build&lt;/code&gt; to contain the Clojure files to run the bundling, compilation and assembling processes.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir build
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;building-the-front-end-js-file&#34;&gt;Building the Front-End JS File&lt;/h3&gt;
&lt;p&gt;As outlined in my previous 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-and-google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt;, the following command will build the front-end production application&amp;rsquo;s &lt;code&gt;js&lt;/code&gt; file from the ClojureScript sources for the application being &lt;em&gt;dockerized&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd target-app
$ clj -A:prod
$ cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will build the application&amp;rsquo;s front-end only and place the production &lt;code&gt;js&lt;/code&gt; file (&lt;code&gt;prod-main.js&lt;/code&gt;) in the &lt;code&gt;target-app/target/public/cljs-out&lt;/code&gt; directory. This is the &lt;strong&gt;only&lt;/strong&gt; change that will be made to the directories and files under &lt;code&gt;target-app&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At a later stage I will move this file to its correct location under my project directory (&lt;code&gt;./clj-deploy-docker&lt;/code&gt;) so that it can be included in the docker image.&lt;/p&gt;
&lt;h3 id=&#34;building-the-back-end-jvm-class-files&#34;&gt;Building the Back-End (JVM) Class Files&lt;/h3&gt;
&lt;p&gt;I&amp;rsquo;ll now &lt;code&gt;cd&lt;/code&gt; into the &lt;code&gt;build&lt;/code&gt; directory I created previously and create a &lt;code&gt;package.clj&lt;/code&gt; file. This file will contain the &lt;code&gt;-main&lt;/code&gt; method that ultimately performs the bundling, compilation and consolidation of the back-end Clojure files i.e. the JVM class files.&lt;/p&gt;
&lt;h4 id=&#34;some-background-on-bundling-compilation-and-consolidation-_jaring_&#34;&gt;Some Background on Bundling, Compilation and Consolidation (&lt;em&gt;&lt;strong&gt;Jar&lt;/strong&gt;&amp;lsquo;ing&lt;/em&gt;)&lt;/h4&gt;
&lt;p&gt;There are three distinct phases to assembling the JVM artifacts to include in the docker image and I will be using the Badigeon API to perform all three phases.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h5 id=&#34;bundling&#34;&gt;Bundling&lt;/h5&gt;
&lt;p&gt;The &lt;em&gt;bundling&lt;/em&gt; step creates a &amp;ldquo;bundle&amp;rdquo; at a specified file-system location of all the target project&amp;rsquo;s resources and dependencies, including any &lt;code&gt;jar&lt;/code&gt; files that are needed. Note that because the Badigeon bundler does not merge in the system and user &lt;code&gt;deps&lt;/code&gt; preferences, it will not automatically copy sources that are in &lt;code&gt;src&lt;/code&gt; directory of your project, &lt;strong&gt;unless&lt;/strong&gt; that directory is explicitly specified in the &lt;code&gt;:paths&lt;/code&gt; or &lt;code&gt;:extra-paths&lt;/code&gt; entries in the &lt;code&gt;deps.edn&lt;/code&gt; file. During the bundling phase all the &lt;code&gt;jar&lt;/code&gt; files required by your application, and all other resources on the classpath such as static html file, css files, user authored js files etc. will be copied to the specified target directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;compilation&#34;&gt;Compilation&lt;/h5&gt;
&lt;p&gt;During the &lt;em&gt;compilation&lt;/em&gt; step the compiled versions of your Clojure source files (as &lt;code&gt;.class&lt;/code&gt; files) are generated and copied to a specified target directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;consolidation&#34;&gt;Consolidation&lt;/h5&gt;
&lt;p&gt;The final phase involves creating a &lt;code&gt;jar&lt;/code&gt; file containing all the &lt;code&gt;.class&lt;/code&gt; files needed by the application with an appropriate manifest file (&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;) which has an entry indicating the application&amp;rsquo;s entry-point (a &lt;code&gt;Main-Class&lt;/code&gt; entry), and an entry specifying the libraries to be used by the &lt;code&gt;jar&lt;/code&gt; file (a &lt;code&gt;Class-Path&lt;/code&gt; entry).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dependencies (found by Badigeon using the &lt;code&gt;:deps&lt;/code&gt; and &lt;code&gt;:extra-deps&lt;/code&gt; coordinates) will &lt;strong&gt;not&lt;/strong&gt; be incorporated into this &lt;code&gt;jar&lt;/code&gt; file. They will however be added to a &lt;code&gt;./lib&lt;/code&gt; directory as individual &lt;code&gt;jar&lt;/code&gt; files and referenced by the &lt;code&gt;Class-Path&lt;/code&gt; entry in the jar&amp;rsquo;s manifest file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Once these three phases are complete, &lt;strong&gt;and&lt;/strong&gt; the js file containing the front-end application is placed in its correct location, the application can be run using the &lt;code&gt;java&lt;/code&gt; command line tool.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ll come to that presently, but first I&amp;rsquo;d like to take a slightly deeper look at the &lt;em&gt;bundling&lt;/em&gt;, &lt;em&gt;compilation&lt;/em&gt; and &lt;em&gt;consolidation&lt;/em&gt; phases. The full details are available in the &lt;code&gt;package.clj&lt;/code&gt; file from which the following code snippets have been extracted.&lt;/p&gt;
&lt;h4 id=&#34;notes-on-the-code-performing-the-three-steps&#34;&gt;Notes on the code performing the three steps&lt;/h4&gt;
&lt;p&gt;First, I &lt;strong&gt;bundle&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(bundle
     out-path
     {:deps-map translated-deps-map
      :aliases aliases
      :libs-path &amp;quot;lib&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given a &lt;code&gt;deps-map&lt;/code&gt; and a vector of aliases (&lt;code&gt;[:main]&lt;/code&gt;) this function will copy the projects&amp;rsquo;s resources needed to &lt;code&gt;out-path&lt;/code&gt;, and also copy the &lt;code&gt;jar&lt;/code&gt; files required to &lt;code&gt;out-path/lib&lt;/code&gt;. Because the code I want to bundle is in the &lt;code&gt;target-app&lt;/code&gt; directory, I&amp;rsquo;ll read the &lt;code&gt;deps.edn&lt;/code&gt; file from its location under &lt;code&gt;target-app&lt;/code&gt; and update the &lt;code&gt;:path&lt;/code&gt; and &lt;code&gt;:extra-paths&lt;/code&gt; entries so that they are now relative to the current working directory rather than &lt;code&gt;target-app&lt;/code&gt; (see 
&lt;a href=&#34;#background-challenges--tools&#34;&gt;above&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Now the &lt;strong&gt;compilation&lt;/strong&gt; phase runs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(compile/compile
     &#39;main.core
     {:compile-path
      classes-path
      :classpath
      (translate-path-to-absolute
       target-dir
       deps-map
       aliases)})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This compiles the &lt;code&gt;main.core&lt;/code&gt; namespace, putting the &lt;code&gt;.class&lt;/code&gt; files into the directory specified by the &lt;code&gt;classes-path&lt;/code&gt; directory, using a classpath specified by the value of the &lt;code&gt;:classpath&lt;/code&gt; entry. In my case, this is generated by reading the &lt;code&gt;target-app/deps.edn&lt;/code&gt; file into &lt;code&gt;deps-map&lt;/code&gt; and converting the relative components of &lt;code&gt;:paths&lt;/code&gt; and &lt;code&gt;:extra-paths&lt;/code&gt; vectors to absolute file-system locations.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;strong&gt;consolidation&lt;/strong&gt; phase runs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(spit manifest-path
          (jar/make-manifest
           &#39;main.core
           {:Class-Path
            (str
             &amp;quot;. &amp;quot;
             (str/join
              &amp;quot; &amp;quot;
              (mapv
               #(str &amp;quot;lib/&amp;quot; (.getName %))
               (.listFiles (io/file &amp;quot;target/app/lib&amp;quot;)))))}))
    
    (zip/zip
     classes-path
     (str (make-path out-path &amp;quot;app-runner&amp;quot;) &amp;quot;.jar&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This achieves two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;It creates a manifest file in &lt;code&gt;target/app/classes/META-INF&lt;/code&gt;, setting &lt;code&gt;main.core&lt;/code&gt; as the entry point, and adds entries for all the &lt;code&gt;jar&lt;/code&gt; files in the &lt;code&gt;target/lib&lt;/code&gt; directory (which was created and populated during &lt;em&gt;bundling&lt;/em&gt;) into the manifest file&amp;rsquo;s &lt;code&gt;Class-Path&lt;/code&gt; header field. In order for the application to run there is an assumption that the final &lt;code&gt;jar&lt;/code&gt; file and the &lt;code&gt;lib&lt;/code&gt; directory will exist at the same level in the file system i.e. in the same directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It creates a &lt;code&gt;app-runner.jar&lt;/code&gt; file from the contents of the &lt;code&gt;target/app/classes&lt;/code&gt; directory. This &lt;code&gt;jar&lt;/code&gt; file &lt;strong&gt;is&lt;/strong&gt; the main application and will contain the manifest file just created with its &lt;code&gt;Class-Path&lt;/code&gt; entry pointing to the non-application &lt;code&gt;jar&lt;/code&gt; files it needs to run - i.e. those found in the &lt;code&gt;lib&lt;/code&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In order to run all three steps, I can &amp;ldquo;execute&amp;rdquo; the &lt;code&gt;package&lt;/code&gt; namespace passing the &lt;code&gt;target-app&lt;/code&gt; directory name as an argument.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ clj -A:build -m package &amp;quot;target-app&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This completes the Bundling, Compilation and Consolidation steps, and when it finishes I will have a directory structure, which with the addition of the front-end &lt;code&gt;js&lt;/code&gt; file (which I compiled above) will constitute the complete application.&lt;/p&gt;
&lt;p&gt;The result is a &lt;code&gt;target&lt;/code&gt; folder containing an &lt;code&gt;app-runner.jar&lt;/code&gt; file and any other supporting files needed to run the app. Many are extraneous; for instance all the classes files, now included in the &lt;code&gt;jar&lt;/code&gt; file are also under this directory, as are the source code of the Clojure files.&lt;/p&gt;
&lt;p&gt;I can copy the &lt;code&gt;js&lt;/code&gt; file to its correct location using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir -p target/app/public/cljs-out &amp;amp;&amp;amp; \ 
  cp target-app/target/public/cljs-out/prod-main.js &amp;quot;$_&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, everything I need (and some I don&amp;rsquo;t) is available in the &lt;code&gt;./target/app/&lt;/code&gt; directory.&lt;/p&gt;
&lt;h4 id=&#34;running-the-application&#34;&gt;Running the Application&lt;/h4&gt;
&lt;p&gt;Before running the compiled application I need to ensure that certain environment variables are defined and set correctly.&lt;/p&gt;
&lt;p&gt;As discussed in my 
&lt;a href=&#34;https://heykieran.github.io/post/pedestal-and-google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;previous post&lt;/a&gt;, the application requires a number of environment variables to be set in order to configure itself correctly.&lt;/p&gt;
&lt;p&gt;These are&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# the https port number used by the Pedestal API server
ALLOC_SSL_PORT=8081 
# the password of Jetty&#39;s keystore 
ALLOC_KEYSTORE_PASSWORD=&amp;lt;password&amp;gt; 
# the http port number used by the Pedestal API server
ALLOC_PORT=8080 
# the file system location of the Jetty&#39;s keystore (as an absolute file path)
ALLOC_KEYSTORE_LOCATION=&amp;lt;location&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can &lt;code&gt;cd&lt;/code&gt; into the built artifact&amp;rsquo;s directory (&lt;code&gt;./target/app&lt;/code&gt;) and run the backend application directly from the &lt;code&gt;jar&lt;/code&gt; file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd target/app
$ java -jar app-runner.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or, because the classes still exist in a &lt;code&gt;classes&lt;/code&gt; directory under the &lt;code&gt;app&lt;/code&gt; directory&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd target/app
$ java -cp .:classes:lib/* main.core
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The app will start, and when it&amp;rsquo;s fully initialized, I can navigate to 
&lt;a href=&#34;https://localhost:8081/r/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;https://localhost:8081/r/home&lt;/code&gt;&lt;/a&gt; to see it in action.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is also a lot of unnecessary &amp;ldquo;residue&amp;rdquo; in the &lt;code&gt;./target/app&lt;/code&gt; directory, created during &lt;em&gt;bundling&lt;/em&gt;, including directories containing clj and cljc files that are not actually needed to run the application (they will already have been compiled into the &lt;code&gt;classes&lt;/code&gt; directory).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When I process the files for deployment to docker, these will be removed.&lt;/p&gt;
&lt;p&gt;There remains then only the task of creating the docker image itself, which is outlined below.&lt;/p&gt;
&lt;h2 id=&#34;quick-review&#34;&gt;Quick Review&lt;/h2&gt;
&lt;p&gt;Currently, we have in the &lt;code&gt;target/app&lt;/code&gt; all the artifacts (with some extras) to run the application. Now we will rationalize those artifacts, removing all the unnecessary ones, leaving only those that are necessary for running our application and package what remains into a docker image, which we&amp;rsquo;ll place in the folder &lt;code&gt;docker/deploy&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;create-the-docker-image&#34;&gt;Create the Docker Image&lt;/h2&gt;
&lt;p&gt;The docker image I will use is very simple - a basic Debian stretch image with a Java8 SDK.&lt;/p&gt;
&lt;p&gt;In my project directory I create a directory called &lt;code&gt;docker&lt;/code&gt; and &lt;code&gt;cd&lt;/code&gt; into it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir docker
$ cd docker 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and create a &lt;code&gt;Dockerfile&lt;/code&gt; containing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM openjdk:8-stretch

COPY entrypoint.sh /sbin/entrypoint.sh
RUN chmod 755 /sbin/entrypoint.sh

EXPOSE 8081/tcp

COPY deploy /image

WORKDIR /image/app

ENV ALLOC_KEYSTORE_LOCATION=/image/local/jetty-keystore \
    ALLOC_KEYSTORE_PASSWORD=password \
    ALLOC_PORT=8080 \
    ALLOC_SSL_PORT=8081 

ENTRYPOINT [&amp;quot;/sbin/entrypoint.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Dockerfile&lt;/code&gt; as defined will&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create an image from a base &lt;code&gt;openjdk:8-stretch&lt;/code&gt; image,&lt;/li&gt;
&lt;li&gt;copy the file &lt;code&gt;entrypoint.sh&lt;/code&gt; (which I haven&amp;rsquo;t created yet) from the &lt;code&gt;docker/deploy&lt;/code&gt; folder to the image&amp;rsquo;s &lt;code&gt;/sbin&lt;/code&gt; directory and set its mode to executable,&lt;/li&gt;
&lt;li&gt;enable network connectivity to port &lt;code&gt;8081&lt;/code&gt; only (there will be &lt;em&gt;no&lt;/em&gt; access to the unprotected &lt;code&gt;http&lt;/code&gt; port 8080),&lt;/li&gt;
&lt;li&gt;copy the entire contents of the &lt;code&gt;docker/deploy&lt;/code&gt; directory to the image&amp;rsquo;s &lt;code&gt;/image&lt;/code&gt; directory,&lt;/li&gt;
&lt;li&gt;set the image&amp;rsquo;s working directory to &lt;code&gt;/image/app&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;set the needed environment variables for the new image, and&lt;/li&gt;
&lt;li&gt;specify that the &lt;code&gt;/sbin/entrypoint.sh&lt;/code&gt; script should be run when the container starts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;deploy&lt;/code&gt; directory under the &lt;code&gt;docker&lt;/code&gt; directory is the location where the application&amp;rsquo;s artifact will be assembled before their inclusion in the image when the &lt;code&gt;COPY deploy /image&lt;/code&gt; command is run.&lt;/p&gt;
&lt;p&gt;From my project&amp;rsquo;s folder (&lt;code&gt;clj-deploy-docker&lt;/code&gt;) I run the following command to copy the entire app (including residue) to the &lt;code&gt;docker/deploy&lt;/code&gt; folder (creating it if it doesn&amp;rsquo;t exist).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir -p docker/deploy/app &amp;amp;&amp;amp; cp -r target/app/* &amp;quot;$_&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, in order to remove the extraneous files I can run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ 	find docker/deploy/app -maxdepth 1 -mindepth 1 -type d \( ! \( -name &#39;lib&#39; -o -name &#39;public&#39; \) \) -exec rm -rf {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This deletes any sub-directory in the &lt;code&gt;docker/deploy&lt;/code&gt; folder &lt;strong&gt;not&lt;/strong&gt; named &lt;code&gt;lib&lt;/code&gt; (which contain the &lt;code&gt;jar&lt;/code&gt; files the application needs) or &lt;code&gt;public&lt;/code&gt; (which contains all the non-JVM resources the application needs).&lt;/p&gt;
&lt;p&gt;I now add the &lt;code&gt;entrypoint.sh&lt;/code&gt; file to the &lt;code&gt;docker&lt;/code&gt; folder. This script, which is run when the image is started, simply calls the application&amp;rsquo;s entry-point.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;#!/bin/bash
# exit immediately if error
set -e

java -jar app-runner.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, I need to ensure that the keystore used to encrypt the application&amp;rsquo;s &lt;code&gt;https&lt;/code&gt; communication is available for the image build process, so I copy it from my local file system&amp;rsquo;s location to the &lt;code&gt;/docker/deploy/local&lt;/code&gt; directory, from whence, during the image building process, it will be copied to the image&amp;rsquo;s &lt;code&gt;/image/local&lt;/code&gt; folder.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mkdir -p docker/deploy/local &amp;amp;&amp;amp; cp &amp;lt;location-of-keystore&amp;gt; &amp;quot;$_&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, with everything cleaned-up and with the script and the keystore in place, I can create the application&amp;rsquo;s docker image, tagging it with the label &lt;code&gt;testapp:dev&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker build -t testapp:dev docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then run a container based on that image using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run --rm --name test 
    --env ALLOC_KEYSTORE_PASSWORD=&amp;lt;the-real-keystore-password&amp;gt; 
    -p:8081:8081 
    -it testapp:dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can then open my browser to 
&lt;a href=&#34;https://localhost:8081/r/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;https://localhost:8081/r/home&lt;/code&gt;&lt;/a&gt; in order to confirm it&amp;rsquo;s running correctly.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;
When I created the image I did not include the correct password for the keystore in the Dockerfile. Therefore, in order for the application to work correctly I&amp;rsquo;m required to pass the correct value by setting the env variable &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt; when I start the container. It will be used in lieu of the value embedded in the image.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;docker-secrets&#34;&gt;Docker Secrets&lt;/h2&gt;
&lt;p&gt;Passing sensitive information using environment variables is satisfactory in many situations, but there is available a better approach: &lt;strong&gt;docker secrets&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;
Docker secrets are &lt;strong&gt;not&lt;/strong&gt; available in stand-alone mode, the feature is only available in &lt;strong&gt;swarm&lt;/strong&gt; mode.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;passing-configuration-values&#34;&gt;Passing Configuration Values&lt;/h3&gt;
&lt;p&gt;For further details on the subject of passing configurations to a Clojure application you can refer to my 
&lt;a href=&#34;https://heykieran.github.io/post/clojure-configuration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blog post&lt;/a&gt; on the subject. The post also discusses more fully the mechanics of how the configuration is used by the application&amp;rsquo;s code.&lt;/p&gt;
&lt;h3 id=&#34;create-a-swarm&#34;&gt;Create a swarm&lt;/h3&gt;
&lt;p&gt;To create a local swarm for testing I can issue the following command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker swarm init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the swarm has been initialized I can add a secret to the registry. Let&amp;rsquo;s suppose I want to protect the &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt; and avoid having to pass it to the image as an environment variable. I can simply create a docker secret to hold the value, protecting it from being stolen too easily. The following command will create a secret called &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt;, set its value to &lt;code&gt;MYKEYSTOREPASSWORD&lt;/code&gt; and store it in the swarm&amp;rsquo;s registry.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ printf &amp;quot;MYKEYSTOREPASSWORD&amp;quot; | docker secret create ALLOC_KEYSTORE_PASSWORD -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can test that the secret was successfully created by issuing&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker secret ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to use the secret, the container has to be started as a service within the swarm, and on the command line must be specified to what secrets the service has access. In order to start the container with access to the &lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt; and linking swarm&amp;rsquo;s network to the host&amp;rsquo;s network I can issue the following command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service create --replicas 1 \
    --secret ALLOC_KEYSTORE_PASSWORD \ 
    --name testapp \
    --publish mode=host,published=8081,target=8081 \
    testapp:dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will start the service (named &lt;code&gt;testapp&lt;/code&gt;) within the swarm, and the service will start serving the application similarly to when I used the &lt;code&gt;docker run&lt;/code&gt; command above.&lt;/p&gt;
&lt;p&gt;Once started the following command will return basic information about the service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this information should look something like the following&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
kjzh1uc2ttng        testapp             replicated          1/1                 testapp:dev         
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If I want to monitor the activity of the service I should monitor the &lt;strong&gt;logs&lt;/strong&gt; of its associated container and, in order to do this I need to know the container&amp;rsquo;s ID.&lt;/p&gt;
&lt;p&gt;I can issue the following command and note the value in the &lt;code&gt;CONTAINER_ID&lt;/code&gt; column for the image &lt;code&gt;testapp:dev&lt;/code&gt; and use it to interrogate the logs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker container ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will return something like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS                    NAMES
d5b269d508b4        testapp:dev         &amp;quot;/sbin/entrypoint.sh&amp;quot;   15 seconds ago      Up 14 seconds       0.0.0.0:8081-&amp;gt;8081/tcp   testapp.1.tb4n70oe1t8tz3qdzo2aawmek
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And I can view the logs of the running container using as much of the container&amp;rsquo;s ID as necessary to make it unique&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker logs d5b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This allows me to confirm that the application started correctly and is responding to requests.&lt;/p&gt;
&lt;p&gt;As before, I can point my browser at 
&lt;a href=&#34;https://localhost:8081/r/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;https://localhost:8081/r/home&lt;/code&gt;&lt;/a&gt; and exercise the packaged application running as a docker service.&lt;/p&gt;
&lt;p&gt;After some activity I can review the history of my interactions (and the server&amp;rsquo;s responses) by once again reviewing the logs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker logs d5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To shutdown the service, I run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service rm testapp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;review&#34;&gt;Review&lt;/h2&gt;
&lt;p&gt;There were quite a number of steps but I hope the detail was illuminative.&lt;/p&gt;
&lt;p&gt;A later post will illustrate how to integrate the build process within the Clojure application directory structure rather than requiring that it be cloned into a separate working directory.&lt;/p&gt;
&lt;p&gt;That post will also show how the build and deployment steps can be automated using a simple Makefile.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Clojure Configurations with Docker Secrets</title>
      <link>https://heykieran.github.io/post/clojure-configuration/</link>
      <pubDate>Thu, 07 May 2020 11:26:15 -0400</pubDate>
      <guid>https://heykieran.github.io/post/clojure-configuration/</guid>
      <description>&lt;h1 id=&#34;passing-a-configuration-to-a-clojure-application&#34;&gt;Passing a &amp;ldquo;Configuration&amp;rdquo; to a Clojure Application&lt;/h1&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;There are many ways to pass configuration values to a Clojure application. This piece will cover four of them:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;#using-command-line-parameters&#34;&gt;Command Line Parameters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#using-environment-variables&#34;&gt;Environment Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#using-dynamic-environment-variables&#34;&gt;Dynamic Environment Variables&lt;/a&gt;, and&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#using-docker-secrets---with-dynamic-environment-variables&#34;&gt;Docker Secrets&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first two are briefly discussed, while greater time is spent on the final two. Of the four, the 
&lt;a href=&#34;#our-example-with-secrets&#34;&gt;last&lt;/a&gt; is particularly useful to keep &lt;strong&gt;secure&lt;/strong&gt; configuration values that &lt;strong&gt;ought&lt;/strong&gt; to be kept so - passwords, private keys etc.&lt;/p&gt;
&lt;h3 id=&#34;using-command-line-parameters&#34;&gt;Using Command Line Parameters&lt;/h3&gt;
&lt;p&gt;If one starts Clojure from the command line using the &lt;code&gt;-m&lt;/code&gt; option specifying a namespace, Clojure will execute the &lt;code&gt;-main&lt;/code&gt; function from that namespace, passing any further arguments on the command line as parameters to &lt;code&gt;-main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, the following Clojure code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Clojure&#34;&gt;(ns main.core)

(defn -main [args]
  (println args))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which can be executed from the command line using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ clj -m main.core &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will result in the string &lt;code&gt;Hello World!&lt;/code&gt; being printed to the console.&lt;/p&gt;
&lt;h3 id=&#34;using-environment-variables&#34;&gt;Using Environment Variables&lt;/h3&gt;
&lt;p&gt;As an alternative to command line parameters, it&amp;rsquo;s often convenient to have your Clojure application read its parameters from the application&amp;rsquo;s execution environment i.e. environment variables or JVM system properties.&lt;/p&gt;
&lt;p&gt;So running&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ export MYARGS=&amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;at the command line, and changing the &lt;code&gt;-main&lt;/code&gt; function to&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Clojure&#34;&gt;(defn -main [&amp;amp; args]
  (println (System/getenv &amp;quot;MYARGS&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you can now run the application using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ clj -m main.core
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and see the same result.&lt;/p&gt;
&lt;p&gt;The value of the &lt;code&gt;MYARGS&lt;/code&gt; environment variable is read from the environment and then printed to the console.&lt;/p&gt;
&lt;p&gt;Unfortunately, as convenient as this is when executing the code, it can be a little inconvenient during development. If this is the only place you use the variable there&amp;rsquo;s little lost, but if the value is used in other areas of your application e.g. in other namespaces, any changes to its name or expected type will lead to an amount of error-prone &amp;ldquo;code surgery&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Also, &lt;code&gt;env&lt;/code&gt; variables are, by their nature, strings; so if you need the value as, for instance, an &lt;code&gt;int&lt;/code&gt; you&amp;rsquo;ll need to perform the casting and error-checking at the time of initialization.&lt;/p&gt;
&lt;h3 id=&#34;using-dynamic-environment-variables&#34;&gt;Using &amp;ldquo;Dynamic&amp;rdquo; Environment Variables&lt;/h3&gt;
&lt;p&gt;WalmartLabs have published a Clojure library on 
&lt;a href=&#34;https://github.com/walmartlabs/dyn-edn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; to address many of these issues. The library centralizes the reading of &lt;code&gt;env&lt;/code&gt; variables, and also allows for existence-checking, the setting of default values, merging with JVM system properties, casting, type-checking, and composition.&lt;/p&gt;
&lt;p&gt;The library makes it possible to define in a simple &lt;code&gt;edn&lt;/code&gt; file the &lt;em&gt;shape&lt;/em&gt; of your configuration data and have it parsed correctly from the environment (and other locations) into the structure you want.&lt;/p&gt;
&lt;p&gt;As an example, if you have a file called &lt;code&gt;config.edn&lt;/code&gt; somewhere on your classpath with&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-edn&#34;&gt;{:app-configuration
 {:myargs #dyn/prop MYARGS}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and change the &lt;code&gt;main/core.clj&lt;/code&gt; file to&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Clojure&#34;&gt;(ns main.core
  (:require
   [clojure.edn :as edn]
   [clojure.java.io :as io]
   [com.walmartlabs.dyn-edn :refer [env-readers]]))

(def app-config
  (-&amp;gt;&amp;gt; &amp;quot;config.edn&amp;quot;
     io/resource
     slurp
     (edn/read-string {:readers (env-readers)})))

(defn -main [&amp;amp; args]
  (println (get-in app-config [:app-configuration :myargs])))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then run the application using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ clj -m main.core
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You&amp;rsquo;ll see the same result - but, the application&amp;rsquo;s configuration has been correctly (and automatically) parsed into a configuration structure and is available as a map named &lt;code&gt;main.core/app-config&lt;/code&gt; that can be used throughout your application.&lt;/p&gt;
&lt;p&gt;The use of the &lt;code&gt;config.edn&lt;/code&gt; file also allows you to view the expected configuration parameters, or add to them, or change their default values in one central location - &lt;strong&gt;very&lt;/strong&gt; convenient.&lt;/p&gt;
&lt;h3 id=&#34;using-docker-secrets---with-dynamic-environment-variables&#34;&gt;Using Docker Secrets - with Dynamic Environment Variables&lt;/h3&gt;
&lt;p&gt;An area where &lt;code&gt;env&lt;/code&gt; variables are extensively used as configuration parameters is when an application is being run inside a docker container. By providing one or more &lt;code&gt;-e&lt;/code&gt; options to the &lt;code&gt;docker run&lt;/code&gt; command, it&amp;rsquo;s possible to establish the configuration environment for the application (if that&amp;rsquo;s where the application expects to find it).&lt;/p&gt;
&lt;p&gt;Unfortunately, certain configuration parameters contain sensitive information, such as passwords or private keys and one can&amp;rsquo;t realistically embed those values in the application&amp;rsquo;s code. They may change frequently; they may need to differ from one container to another; and their very existence in the code represents a risk that they&amp;rsquo;ll &amp;ldquo;leak&amp;rdquo; into an SCM.&lt;/p&gt;
&lt;p&gt;Of course, the use of environment variables is a good alternative to embedded code values, but represents a different, albeit smaller, set of risks. Anyone with access to the docker instance could recover the environment variables passed to a container during initialization.&lt;/p&gt;
&lt;p&gt;In order to address this, Docker introduced the concept of &lt;strong&gt;secrets&lt;/strong&gt; with docker &lt;strong&gt;swarm&lt;/strong&gt;. Secrets allow sensitive information to be defined securely, and then selectively made available to containers which are running as docker services. It is only within the running container that the secret&amp;rsquo;s value is available as contents of files mounted from an &lt;em&gt;in-memory&lt;/em&gt; filesystem, by default at &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt;, where they can be accessed by the application.&lt;/p&gt;
&lt;p&gt;In order to tie together environment variables with secrets, I&amp;rsquo;ve submitted a PR to the maintainer of the &lt;code&gt;walmart-labs/dyn-edn&lt;/code&gt; library which, in addition to &lt;code&gt;env&lt;/code&gt; variables and system properties, &lt;em&gt;merges in&lt;/em&gt; docker secrets to the set of variable available to the library&amp;rsquo;s readers: &lt;code&gt;#dyn/prop&lt;/code&gt;, &lt;code&gt;#dyn/join&lt;/code&gt;, &lt;code&gt;#dyn/long&lt;/code&gt;, &lt;code&gt;#dyn/boolean&lt;/code&gt;, and &lt;code&gt;#dyn/keyword&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;
The PR was accepted by the maintainer, but the library hasn&amp;rsquo;t yet made it to clojars. In order to use the secrets functionality you&amp;rsquo;ll need to add the following to your &lt;code&gt;:deps&lt;/code&gt; entry in &lt;code&gt;deps.edn&lt;/code&gt;. This will pull the appropriate version of the code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;com.walmartlabs/dyn-edn 
  {:git/url &amp;quot;https://github.com/walmartlabs/dyn-edn.git&amp;quot;
   :sha &amp;quot;855a775959cf1bec531a303a323e6f05f7b260fb&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;our-example-with-secrets&#34;&gt;Our Example with Secrets&lt;/h4&gt;
&lt;p&gt;To use a docker secret in lieu of the &lt;code&gt;MYARGS&lt;/code&gt; env variable used in previous examples all one needs to do is create a secret called &lt;code&gt;MYARGS&lt;/code&gt; with the appropriate value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ printf &amp;quot;Hello World!&amp;quot; | docker secret create MYARGS -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and, when starting the container as a docker service, authorize the service to use that secret&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service create --replicas 1 --secret MYARGS --name &amp;lt;svcname&amp;gt; &amp;lt;image containing the app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No change needs to be made to the &lt;code&gt;config.edn&lt;/code&gt; file, or to the source code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pedestal API, ClojureScript SPA and Google Authentication</title>
      <link>https://heykieran.github.io/post/pedestal-and-google/</link>
      <pubDate>Mon, 27 Apr 2020 11:53:08 -0400</pubDate>
      <guid>https://heykieran.github.io/post/pedestal-and-google/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The following are some notes about a 
&lt;a href=&#34;https://github.com/heykieran/clj-pedestal-spa/tree/v1.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repository&lt;/a&gt;
containing working code (extracted from a larger project) demonstrating a
combination of a secured &lt;strong&gt;Pedestal&lt;/strong&gt; website (and associated API services), and
a &lt;strong&gt;React&lt;/strong&gt;-ive ClojureScript front-end application that utilizes either Google
or bespoke login logic to identify and validate the user&amp;rsquo;s credentials, and sets
his/her authorization levels.&lt;/p&gt;
&lt;p&gt;I hope that it may be helpful to anyone else who may know how each of the the
individual pieces work, but is wondering how to put it all together.&lt;/p&gt;
&lt;p&gt;I owe a debt of gratitude to Tristan Straub, as much of the front-end logic (and
code) to utilize Google&amp;rsquo;s login is based on some code he posted on

&lt;a href=&#34;https://github.com/tristanstraub/cljs-google-signin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;. I&amp;rsquo;ve changed the
code in many ways, so any errors are not his but mine.&lt;/p&gt;
&lt;p&gt;The front-end application, which is intentionally simple, allows a user to
login, and according to his/her permissions will allow access to various
resources. The application is written using React/ReFrame, Semantic UI React and
ClojureScript. The application uses Figwheel-main to compile and, in development
mode run the front-end; but switching to a different tool-chain (e.g.
shadow-cljs) should be relatively easy.&lt;/p&gt;
&lt;h1 id=&#34;features&#34;&gt;Features&lt;/h1&gt;
&lt;h3 id=&#34;google-login-integration-and-mapping-to-application-id&#34;&gt;Google Login Integration (and mapping to application id)&lt;/h3&gt;
&lt;p&gt;The application demonstrates how to integrate Google&amp;rsquo;s login
functionality with a ClojureScript application. After successfully
authenticating with Google, the user&amp;rsquo;s Google &lt;em&gt;email&lt;/em&gt; address is
associated with one (and only one) internal application user ID. The
internal user ID is associated internally with one or more application
defined roles, which are defined in the code.&lt;/p&gt;
&lt;p&gt;Conceivably, this &lt;em&gt;mapping&lt;/em&gt; of external ID to internal ID could allow
multiple external authentication services to be used to map multiple
externally asserted identities to a single internal user ID. For
example, by extending the application to use Facebook&amp;rsquo;s authentication
service, it would be possible to have both &lt;code&gt;user@gmail.com&lt;/code&gt; and
&lt;code&gt;user@facebook.com&lt;/code&gt; to be mapped to the same internal user ID, e.g.
&lt;code&gt;:user&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fundamentally, authenticating and logging in merely associates a user
with a web session. The session is the operative object and identities
are not, and cannot be shared between sessions. A user may have multiple
sessions open, but they don&amp;rsquo;t &amp;ldquo;&lt;em&gt;mingle&lt;/em&gt;&amp;quot;.&lt;/p&gt;
&lt;h3 id=&#34;ad-hoc-_affirmative_-login-method&#34;&gt;Ad-hoc &lt;em&gt;affirmative&lt;/em&gt; login method&lt;/h3&gt;
&lt;p&gt;The application as presented allows a user to simply assert that they
are a known user. The only reason this feature is included is to
simplify debugging. In a production application these assertions would
typically be replaced with an application specific logon process.&lt;/p&gt;
&lt;h3 id=&#34;isolation-of-sensitive-information-from-codebase&#34;&gt;Isolation of sensitive information from codebase&lt;/h3&gt;
&lt;p&gt;In order to run Pedestal/Jetty (for production) or Figwheel/Jetty (for
development) with https (required to use Google login) the location of a
keystore and its password must be supplied.&lt;/p&gt;
&lt;p&gt;This is an obvious security concern - including any sensitive information in
either the source-code, or the application&amp;rsquo;s generated js code is poor security
hygiene. The application avoids this by using environment variable (assumed to
be available) to store this information which is read-only at runtime.&lt;/p&gt;
&lt;h3 id=&#34;secured-api-end-points-by-role-membership&#34;&gt;Secured API end-points by role membership&lt;/h3&gt;
&lt;p&gt;The application uses role-based security, where access to resources (URI&amp;rsquo;s) is
permitted or prohibited according to whether a user has membership within a
particular role. A user ID can be associated with one or more roles. Roles are
independent of one another. There is no concept of hierarchy or inheritance
beyond how the code chooses to handle these concepts.&lt;/p&gt;
&lt;p&gt;The application, for our purposes, defines three roles: &lt;code&gt;:admin&lt;/code&gt;,
&lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:public&lt;/code&gt;. An unauthenticated user is associated with the
role &lt;code&gt;:public&lt;/code&gt;. Note that there is nothing privileged about these roles,
or their names. They are completely application defined.&lt;/p&gt;
&lt;p&gt;In the code for the application&amp;rsquo;s configuration file
(&lt;code&gt;common-src/config/config.cljc&lt;/code&gt;) you can see how these have been
defined:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(def roles-and-users
  {:admin {:roles #{:admin} 
           :users #{&amp;quot;admin@timpsongray.com&amp;quot; &amp;quot;heykieran@gmail.com&amp;quot;}}
   :user {:roles #{:user} 
          :users #{&amp;quot;user@timpsongray.com&amp;quot;}}})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we&amp;rsquo;ve defined two users &lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:admin&lt;/code&gt;, along with two
roles, also called &lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:admin&lt;/code&gt;. Users who authenticated with
the email addresses &lt;code&gt;admin@timpsongray.com&lt;/code&gt; and &lt;code&gt;heykieran@gmail.com&lt;/code&gt;
will be associated with the user ID &lt;code&gt;:admin&lt;/code&gt;, and the user with the
email address &lt;code&gt;user@timpsongray.com&lt;/code&gt; will be associated with the user ID
&lt;code&gt;:user&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we examine how routes are defined in the file
&lt;code&gt;server/be_handler_pdstl.clj&lt;/code&gt; we can see how security is applied to
URL&amp;rsquo;s.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(def routes
  (route/expand-routes
    #{[&amp;quot;/echo&amp;quot;  :get echo]
      [&amp;quot;/auth/isauthenticated&amp;quot; :post (build-secured-route-vec-to app-auth/get-current-logged-in-user) :route-name :alloc-public/is-authenticated]
      [&amp;quot;/auth/setid&amp;quot; :post (build-secured-route-vec-to app-auth/alloc-auth-explicitly-set-identity-of-user-post) :route-name :alloc-public/auth-set-id-post]
      [&amp;quot;/auth/google&amp;quot; :post (build-secured-route-vec-to app-auth/alloc-auth-google-login) :route-name :alloc-public/google-login-post]
      [&amp;quot;/auth/logout&amp;quot; :post (build-secured-route-vec-to disconnect-session) :route-name :alloc-user/auth-logout-post]
      [&amp;quot;/api/getsecresource/p&amp;quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :alloc-public/test-res]
      [&amp;quot;/api/getsecresource/u&amp;quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :alloc-user/test-res]
      [&amp;quot;/api/getsecresource/a&amp;quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :test-res]
      [&amp;quot;/r/home&amp;quot; :get [content-neg-intc respond-with-app-page] :route-name :app-main-page]}))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The current implementation uses the namespace of values
of each route&amp;rsquo;s &lt;code&gt;:route-name&lt;/code&gt; key to assign security.&lt;/p&gt;
&lt;p&gt;Any protected URL whose &lt;code&gt;:route-name&lt;/code&gt; namespace is &lt;code&gt;:alloc-public&lt;/code&gt; is
available to any user, authenticated or not.&lt;/p&gt;
&lt;p&gt;Any protected URL whose &lt;code&gt;:route-name&lt;/code&gt; namespace is &lt;code&gt;:alloc-user&lt;/code&gt; is
available to any user associated with the &lt;code&gt;:user&lt;/code&gt; role.&lt;/p&gt;
&lt;p&gt;Any protected URL whose &lt;code&gt;:route-name&lt;/code&gt; namespace is &lt;strong&gt;either&lt;/strong&gt;
&lt;code&gt;:alloc-admin&lt;/code&gt; or the default namespace is available to only users
associated with the &lt;code&gt;:admin&lt;/code&gt; role.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;URL&amp;rsquo;s are only &lt;em&gt;protected&lt;/em&gt; if they use the auth interceptors. These
interceptors are included when the function
&lt;code&gt;build-secured-route-vec-to&lt;/code&gt; is used to wrap the content handler
function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Another item to note is the three test URL&amp;rsquo;s &lt;code&gt;/api/getsecresource/p&lt;/code&gt;
(available to all users), &lt;code&gt;/api/getsecresource/u&lt;/code&gt; (available to users in
the &lt;code&gt;:user&lt;/code&gt; role) and &lt;code&gt;/api/getsecresource/a&lt;/code&gt; (available only to users
in the &lt;code&gt;:admin&lt;/code&gt; role) use the same handler &lt;code&gt;get-secured-resource&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;development-server--production-server&#34;&gt;Development Server &amp;amp; Production Server&lt;/h3&gt;
&lt;p&gt;The application has both a &lt;em&gt;development&lt;/em&gt; mode and a &lt;em&gt;production&lt;/em&gt; mode. Both
modes use Pedestal as the API server, responding to requests as defined
in the &lt;code&gt;routes&lt;/code&gt; parameter used to start the server. The difference
between the two modes is in how the js files are served, and in how
front-end development proceeds, or not.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;development&lt;/em&gt; mode the application&amp;rsquo;s js files are served from a handler
(&lt;code&gt;fe-src/server/fe-handler&lt;/code&gt;) sitting behind figwheel/Jetty, and started
using the script provided in &lt;code&gt;scripts/server.clj&lt;/code&gt;. This facilitates the
&lt;em&gt;standard&lt;/em&gt; figwheel development process of having figwheel monitor a set
of source directories and regenerate and reload any changed files as
necessary. This should be familiar to anyone who&amp;rsquo;s used figwheel-main
for ClojureScript development. An alias has been defined in the
&lt;code&gt;deps.edn&lt;/code&gt; file to start all the various servers and to start figwheel.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;production&lt;/em&gt; mode, the js files are served from the Pedestal/Jetty
server itself. Of course, in order to do this the js files must have
been previously compiled by figwheel. An alias has been defined in the
&lt;code&gt;deps.edn&lt;/code&gt; file for this purpose.&lt;/p&gt;
&lt;h3 id=&#34;log-out-functionality&#34;&gt;Log-out Functionality&lt;/h3&gt;
&lt;p&gt;The application allows the user to disassociate their session from their
identity. Because the session is the operative object, this is
essentially logging out.&lt;/p&gt;
&lt;h3 id=&#34;session-expiration&#34;&gt;Session Expiration&lt;/h3&gt;
&lt;p&gt;When credentials are issued for an authenticated user and associated
with a session, the information will also contain an expiration date. If
a user attempts to access a protected resource and the credentials are
found to have expired, access is denied and the user&amp;rsquo;s credentials are
disassociated from the session. This essentially logs that user out and
he/she will need to reassociate their credentials with the session.&lt;/p&gt;
&lt;h3 id=&#34;reactreagentreframekee-frame-application&#34;&gt;React/Reagent/Reframe/kee-frame Application&lt;/h3&gt;
&lt;p&gt;The test application is a reactive application written in ClojureScript
using reagent, reframe and kee-frame. It illustrates some of the
principles required for a simple application of this type.&lt;/p&gt;
&lt;h3 id=&#34;semantic-ui-integration&#34;&gt;Semantic UI Integration&lt;/h3&gt;
&lt;p&gt;The toolkit used for widgets and styling is 
&lt;a href=&#34;https://react.semantic-ui.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SemanticUI-react&lt;/a&gt;, and the
application illustrates how the library can be used.&lt;/p&gt;
&lt;h1 id=&#34;running-the-servers--applications&#34;&gt;Running the Servers &amp;amp; Applications&lt;/h1&gt;
&lt;h3 id=&#34;setting-up-a-keystore-for-https&#34;&gt;Setting up a keystore for HTTPS&lt;/h3&gt;
&lt;p&gt;In order to run the web servers in secured mode you&amp;rsquo;ll need to create a
keystore for the certificates used by the servers and make it available
to Jetty. Instructions on how to do this can be found

&lt;a href=&#34;https://heykieran.github.io/post/pedestal-jetty-https/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;setting-up-google-login&#34;&gt;Setting up Google Login&lt;/h3&gt;
&lt;p&gt;In order to use the application for yourself you will need to get your
own Google Client ID. Instructions on how to do this can be found

&lt;a href=&#34;https://developers.google.com/identity/sign-in/web/sign-in&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You will also need to use the Google Console to inform Google of the
&lt;strong&gt;Authorized Javascript Origins&lt;/strong&gt; associated with your Client ID. These
should be the names and ports of your https endpoints. For testing,
these will typically be the server name and port of your Pedestal/Jetty
and your figwheel/Jetty (for development mode only) servers.&lt;/p&gt;
&lt;p&gt;The values should also be set in the following places&lt;/p&gt;
&lt;p&gt;In your environment the following variables should be set&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Environment Variable&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ALLOC_KEYSTORE_PASSWORD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The keystore&amp;rsquo;s password&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ALLOC_KEYSTORE_LOCATION&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The keystore&amp;rsquo;s filesystem location&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ALLOC_SSL_PORT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The ssl port number used for Pedestal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ALLOC_PORT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The port number used for Pedestal&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In the &lt;code&gt;common-src/config/config.cljc&lt;/code&gt; you will need to set the following
variables&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Configuration Variable&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;google-client-id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;your Google Client ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;my-hostname&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;your server&amp;rsquo;s name&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;figwheel-ssl-port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;the port used by figwheel&amp;rsquo;s https server and serving the application&amp;rsquo;s js files&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pedestal-port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Pedestal&amp;rsquo;s HTTP port number (should match &lt;code&gt;ALLOC_PORT&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pedestal-ssl-port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Pedestal&amp;rsquo;s HTTPS port number (should match &lt;code&gt;ALLOC_SSL_PORT&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;google-callback-url&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;change the server name in this variable to match your server&amp;rsquo;s name.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In the file &lt;code&gt;dev.cljs.edn&lt;/code&gt; change the &lt;code&gt;:open-url&lt;/code&gt; parameter to match your
server&amp;rsquo;s name, and the ssl port used by figwheel. This should match
&lt;code&gt;https://&amp;lt;my-hostname&amp;gt;:&amp;lt;pedestal-ssl-port&amp;gt;/r/home&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;starting-the-servers&#34;&gt;Starting the Server(s)&lt;/h3&gt;
&lt;h4 id=&#34;development-mode&#34;&gt;Development Mode&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In your IDE of choice, start a REPL (with the alias &lt;code&gt;:main&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Load and execute the &lt;code&gt;control&lt;/code&gt; namespace&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the function &lt;code&gt;(start-dev)&lt;/code&gt; (It&amp;rsquo;s within a &lt;code&gt;comment&lt;/code&gt; expression).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log messages are sent to the REPL output stream, so you can monitor
progress and activity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When the Pedestal server has started, run the following from a command line&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clj -A:dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will start the front-end server used by figwheel on ports 9500 and
&lt;code&gt;figwheel-ssl-port&lt;/code&gt; and will start the figwheel watch process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Your browser should automatically open to
&lt;code&gt;https://&amp;lt;my-hostname&amp;gt;:&amp;lt;figwheel-ssl-port&amp;gt;/r/home&lt;/code&gt; where the application
will be loaded. (You should have set this in &lt;code&gt;dev.cljs.edn&lt;/code&gt; as above).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    When you&amp;rsquo;re finished and wish to stop the front-end server: from the Figwheel console you issue the &lt;code&gt;:cljs/quit&lt;/code&gt; command to stop the Figwheel build process followed by Ctrl+C to stop the front-end server itself.
  &lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;production-mode&#34;&gt;Production Mode&lt;/h4&gt;
&lt;p&gt;Build the production application by running&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clj -A:prod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;from the command line. This will generate the production js files from your ClojureScript sources. Then, from the command line run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clj -A:main:main-output -m control
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will start the Pedestal server which in addition to serving API requests will also serve the js files built in the last step.&lt;/p&gt;
&lt;p&gt;Finally, open your browser and navigate to &lt;code&gt;https://&amp;lt;my-hostname&amp;gt;:8081/r/home&lt;/code&gt; to display the application&amp;rsquo;s Home page.&lt;/p&gt;
&lt;h2 id=&#34;navigating-the-application&#34;&gt;Navigating the Application&lt;/h2&gt;
&lt;h3 id=&#34;the-home-page&#34;&gt;The Home Page&lt;/h3&gt;
&lt;p&gt;When the application first starts, you can go to the Home page&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-initial-view-of-the-home-page-no-logged-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page_huaaba3d4bf3897864ad8c0dbe2950fa00_42345_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The initial view of the home page (&amp;lt;strong&amp;gt;no&amp;lt;/strong&amp;gt; logged-in user).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page_huaaba3d4bf3897864ad8c0dbe2950fa00_42345_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1338&#34; height=&#34;352&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The initial view of the home page (&lt;strong&gt;no&lt;/strong&gt; logged-in user).
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;the-applications-menu&#34;&gt;The Application&amp;rsquo;s Menu&lt;/h3&gt;
&lt;p&gt;The application is a SPA with client-side routing and has only a single menu with 5 menu items.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-main-menu-no-logged-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page-menu-no-logged-in-user_hufd402a6ba5fecc72c633474ae2fa3e3d_57047_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The main menu (&amp;lt;strong&amp;gt;no&amp;lt;/strong&amp;gt; logged-in user).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page-menu-no-logged-in-user_hufd402a6ba5fecc72c633474ae2fa3e3d_57047_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1338&#34; height=&#34;674&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The main menu (&lt;strong&gt;no&lt;/strong&gt; logged-in user).
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;strong&gt;Home&lt;/strong&gt; item will take you to the Home page&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Users&lt;/strong&gt; menu item will display the application&amp;rsquo;s Sign-In/Sign-Out page. Here you can connect an identity to your session (&lt;em&gt;log-in&lt;/em&gt;), or disconnect an identity from your session (&lt;em&gt;log-out&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Public&lt;/strong&gt; menu item will request content from an unsecured API endpoint whose content is available to any user whether authenticated or not.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;User&lt;/strong&gt; menu item will request content from an an API endpoint to which access has been restricted to users with &lt;strong&gt;role&lt;/strong&gt; memberships of &lt;code&gt;:admin&lt;/code&gt; or &lt;code&gt;:user&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Admin&lt;/strong&gt; menu item will request content from an an API endpoint to which access has been restricted to users with &lt;strong&gt;role&lt;/strong&gt; membership of &lt;code&gt;:admin&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-a-public-resource&#34;&gt;Access a Public Resource&lt;/h3&gt;
&lt;p&gt;Even though you have not yet signed in, if you click on the &lt;strong&gt;Public&lt;/strong&gt; menu item the application will respond with some content.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-access-to-public-resource-is-allowed-no-logged-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/access-public-resource_huf6a3c9ebea043d4f5d4e6b23eba4a1b4_41499_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;Access to Public Resource is allowed (&amp;lt;strong&amp;gt;no&amp;lt;/strong&amp;gt; logged-in user).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/access-public-resource_huf6a3c9ebea043d4f5d4e6b23eba4a1b4_41499_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1340&#34; height=&#34;418&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Access to Public Resource is allowed (&lt;strong&gt;no&lt;/strong&gt; logged-in user).
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;This is as expected as that resource is unsecured and available to anyone who can access the application.&lt;/p&gt;
&lt;h3 id=&#34;sign-in-as-the-localuser-user&#34;&gt;Sign-In as the &lt;code&gt;:local/:user&lt;/code&gt; User&lt;/h3&gt;
&lt;p&gt;On the Sign-In Page, click on the button labelled &lt;strong&gt;&lt;a href=&#34;mailto:user@timpsongray.com&#34;&gt;user@timpsongray.com&lt;/a&gt;&lt;/strong&gt;. This will associate you session with the application user &lt;code&gt;:user&lt;/code&gt;, who has been assigned the &lt;code&gt;:user&lt;/code&gt; &lt;strong&gt;role&lt;/strong&gt;. This form of sign-in is a &lt;code&gt;:local&lt;/code&gt; authority sign-in. The authority is granted by the application itself.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-standard-sign-in-page-no-logged-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/sign-in-page_hu08d58e743afadb57a341d72a72bfa387_91827_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The Standard Sign-In Page (&amp;lt;strong&amp;gt;no&amp;lt;/strong&amp;gt; logged-in user).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/sign-in-page_hu08d58e743afadb57a341d72a72bfa387_91827_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1336&#34; height=&#34;868&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Standard Sign-In Page (&lt;strong&gt;no&lt;/strong&gt; logged-in user).
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Once you&amp;rsquo;ve done that you&amp;rsquo;ll be redirected to the &lt;strong&gt;Home&lt;/strong&gt; page where your session and identity details are displayed.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-after-the-user-user-has-signed-in&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-user-signed-in_hu88471979aee3312eae8537ac4b138fbe_46032_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;After the user &amp;lt;code&amp;gt;:user&amp;lt;/code&amp;gt; has signed in.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-user-signed-in_hu88471979aee3312eae8537ac4b138fbe_46032_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1340&#34; height=&#34;372&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    After the user &lt;code&gt;:user&lt;/code&gt; has signed in.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;accessing-a-protected-resource&#34;&gt;Accessing a protected resource&lt;/h3&gt;
&lt;p&gt;Now click on the &lt;strong&gt;User&lt;/strong&gt; menu item. The application will attempt to fetch a resource from an API endpoint restricted to users in the &lt;code&gt;:user&lt;/code&gt; or &lt;code&gt;:admin&lt;/code&gt; roles.&lt;/p&gt;
&lt;p&gt;Because &lt;code&gt;:user&lt;/code&gt; has that role association the contents of the resource is displayed.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-user-user-is-allowed-to-access-to-the-user-resource&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-accesses-user-page-ok_hua77f555305a4e482c429b34566c4f1b6_45163_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The user (&amp;lt;code&amp;gt;:user&amp;lt;/code&amp;gt;) is allowed to access to the &amp;lt;strong&amp;gt;User&amp;lt;/strong&amp;gt; resource.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-accesses-user-page-ok_hua77f555305a4e482c429b34566c4f1b6_45163_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1344&#34; height=&#34;426&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The user (&lt;code&gt;:user&lt;/code&gt;) is allowed to access to the &lt;strong&gt;User&lt;/strong&gt; resource.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;However, if you now click on the &lt;strong&gt;Admin&lt;/strong&gt; menu item, which attempts to fetch
data from an API endpoint restricted to &lt;code&gt;:admin&lt;/code&gt; role members only, you&amp;rsquo;ll see
an access denied message.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-user-user-is-denied-access-to-the-admin-resource&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-accesses-admin-page-denied_hu8fda4bc3b88839b1d49961b5d15e137b_125581_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The user (&amp;lt;code&amp;gt;:user&amp;lt;/code&amp;gt;) is denied access to the &amp;lt;strong&amp;gt;Admin&amp;lt;/strong&amp;gt; resource.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/user-accesses-admin-page-denied_hu8fda4bc3b88839b1d49961b5d15e137b_125581_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1334&#34; height=&#34;592&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The user (&lt;code&gt;:user&lt;/code&gt;) is denied access to the &lt;strong&gt;Admin&lt;/strong&gt; resource.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;sign-out-from-user&#34;&gt;Sign-Out from &lt;code&gt;:user&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Click on the &lt;strong&gt;Users&lt;/strong&gt; menu item to go to the Sign-In/Sign-Out page&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-a-view-of-the-standard-sign-out-page-with-user-user-is-logged-in&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/local-user-sign-out_hu5288488acb08e3af3122c648af377573_121592_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;A view of the standard Sign-Out page with user (&amp;lt;code&amp;gt;:user&amp;lt;/code&amp;gt;) is logged in.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/local-user-sign-out_hu5288488acb08e3af3122c648af377573_121592_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1334&#34; height=&#34;1170&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    A view of the standard Sign-Out page with user (&lt;code&gt;:user&lt;/code&gt;) is logged in.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;and at the bottom click on the button in &lt;strong&gt;Sign-Out (Local)&lt;/strong&gt; section. This will remove the identity information from your session, and return you to the Home page.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-returned-to-home-page-after-user-signs-out&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page_huaaba3d4bf3897864ad8c0dbe2950fa00_42345_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;Returned to Home Page after user signs out.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/home-page_huaaba3d4bf3897864ad8c0dbe2950fa00_42345_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1338&#34; height=&#34;352&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Returned to Home Page after user signs out.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;sign-in-as-a-google-user&#34;&gt;Sign in as a Google User&lt;/h3&gt;
&lt;p&gt;Again, click on the &lt;strong&gt;Users&lt;/strong&gt; menu item to go to the Sign-In/Sign-Out page&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-standard-sign-in-page&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/sign-in-page_hu08d58e743afadb57a341d72a72bfa387_91827_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The Standard Sign-In Page.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/sign-in-page_hu08d58e743afadb57a341d72a72bfa387_91827_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1336&#34; height=&#34;868&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Standard Sign-In Page.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;This time however click on the Google &lt;strong&gt;Sign in&lt;/strong&gt; button. This will open the familiar Google Sign-In dialog where you can login with your Google identity. If the email address of the Google user is registered with an application user ID your session will assigned that identity, but the &lt;code&gt;:authority&lt;/code&gt; will now be &lt;code&gt;:google&lt;/code&gt;, indicating that is the entity making the assertion of identity.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-google-sign-in-dialog&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-login-dialog_hu00c65657a65268155e33b18fe1910fb9_72909_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The Google Sign-In Dialog.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-login-dialog_hu00c65657a65268155e33b18fe1910fb9_72909_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1178&#34; height=&#34;712&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Google Sign-In Dialog.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Again, you&amp;rsquo;ll be returned to the Home page where the session&amp;rsquo;s identity information is displayed.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-home-page-with-google-signed-in-user&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-user-login-home_hu0f008ac669061a5310176bfbdabf1530_48835_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The Home Page with Google signed-in user.&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-user-login-home_hu0f008ac669061a5310176bfbdabf1530_48835_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1478&#34; height=&#34;352&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Home Page with Google signed-in user.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Because &lt;strong&gt;&lt;a href=&#34;mailto:heykieran@gmail.com&#34;&gt;heykieran@gmail.com&lt;/a&gt;&lt;/strong&gt; is an alias for the user &lt;code&gt;:admin&lt;/code&gt;, that is the ID displayed in the top-right corner of the page, and consequently access to the API endpoints restricted to users in the &lt;code&gt;:admin&lt;/code&gt; role will be allowed.&lt;/p&gt;
&lt;h3 id=&#34;signing-out&#34;&gt;Signing Out&lt;/h3&gt;
&lt;p&gt;If you click on the &lt;strong&gt;Users&lt;/strong&gt; menu item you can return to the Sign-In/Sign-Out page to disconnect your session from the Google account using the &lt;strong&gt;Sign Out&lt;/strong&gt; button. This disconnects your application session, but does &lt;strong&gt;not&lt;/strong&gt; log you out from Google.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-the-users-page-with-a-signed-in-google-user-mapped-to-application-id-admin&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-user-sign-out-page_hua45813ca70e13bb9a469ee5545a5e2d9_106661_2000x2000_fit_lanczos_2.png&#34; data-caption=&#34;The Users page with a Signed-In Google user (mapped to application ID &amp;lt;code&amp;gt;:admin&amp;lt;/code&amp;gt;).&#34;&gt;


  &lt;img data-src=&#34;https://heykieran.github.io/post/pedestal-and-google/static/img/google-user-sign-out-page_hua45813ca70e13bb9a469ee5545a5e2d9_106661_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1340&#34; height=&#34;908&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The Users page with a Signed-In Google user (mapped to application ID &lt;code&gt;:admin&lt;/code&gt;).
  &lt;/figcaption&gt;


&lt;/figure&gt;

</description>
    </item>
    
    <item>
      <title>Cadence Workflow and Clojure</title>
      <link>https://heykieran.github.io/post/cadence-and-clojure/</link>
      <pubDate>Wed, 22 Apr 2020 11:10:38 -0400</pubDate>
      <guid>https://heykieran.github.io/post/cadence-and-clojure/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    A repository with some working code and implementation notes can be found &lt;a href=&#34;https://github.com/heykieran/cadence-test&#34;&gt;here&lt;/a&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I had the occasion recently to investigate, and cursorily evaluate, a number of workflow
orchestration systems for use on a project with which I was involved. One of those systems,

&lt;a href=&#34;https://cadenceworkflow.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Cadence&lt;/strong&gt;&lt;/a&gt;, particularly appealed to me - there was something very &lt;em&gt;Clojuresque&lt;/em&gt; about it;
certainly something very suggestive of a functional language.&lt;/p&gt;
&lt;p&gt;It has the concept of state &lt;em&gt;durability&lt;/em&gt; (in workflow functions) that bears more than a passing
resemblance to the persistent data structures of Clojure - but extended across time. This
concept, similar to checkpoints, opens avenues to consistent, predictable restarts after
failures. If one can restore the complete state of a system to a known &lt;em&gt;good-state&lt;/em&gt; then one can
continue as if the failure had never occurred. Of course, if system-wide (or even better,
distributed) non-volatile RAM ever becomes a reality then Cadence would not be needed. This
strikes me as essence of the problem Cadence is attempting to solve, or, at least, the gap it&amp;rsquo;s
attempting to bridge. Cadence also allows, through activities, the use of non-persistent
data structures which can be considered as being analogous to the concept of a &lt;em&gt;side-effect&lt;/em&gt; in Clojure.&lt;/p&gt;
&lt;p&gt;The separation of the &lt;em&gt;functional&lt;/em&gt; from the &lt;em&gt;side-effect&lt;/em&gt;-ing, and the elision of
infrastructure and communication failure concerns leaves developers with simpler, almost always
more tractable, domain logic concerns and significantly reduces the cognitive load.
This is similar to the benefits often realized through the adoption of functional languages.&lt;/p&gt;
&lt;h2 id=&#34;a-brief-tour-to-cadence&#34;&gt;A Brief Tour to Cadence&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://cadenceworkflow.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cadence&lt;/a&gt; is a workflow automation system developed by Uber. It shares many features
with other workflow automation systems but differs by being uniquely
&lt;em&gt;fault-oblivious&lt;/em&gt; rather than merely &lt;em&gt;fault-tolerant&lt;/em&gt;. The approach adopted by Cadence simplifies
greatly the work of developers who are relieved of many of the burdens of coordinating
activities and recovering from system or service failure.&lt;/p&gt;
&lt;p&gt;Cadence is complex but three concepts core to its understanding are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Cadence Service itself,&lt;/li&gt;
&lt;li&gt;Workflow Workers and&lt;/li&gt;
&lt;li&gt;Activity Workers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Cadence service, backed by a persistent data-store such as Cassandra or MySql, is responsible for
orchestrating the activities of both type of workers, for maintaining history, and in the case of failure,
for recovering the state of all workflows (but not activities).&lt;/p&gt;
&lt;p&gt;Conceptually, the Cadence service instructs a Workflow Worker to execute a Workflow function. The Workflow function,
which implements business logic, is guaranteed by Cadence to be &lt;em&gt;durable&lt;/em&gt;. That is, its state, including its
thread stack and thread-local variables, are known and stored by Cadence, and in the case of failure
they are restored.&lt;/p&gt;
&lt;p&gt;Workflows, like the business processes they typically model, may be long-running. It&amp;rsquo;s not unusual for a
real-world business process to take days or even months to complete, and Cadence provides excellent facilities
to support such long-running processes within workflow functions. Therefore, the durability of the workflow functions (with the guaranteed
recovery of their states across failures) enables a simple &lt;em&gt;straight-line&lt;/em&gt; view of the business logic. This
greatly reduces the complexity of the development process by reducing the burden on the developer to anticipate
and mitigate &lt;strong&gt;all&lt;/strong&gt; failure modes.&lt;/p&gt;
&lt;p&gt;In order to be able to guarantee durability across failures Cadence places a number of
restrictions on the code in Workflow functions. The code must be &lt;em&gt;deterministic&lt;/em&gt; i.e. executing the code
must produce the same result no matter how often it is run. Therefore, certain actions are forbidden within
workflow code - examples being: interacting &lt;strong&gt;directly&lt;/strong&gt; with external services, getting the time, getting random values,
and creating or suspending threads.&lt;/p&gt;
&lt;p&gt;These type of actions are fundamentally non-deterministic and would make full recovery of the workflow state impossible.
However, the Cadence API provides alternatives for &lt;strong&gt;some&lt;/strong&gt; of these that produce deterministic behavior; and
which assure the recoverability of the function&amp;rsquo;s local variables, threads and state.&lt;/p&gt;
&lt;p&gt;For situations requiring interaction with external services (&lt;em&gt;the outside world&lt;/em&gt;), Cadence insists
that all communication be conducted through Activities, using Activity Workers. Activities do not share with Workflows
any of Cadence&amp;rsquo;s requirement that they be deterministic. Essentially anything is allowed in activities and any
clean-up after failure becomes the responsibility of the developer rather than the Cadence service.&lt;/p&gt;
&lt;p&gt;Conceptually, &lt;em&gt;(but not precisely)&lt;/em&gt;, a Workflow Worker will start an Activity Worker (or multiple Activity Workers) to interact with the
outside world. Examples of an Activity might be interacting with a web-service, getting or saving a record to
a database, or awaiting human input, such as a decision. Cadence offers no guarantees about activity state,
and that state is not recovered in the case of failures of the Cadence infrastructure i.e. within the Cadence service itself.&lt;/p&gt;
&lt;p&gt;In order to control a running workflow, or to affect its state, it can be signalled using events delivered by Cadence.&lt;/p&gt;
&lt;h2 id=&#34;cadence--clojure-challenges&#34;&gt;Cadence &amp;amp; Clojure Challenges&lt;/h2&gt;
&lt;p&gt;The signature of the worker registration function is &lt;code&gt;registerWorkflowImplementationTypes(java.lang.Class&amp;lt;?&amp;gt;... workflowImplementationClasses)&lt;/code&gt;
and in the documentation there is the note&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The reason for registration accepting workflow class, but not the workflow instance is that workflows are stateful and a new instance is created for each workflow execution.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What&amp;rsquo;s not noted, but implied, is that the constructor for the classes must have zero-arg constructors. This is problematic
for Clojure as instance variable declared in &lt;code&gt;deftype&lt;/code&gt; will create on constructor taking exactly that number of instance variables as
arguments.&lt;/p&gt;
&lt;p&gt;You might then consider inheritance of the &lt;code&gt;deftype&lt;/code&gt;-d class to workaround the zero arg constructor issue
leaving a cleaner, more Clojure-esque result.&lt;/p&gt;
&lt;p&gt;However, although &lt;code&gt;deftype&lt;/code&gt; can create a Java class with the fields you need, by default these fields are immutable;
but you could use &lt;code&gt;:volatile-mutable&lt;/code&gt; to allow the fields to be settable. Unfortunately, the bigger problem
is that the generated class is &lt;code&gt;public final&lt;/code&gt; which effectively eliminates the possibility that we
could use the class as a base class in &lt;code&gt;gen-class&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This might have been helpful as we could define a zero-args constructor in &lt;code&gt;gen-class&lt;/code&gt; and then using the &lt;code&gt;:constructors&lt;/code&gt;
field map that constructor to the base class constructor and then assign default values to the field in the &lt;code&gt;:init&lt;/code&gt; method.
The fact that the &lt;code&gt;deftype&lt;/code&gt;-ed class is &lt;code&gt;final&lt;/code&gt; eliminates that approach.&lt;/p&gt;
&lt;h2 id=&#34;working-cadence--clojure-code&#34;&gt;Working Cadence &amp;amp; Clojure Code&lt;/h2&gt;
&lt;p&gt;In order to fully investigate using Clojure with Cadence I developed a small set of demos to demonstrate how it works,
works around what doesn&amp;rsquo;t, and exercises the result. &lt;strong&gt;Very&lt;/strong&gt; little consideration was given to making the code more idiomatic,
at least from a Clojure perspective, or even particularly effective. I only making the 
&lt;a href=&#34;https://github.com/heykieran/cadence-test&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repository&lt;/a&gt;
available as it may prove helpful to others who would like to use Clojure with Cadence.&lt;/p&gt;
&lt;p&gt;The repository also contains further notes on the implementation and lessons learnt.&lt;/p&gt;
&lt;h2 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s Next?&lt;/h2&gt;
&lt;p&gt;As time allows I&amp;rsquo;ll probably return to the code, making it more idiomatic. But do let me know if you find it helpful, or share
your suggestions for improvement.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting-up Pedestal/Jetty with HTTPS</title>
      <link>https://heykieran.github.io/post/pedestal-jetty-https/</link>
      <pubDate>Fri, 17 Apr 2020 13:39:37 -0400</pubDate>
      <guid>https://heykieran.github.io/post/pedestal-jetty-https/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Setting up Pedestal (using Jetty) with HTTPS isn&amp;rsquo;t that difficult, but
it is a bit &amp;ldquo;fiddly&amp;rdquo;. Essentially, you&amp;rsquo;ll need a keystore so that Jetty has
access to encryption keys and can encrypt pages sent over HTTPS.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This post only deals with self-signed certificates, but if you want to use
commercially-signed certificates it should work too.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Just be aware that Jetty is happiest with the &lt;code&gt;pkcs12&lt;/code&gt; format - I&amp;rsquo;ve never got it to work satisfactorily
using other formats.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Service Map (Pedestal)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In order to run Jetty under Pedestal you&amp;rsquo;ll need to supply a service map. The following service map works for me. You can change it as you need. The important elements in the
current context are where Jetty should look for the keystore (&lt;code&gt;keystore-location&lt;/code&gt;),
the &lt;code&gt;:ssl?&lt;/code&gt; key, the &lt;code&gt;:ssl-port&lt;/code&gt; and the &lt;code&gt;:security-provider&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Make sure the provider (Conscrypt) is in your &lt;code&gt;deps.edn&lt;/code&gt; file&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
(def service-map
  (let
    [keystore-location
     (if (System/getenv &amp;quot;KEYSTORE_LOCATION&amp;quot;)
       (-&amp;gt; (io/file (System/getenv &amp;quot;KEYSTORE_LOCATION&amp;quot;))
           (.getCanonicalPath))
       &amp;quot;/home/user/security/jetty-keystore&amp;quot;)]
    {::http/host &amp;quot;0.0.0.0&amp;quot;
     ::http/allowed-origins
                 {:allowed-origins (fn[_] true)
                  :creds true}
     ::http/routes #(deref #&#39;routes)
     ::http/type   :jetty
     ::http/container-options
     {:context-configurator jetty-websocket-configurator
      :h2c? true
      :h2 true
      :ssl? true
      :ssl-port 8081
      :keystore keystore-location
      :key-password &amp;quot;thepassword&amp;quot;
      :security-provider &amp;quot;Conscrypt&amp;quot;}
     ::http/port 8080}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Jetty Keystore&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In order for Pedestal to start with Jetty,
it expects to find a keystore in a particular location
(see &lt;em&gt;Service Map&lt;/em&gt; notes above).&lt;/p&gt;
&lt;p&gt;To create the keystore (I&amp;rsquo;ve plagiarized/assembled from the following
pieces of information web, and I&amp;rsquo;m afraid I can&amp;rsquo;t remember the source(s).)&lt;/p&gt;
&lt;p&gt;Generate a private site key (&lt;code&gt;site.key&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl genrsa -des3 -out site.key 2048
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Make a copy of &lt;code&gt;site.key&lt;/code&gt; and strip the password, so that it can be auto-loaded&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cp site.key site.orig.key
$ openssl rsa -in site.orig.key -out site.key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generate a self-signed signing request (&lt;code&gt;site.csr&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl req -new -key site.key -out site.csr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generate a self-signed certificate (&lt;code&gt;sitex509.crt&lt;/code&gt; - in &lt;strong&gt;x509&lt;/strong&gt; format for loading into the keystore)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl req -new -x509 -key site.key -out sitex509.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Combine the self-signed certificate (&lt;code&gt;sitex509.crt&lt;/code&gt;) and site key (&lt;code&gt;site.key&lt;/code&gt;) and
export it in &lt;strong&gt;pkcs12&lt;/strong&gt; format (&lt;code&gt;site.pkcs12&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl pkcs12 -inkey site.key -in sitex509.crt -export -out site.pkcs12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rename the keystore (&lt;code&gt;site.pkcs12&lt;/code&gt;) to jetty-keystore&lt;/p&gt;
&lt;p&gt;and adjust the service-map to use it&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
