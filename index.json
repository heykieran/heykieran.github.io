[{"authors":["heykieran"],"categories":null,"content":"Kieran Owens is the CTO of Timpson Gray\n","date":1588002788,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1588002788,"objectID":"1b59167ee93fdb1982478d476b8e75dd","permalink":"https://heykieran.github.io/author/kieran-owens/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/kieran-owens/","section":"authors","summary":"Kieran Owens is the CTO of Timpson Gray","tags":null,"title":"Kieran Owens","type":"authors"},{"authors":["admin"],"categories":null,"content":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://heykieran.github.io/author/nelson-bighetti/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/nelson-bighetti/","section":"authors","summary":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.","tags":null,"title":"Nelson Bighetti","type":"authors"},{"authors":["Kieran Owens"],"categories":["Blog Post"],"content":"Introduction The following are some notes about a repository containing working code (extracted from a larger project) demonstrating a combination of a secured Pedestal website (and associated API services), and a React-ive ClojureScript front-end application that utilizes either Google or bespoke login logic to identify and validate the user\u0026rsquo;s credentials, and sets his/her authorization levels.\nI hope that it may be helpful to anyone else who may know how each of the the individual pieces work, but is wondering how to put it all together.\nI owe a debt of gratitude to Tristan Straub, as much of the front-end logic (and code) to utilize Google\u0026rsquo;s login is based on some code he posted on Github. I\u0026rsquo;ve changed the code in many ways, so any errors are not his but mine.\nThe front-end application, which is intentionally simple, allows a user to login, and according to his/her permissions will allow access to various resources. The application is written using React/ReFrame, Semantic UI React and ClojureScript. The application uses Figwheel-main to compile and, in development mode run the front-end; but switching to a different tool-chain (e.g. shadow-cljs) should be relatively easy.\nFeatures Google Login Integration (and mapping to application id) The application demonstrates how to integrate Google\u0026rsquo;s login functionality with a ClojureScript application. After successfully authenticating with Google, the user\u0026rsquo;s Google email address is associated with one (and only one) internal application user ID. The internal user ID is associated internally with one or more application defined roles, which are defined in the code.\nConceivably, this mapping of external ID to internal ID could allow multiple external authentication services to be used to map multiple externally asserted identities to a single internal user ID. For example, by extending the application to use Facebook\u0026rsquo;s authentication service, it would be possible to have both user@gmail.com and user@facebook.com to be mapped to the same internal user ID, e.g. :user.\nFundamentally, authenticating and logging in merely associates a user with a web session. The session is the operative object and identities are not, and cannot be shared between sessions. A user may have multiple sessions open, but they don\u0026rsquo;t \u0026ldquo;mingle\u0026quot;.\nAd-hoc affirmative login method The application as presented allows a user to simply assert that they are a known user. The only reason this feature is included is to simplify debugging. In a production application these assertions would typically be replaced with an application specific logon process.\nIsolation of sensitive information from codebase In order to run Pedestal/Jetty (for production) or Figwheel/Jetty (for development) with https (required to use Google login) the location of a keystore and its password must be supplied.\nThis is an obvious security concern - including any sensitive information in either the source-code, or the application\u0026rsquo;s generated js code is poor security hygiene. The application avoids this by using environment variable (assumed to be available) to store this information which is read-only at runtime.\nSecured API end-points by role membership The application uses role-based security, where access to resources (URI\u0026rsquo;s) is permitted or prohibited according to whether a user has membership within a particular role. A user ID can be associated with one or more roles. Roles are independent of one another. There is no concept of hierarchy or inheritance beyond how the code chooses to handle these concepts.\nThe application, for our purposes, defines three roles: :admin, :user and :public. An unauthenticated user is associated with the role :public. Note that there is nothing privileged about these roles, or their names. They are completely application defined.\nIn the code for the application\u0026rsquo;s configuration file (common-src/config/config.cljc) you can see how these have been defined:\n(def roles-and-users {:admin {:roles #{:admin} :users #{\u0026quot;admin@timpsongray.com\u0026quot; \u0026quot;heykieran@gmail.com\u0026quot;}} :user {:roles #{:user} :users #{\u0026quot;user@timpsongray.com\u0026quot;}}})  Here, we\u0026rsquo;ve defined two users :user and :admin, along with two roles, also called :user and :admin. Users who authenticated with the email addresses admin@timpsongray.com and heykieran@gmail.com will be associated with the user ID :admin, and the user with the email address user@timpsongray.com will be associated with the user ID :user.\nIf we examine how routes are defined in the file server/be_handler_pdstl.clj we can see how security is applied to URL\u0026rsquo;s.\n(def routes (route/expand-routes #{[\u0026quot;/echo\u0026quot; :get echo] [\u0026quot;/auth/isauthenticated\u0026quot; :post (build-secured-route-vec-to app-auth/get-current-logged-in-user) :route-name :alloc-public/is-authenticated] [\u0026quot;/auth/setid\u0026quot; :post (build-secured-route-vec-to app-auth/alloc-auth-explicitly-set-identity-of-user-post) :route-name :alloc-public/auth-set-id-post] [\u0026quot;/auth/google\u0026quot; :post (build-secured-route-vec-to app-auth/alloc-auth-google-login) :route-name :alloc-public/google-login-post] [\u0026quot;/auth/logout\u0026quot; :post (build-secured-route-vec-to disconnect-session) :route-name :alloc-user/auth-logout-post] [\u0026quot;/api/getsecresource/p\u0026quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :alloc-public/test-res] [\u0026quot;/api/getsecresource/u\u0026quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :alloc-user/test-res] [\u0026quot;/api/getsecresource/a\u0026quot; :post (build-secured-route-vec-to get-secured-resource) :route-name :test-res] [\u0026quot;/r/home\u0026quot; :get [content-neg-intc respond-with-app-page] :route-name :app-main-page]}))  The current implementation uses the namespace of values of each route\u0026rsquo;s :route-name key to assign security.\nAny protected URL whose :route-name namespace is :alloc-public is available to any user, authenticated or not.\nAny protected URL whose :route-name namespace is :alloc-user is available to any user associated with the :user role.\nAny protected URL whose :route-name namespace is either :alloc-admin or the default namespace is available to only users associated with the :admin role.\n URL\u0026rsquo;s are only protected if they use the auth interceptors. These interceptors are included when the function build-secured-route-vec-to is used to wrap the content handler function.\n Another item to note is the three test URL\u0026rsquo;s /api/getsecresource/p (available to all users), /api/getsecresource/u (available to users in the :user role) and /api/getsecresource/a (available only to users in the :admin role) use the same handler get-secured-resource.\nDevelopment Server \u0026amp; Production Server The application has both a development mode and a production mode. Both modes use Pedestal as the API server, responding to requests as defined in the routes parameter used to start the server. The difference between the two modes is in how the js files are served, and in how front-end development proceeds, or not.\nIn development mode the application\u0026rsquo;s js files are served from a handler (fe-src/server/fe-handler) sitting behind figwheel/Jetty, and started using the script provided in scripts/server.clj. This facilitates the standard figwheel development process of having figwheel monitor a set of source directories and regenerate and reload any changed files as necessary. This should be familiar to anyone who\u0026rsquo;s used figwheel-main for ClojureScript development. An alias has been defined in the deps.edn file to start all the various servers and to start figwheel.\nIn production mode, the js files are served from the Pedestal/Jetty server itself. Of course, in order to do this the js files must have been previously compiled by figwheel. An alias has been defined in the deps.edn file for this purpose.\nLog-out Functionality The application allows the user to disassociate their session from their identity. Because the session is the operative object, this is essentially logging out.\nSession Expiration When credentials are issued for an authenticated user and associated with a session, the information will also contain an expiration date. If a user attempts to access a protected resource and the credentials are found to have expired, access is denied and the user\u0026rsquo;s credentials are disassociated from the session. This essentially logs that user out and he/she will need to reassociate their credentials with the session.\nReact/Reagent/Reframe/kee-frame Application The test application is a reactive application written in ClojureScript using reagent, reframe and kee-frame. It illustrates some of the principles required for a simple application of this type.\nSemantic UI Integration The toolkit used for widgets and styling is SemanticUI-react, and the application illustrates how the library can be used.\nRunning the Servers \u0026amp; Applications Setting up a keystore for HTTPS In order to run the web servers in secured mode you\u0026rsquo;ll need to create a keystore for the certificates used by the servers and make it available to Jetty. Instructions on how to do this can be found here.\nSetting up Google Login In order to use the application for yourself you will need to get your own Google Client ID. Instructions on how to do this can be found here.\nYou will also need to use the Google Console to inform Google of the Authorized Javascript Origins associated with your Client ID. These should be the names and ports of your https endpoints. For testing, these will typically be the server name and port of your Pedestal/Jetty and your figwheel/Jetty (for development mode only) servers.\nThe values should also be set in the following places\nIn your environment the following variables should be set\n   Environment Variable Value     ALLOC_KEYSTORE_PASSWORD The keystore\u0026rsquo;s password   ALLOC_KEYSTORE_LOCATION The keystore\u0026rsquo;s filesystem location   ALLOC_SSL_PORT The ssl port number used for Pedestal   ALLOC_PORT The port number used for Pedestal    In the common-src/config/config.cljc you will need to set the following variables\n   Configuration Variable Value     google-client-id your Google Client ID   my-hostname your server\u0026rsquo;s name   figwheel-ssl-port the port used by figwheel\u0026rsquo;s https server and serving the application\u0026rsquo;s js files   pedestal-port Pedestal\u0026rsquo;s HTTP port number (should match ALLOC_PORT).   pedestal-ssl-port Pedestal\u0026rsquo;s HTTPS port number (should match ALLOC_SSL_PORT)   google-callback-url change the server name in this variable to match your server\u0026rsquo;s name.    In the file dev.cljs.edn change the :open-url parameter to match your server\u0026rsquo;s name, and the ssl port used by figwheel. This should match https://\u0026lt;my-hostname\u0026gt;:\u0026lt;pedestal-ssl-port\u0026gt;/r/home.\nStarting the Server(s) Development Mode   In your IDE of choice, start a REPL (with the alias :main)\n  Load and execute the control namespace\n  Execute the function (start-dev) (It\u0026rsquo;s within a comment expression).\n  Log messages are sent to the REPL output stream, so you can monitor progress and activity.\n  When the Pedestal server has started, run the following from a command line\nclj -A:dev  This will start the front-end server used by figwheel on ports 9500 and figwheel-ssl-port and will start the figwheel watch process.\n  Your browser should automatically open to https://\u0026lt;my-hostname\u0026gt;:\u0026lt;figwheel-ssl-port\u0026gt;/r/home where the application will be loaded. (You should have set this in dev.cljs.edn as above).\n   When you\u0026rsquo;re finished and wish to stop the front-end server: from the Figwheel console you issue the :cljs/quit command to stop the Figwheel build process followed by Ctrl+C to stop the front-end server itself.   Production Mode Build the production application by running\nclj -A:prod  from the command line. This will generate the production js files from your ClojureScript sources. Then, from the command line run\nclj -A:main -m control  This will start the Pedestal server which in addition to serving API requests will also serve the js files built in the last step.\nFinally, open your browser and navigate to https://\u0026lt;my-hostname\u0026gt;:8081/r/home to display the application\u0026rsquo;s Home page.\nNavigating the Application The Home Page When the application first starts, you can go to the Home page\n  The initial view of the home page (no logged-in user).   The Application\u0026rsquo;s Menu The application is a SPA with client-side routing and has only a single menu with 5 menu items.\n  The main menu (no logged-in user).    The Home item will take you to the Home page The Users menu item will display the application\u0026rsquo;s Sign-In/Sign-Out page. Here you can connect an identity to your session (log-in), or disconnect an identity from your session (log-out). The Public menu item will request content from an unsecured API endpoint whose content is available to any user whether authenticated or not. The User menu item will request content from an an API endpoint to which access has been restricted to users with role memberships of :admin or :user. The Admin menu item will request content from an an API endpoint to which access has been restricted to users with role membership of :admin.  Access a Public Resource Even though you have not yet signed in, if you click on the Public menu item the application will respond with some content.\n  Access to Public Resource is allowed (no logged-in user).   This is as expected as that resource is unsecured and available to anyone who can access the application.\nSign-In as the :local/:user User On the Sign-In Page, click on the button labelled user@timpsongray.com. This will associate you session with the application user :user, who has been assigned the :user role. This form of sign-in is a :local authority sign-in. The authority is granted by the application itself.\n  The Standard Sign-In Page (no logged-in user).   Once you\u0026rsquo;ve done that you\u0026rsquo;ll be redirected to the Home page where your session and identity details are displayed.\n  After the user :user has signed in.   Accessing a protected resource Now click on the User menu item. The application will attempt to fetch a resource from an API endpoint restricted to users in the :user or :admin roles.\nBecause :user has that role association the contents of the resource is displayed.\n  The user (:user) is allowed to access to the User resource.   However, if you now click on the Admin menu item, which attempts to fetch data from an API endpoint restricted to :admin role members only, you\u0026rsquo;ll see an access denied message.\n  The user (:user) is denied access to the Admin resource.   Sign-Out from :user Click on the Users menu item to go to the Sign-In/Sign-Out page\n  A view of the standard Sign-Out page with user (:user) is logged in.   and at the bottom click on the button in Sign-Out (Local) section. This will remove the identity information from your session, and return you to the Home page.\n  Returned to Home Page after user signs out.   Sign in as a Google User Again, click on the Users menu item to go to the Sign-In/Sign-Out page\n  The Standard Sign-In Page.   This time however click on the Google Sign in button. This will open the familiar Google Sign-In dialog where you can login with your Google identity. If the email address of the Google user is registered with an application user ID your session will assigned that identity, but the :authority will now be :google, indicating that is the entity making the assertion of identity.\n  The Google Sign-In Dialog.   Again, you\u0026rsquo;ll be returned to the Home page where the session\u0026rsquo;s identity information is displayed.\n  The Home Page with Google signed-in user.   Because heykieran@gmail.com is an alias for the user :admin, that is the ID displayed in the top-right corner of the page, and consequently access to the API endpoints restricted to users in the :admin role will be allowed.\nSigning Out If you click on the Users menu item you can return to the Sign-In/Sign-Out page to disconnect your session from the Google account using the Sign Out button. This disconnects your application session, but does not log you out from Google.\n  The Users page with a Signed-In Google user (mapped to application ID :admin).   ","date":1588002788,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588002788,"objectID":"37f4baad1635bb85122b7742e828e506","permalink":"https://heykieran.github.io/post/pedestal-and-google/","publishdate":"2020-04-27T11:53:08-04:00","relpermalink":"/post/pedestal-and-google/","section":"post","summary":"A longer discussion of my publicly available GitHub repository containing a secured Pedestal API server and ClojureScript/React SPA that can use Google login to authenticate a user. I show how to set up HTTPS, integrate with Google and secure API endpoints in the context of a simple React application.","tags":["clojure","clojurescript","pedestal","react","security"],"title":"Pedestal API, ClojureScript SPA and Google Authentication","type":"post"},{"authors":["Kieran Owens"],"categories":["Blog Post"],"content":"Introduction  A repository with some working code and implementation notes can be found here.   I had the occasion recently to investigate, and cursorily evaluate, a number of workflow orchestration systems for use on a project with which I was involved. One of those systems, Cadence, particularly appealed to me - there was something very Clojuresque about it; certainly something very suggestive of a functional language.\nIt has the concept of state durability (in workflow functions) that bears more than a passing resemblance to the persistent data structures of Clojure - but extended across time. This concept, similar to checkpoints, opens avenues to consistent, predictable restarts after failures. If one can restore the complete state of a system to a known good-state then one can continue as if the failure had never occurred. Of course, if system-wide (or even better, distributed) non-volatile RAM ever becomes a reality then Cadence would not be needed. This strikes me as essence of the problem Cadence is attempting to solve, or, at least, the gap it\u0026rsquo;s attempting to bridge. Cadence also allows, through activities, the use of non-persistent data structures which can be considered as being analogous to the concept of a side-effect in Clojure.\nThe separation of the functional from the side-effect-ing, and the elision of infrastructure and communication failure concerns leaves developers with simpler, almost always more tractable, domain logic concerns and significantly reduces the cognitive load. This is similar to the benefits often realized through the adoption of functional languages.\nA Brief Tour to Cadence  Cadence is a workflow automation system developed by Uber. It shares many features with other workflow automation systems but differs by being uniquely fault-oblivious rather than merely fault-tolerant. The approach adopted by Cadence simplifies greatly the work of developers who are relieved of many of the burdens of coordinating activities and recovering from system or service failure.\nCadence is complex but three concepts core to its understanding are\n The Cadence Service itself, Workflow Workers and Activity Workers  The Cadence service, backed by a persistent data-store such as Cassandra or MySql, is responsible for orchestrating the activities of both type of workers, for maintaining history, and in the case of failure, for recovering the state of all workflows (but not activities).\nConceptually, the Cadence service instructs a Workflow Worker to execute a Workflow function. The Workflow function, which implements business logic, is guaranteed by Cadence to be durable. That is, its state, including its thread stack and thread-local variables, are known and stored by Cadence, and in the case of failure they are restored.\nWorkflows, like the business processes they typically model, may be long-running. It\u0026rsquo;s not unusual for a real-world business process to take days or even months to complete, and Cadence provides excellent facilities to support such long-running processes within workflow functions. Therefore, the durability of the workflow functions (with the guaranteed recovery of their states across failures) enables a simple straight-line view of the business logic. This greatly reduces the complexity of the development process by reducing the burden on the developer to anticipate and mitigate all failure modes.\nIn order to be able to guarantee durability across failures Cadence places a number of restrictions on the code in Workflow functions. The code must be deterministic i.e. executing the code must produce the same result no matter how often it is run. Therefore, certain actions are forbidden within workflow code - examples being: interacting directly with external services, getting the time, getting random values, and creating or suspending threads.\nThese type of actions are fundamentally non-deterministic and would make full recovery of the workflow state impossible. However, the Cadence API provides alternatives for some of these that produce deterministic behavior; and which assure the recoverability of the function\u0026rsquo;s local variables, threads and state.\nFor situations requiring interaction with external services (the outside world), Cadence insists that all communication be conducted through Activities, using Activity Workers. Activities do not share with Workflows any of Cadence\u0026rsquo;s requirement that they be deterministic. Essentially anything is allowed in activities and any clean-up after failure becomes the responsibility of the developer rather than the Cadence service.\nConceptually, (but not precisely), a Workflow Worker will start an Activity Worker (or multiple Activity Workers) to interact with the outside world. Examples of an Activity might be interacting with a web-service, getting or saving a record to a database, or awaiting human input, such as a decision. Cadence offers no guarantees about activity state, and that state is not recovered in the case of failures of the Cadence infrastructure i.e. within the Cadence service itself.\nIn order to control a running workflow, or to affect its state, it can be signalled using events delivered by Cadence.\nCadence \u0026amp; Clojure Challenges The signature of the worker registration function is registerWorkflowImplementationTypes(java.lang.Class\u0026lt;?\u0026gt;... workflowImplementationClasses) and in the documentation there is the note\n The reason for registration accepting workflow class, but not the workflow instance is that workflows are stateful and a new instance is created for each workflow execution.\n What\u0026rsquo;s not noted, but implied, is that the constructor for the classes must have zero-arg constructors. This is problematic for Clojure as instance variable declared in deftype will create on constructor taking exactly that number of instance variables as arguments.\nYou might then consider inheritance of the deftype-d class to workaround the zero arg constructor issue leaving a cleaner, more Clojure-esque result.\nHowever, although deftype can create a Java class with the fields you need, by default these fields are immutable; but you could use :volatile-mutable to allow the fields to be settable. Unfortunately, the bigger problem is that the generated class is public final which effectively eliminates the possibility that we could use the class as a base class in gen-class.\nThis might have been helpful as we could define a zero-args constructor in gen-class and then using the :constructors field map that constructor to the base class constructor and then assign default values to the field in the :init method. The fact that the deftype-ed class is final eliminates that approach.\nWorking Cadence \u0026amp; Clojure Code In order to fully investigate using Clojure with Cadence I developed a small set of demos to demonstrate how it works, works around what doesn\u0026rsquo;t, and exercises the result. Very little consideration was given to making the code more idiomatic, at least from a Clojure perspective, or even particularly effective. I only making the repository available as it may prove helpful to others who would like to use Clojure with Cadence.\nThe repository also contains further notes on the implementation and lessons learnt.\nWhat\u0026rsquo;s Next? As time allows I\u0026rsquo;ll probably return to the code, making it more idiomatic. But do let me know if you find it helpful, or share your suggestions for improvement.\n","date":1587568238,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587568238,"objectID":"ea85603ab754bf4e179277cf351907ed","permalink":"https://heykieran.github.io/post/cadence-and-clojure/","publishdate":"2020-04-22T11:10:38-04:00","relpermalink":"/post/cadence-and-clojure/","section":"post","summary":"How to use Clojure with the Cadence Workflow orchestration system. Some background on Cadence, and links to a working code repository with implementation notes.","tags":["clojure","cadence"],"title":"Cadence Workflow and Clojure","type":"post"},{"authors":["Kieran Owens"],"categories":["Blog Post"],"content":"Introduction\nSetting up Pedestal (using Jetty) with HTTPS isn\u0026rsquo;t that difficult, but it is a bit \u0026ldquo;fiddly\u0026rdquo;. Essentially, you\u0026rsquo;ll need a keystore so that Jetty has access to encryption keys and can encrypt pages sent over HTTPS.\nThis post only deals with self-signed certificates, but if you want to use commercially-signed certificates it should work too.\n Just be aware that Jetty is happiest with the pkcs12 format - I\u0026rsquo;ve never got it to work satisfactorily using other formats.   Service Map (Pedestal)\nIn order to run Jetty under Pedestal you\u0026rsquo;ll need to supply a service map. The following service map works for me. You can change it as you need. The important elements in the current context are where Jetty should look for the keystore (keystore-location), the :ssl? key, the :ssl-port and the :security-provider.\nMake sure the provider (Conscrypt) is in your deps.edn file\n (def service-map (let [keystore-location (if (System/getenv \u0026quot;KEYSTORE_LOCATION\u0026quot;) (-\u0026gt; (io/file (System/getenv \u0026quot;KEYSTORE_LOCATION\u0026quot;)) (.getCanonicalPath)) \u0026quot;/home/user/security/jetty-keystore\u0026quot;)] {::http/host \u0026quot;0.0.0.0\u0026quot; ::http/allowed-origins {:allowed-origins (fn[_] true) :creds true} ::http/routes #(deref #'routes) ::http/type :jetty ::http/container-options {:context-configurator jetty-websocket-configurator :h2c? true :h2 true :ssl? true :ssl-port 8081 :keystore keystore-location :key-password \u0026quot;thepassword\u0026quot; :security-provider \u0026quot;Conscrypt\u0026quot;} ::http/port 8080}))  Jetty Keystore\nIn order for Pedestal to start with Jetty, it expects to find a keystore in a particular location (see Service Map notes above).\nTo create the keystore (I\u0026rsquo;ve plagiarized/assembled from the following pieces of information web, and I\u0026rsquo;m afraid I can\u0026rsquo;t remember the source(s).)\nGenerate a private site key (site.key)\n$ openssl genrsa -des3 -out site.key 2048  Make a copy of site.key and strip the password, so that it can be auto-loaded\n$ cp site.key site.orig.key $ openssl rsa -in site.orig.key -out site.key  Generate a self-signed signing request (site.csr)\n$ openssl req -new -key site.key -out site.csr  Generate a self-signed certificate (sitex509.crt - in x509 format for loading into the keystore)\n$ openssl req -new -x509 -key site.key -out sitex509.crt  Combine the self-signed certificate (sitex509.crt) and site key (site.key) and export it in pkcs12 format (site.pkcs12)\n$ openssl pkcs12 -inkey site.key -in sitex509.crt -export -out site.pkcs12  Rename the keystore (site.pkcs12) to jetty-keystore\nand adjust the service-map to use it\n","date":1587145177,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587145177,"objectID":"caa521ff1fb0576fd01e59f1ba4c95e2","permalink":"https://heykieran.github.io/post/pedestal-jetty-https/","publishdate":"2020-04-17T13:39:37-04:00","relpermalink":"/post/pedestal-jetty-https/","section":"post","summary":"Introduction\nSetting up Pedestal (using Jetty) with HTTPS isn\u0026rsquo;t that difficult, but it is a bit \u0026ldquo;fiddly\u0026rdquo;. Essentially, you\u0026rsquo;ll need a keystore so that Jetty has access to encryption keys and can encrypt pages sent over HTTPS.","tags":["clojure","pedestal","https"],"title":"Setting-up Pedestal/Jetty with HTTPS","type":"post"}]